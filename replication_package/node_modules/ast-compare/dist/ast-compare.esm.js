/**
 * @name ast-compare
 * @fileoverview Compare anything: AST, objects, arrays, strings and nested thereof
 * @version 4.0.25
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ast-compare/}
 */

import i from"type-detect";import{empty as s}from"ast-contains-only-empty-space";import{isPlainObject as o,hasOwnProp as O}from"codsen-utils";import{isMatch as m}from"matcher";var f="4.0.25";var x=f;function V(e){return o(e)?!Object.keys(e).length:Array.isArray(e)||typeof e=="string"?!e.length:!1}var j={hungryForWhitespace:!1,matchStrictly:!1,verboseWhenMismatches:!1,useWildcards:!1};function d(e,t,b){let c,u,h,g=0,r={...j,...b};if(r.hungryForWhitespace&&r.matchStrictly&&o(e)&&s(e)&&o(t)&&!Object.keys(t).length)return!0;if((!r.hungryForWhitespace||r.hungryForWhitespace&&!s(e)&&s(t))&&o(e)&&Object.keys(e).length!==0&&o(t)&&Object.keys(t).length===0||i(e)!==i(t)&&(!r.hungryForWhitespace||r.hungryForWhitespace&&!s(e)))return!1;if(typeof e=="string"&&typeof t=="string")return r.hungryForWhitespace&&s(e)&&s(t)?!0:r.verboseWhenMismatches?e===t?!0:`Given string ${t} is not matched! We have ${e} on the other end.`:r.useWildcards?m(e,t,{caseSensitive:!0}):e===t;if(Array.isArray(e)&&Array.isArray(t)){if(r.hungryForWhitespace&&s(t)&&(!r.matchStrictly||r.matchStrictly&&e.length===t.length))return!0;if(!r.hungryForWhitespace&&t.length>e.length||r.matchStrictly&&t.length!==e.length)return r.verboseWhenMismatches?`The length of a given array, ${JSON.stringify(t,null,4)} is ${t.length} but the length of an array on the other end, ${JSON.stringify(e,null,4)} is ${e.length}`:!1;if(t.length===0)return e.length===0?!0:r.verboseWhenMismatches?`The given array has no elements, but the array on the other end, ${JSON.stringify(e,null,4)} does have some`:!1;for(let n=0,a=t.length;n<a;n++){h=!1;for(let l=g,y=e.length;l<y;l++)if(g+=1,d(e[l],t[n],r)===!0){h=!0;break}if(!h)return r.verboseWhenMismatches?`The given array ${JSON.stringify(t,null,4)} is not a subset of an array on the other end, ${JSON.stringify(e,null,4)}`:!1}}else if(o(e)&&o(t)){if(c=new Set(Object.keys(t)),u=new Set(Object.keys(e)),r.matchStrictly&&c.size!==u.size){if(!r.verboseWhenMismatches)return!1;let n=new Set([...c].filter(p=>!u.has(p))),a=n.size?` First object has unique keys: ${JSON.stringify(n,null,4)}.`:"",l=new Set([...u].filter(p=>!c.has(p))),y=l.size?` Second object has unique keys:
        ${JSON.stringify(l,null,4)}.`:"";return`When matching strictly, we found that both objects have different amount of keys.${a}${y}`}for(let n of c){if(!O(e,n))return!r.useWildcards||r.useWildcards&&!n.includes("*")?r.verboseWhenMismatches?`The given object has key "${n}" which the other-one does not have.`:!1:Object.keys(e).some(a=>m(a,n,{caseSensitive:!0}))?!0:r.verboseWhenMismatches?`The given object has key "${n}" which the other-one does not have.`:!1;if(e[n]!=null&&i(e[n])!==i(t[n])){if(!(s(e[n])&&s(t[n])&&r.hungryForWhitespace))return r.verboseWhenMismatches?`The given key ${n} is of a different type on both objects. On the first-one, it's ${i(t[n])}, on the second-one, it's ${i(e[n])}`:!1}else if(d(e[n],t[n],r)!==!0)return r.verboseWhenMismatches?`The given piece ${JSON.stringify(t[n],null,4)} and ${JSON.stringify(e[n],null,4)} don't match.`:!1}}else return r.hungryForWhitespace&&s(e)&&s(t)&&(!r.matchStrictly||r.matchStrictly&&V(t))?!0:e===t;return!0}export{d as compare,j as defaults,x as version};
