The Node.js code provided defines a custom class called `Minipass` that acts as both writable and readable stream, implementing basic stream functionality with an asynchronous option. This class extends from `EventEmitter`, allowing it to emit events like 'data' and 'end'. Here's a breakdown of its functionality:

1. **Constructor:**
   - Initializes options like `encoding`, `objectMode`, `async`.
   - Sets up internal state variables: `buffer`, `writable`, `readable`, `flowing`, and `emittedEnd`.

2. **write method:**
   - Adds `chunk` to the internal buffer.
   - Converts string chunks to Buffer if encoding is specified and object mode is off.
   - Triggers `emitData` to send out buffered data if the stream is flowing.

3. **end method:**
   - Finalizes the stream by marking it as not writable and optionally writing a final `chunk`.
   - Calls `emitEnd` if the buffer is empty.

4. **emitData method:**
   - Emits buffered data chunks one by one when the stream is in flowing mode.
   - Calls `emitEnd` if there are no more chunks and the stream has ended.

5. **emitEnd method:**
   - Emits 'end' event to signal that the stream has finished.

6. **pipe method:**
   - Connects this stream to a writable destination stream by setting `flowing` to true and handling 'data' and 'end' events.

7. **resume method:**
   - Resumes emitting data if the stream is paused.

8. **pause method:**
   - Stops the stream from emitting data.

Here's a possible rewrite of the original code:

```javascript
const { EventEmitter } = require('events');

class Minipass extends EventEmitter {
  constructor(options = {}) {
    super();
    const { encoding = null, objectMode = false, async = false } = options;
    this.encoding = encoding;
    this.objectMode = objectMode;
    this.async = async;
    this.buffer = [];
    this.writable = true;
    this.readable = true;
    this.flowing = null;
    this.emittedEnd = false;
  }

  write(chunk, encoding, cb) {
    if (!this.writable) throw new Error('Stream is not writable');
    if (!this.objectMode && typeof chunk !== 'string' && !Buffer.isBuffer(chunk)) {
      throw new Error('Invalid chunk type');
    }
    if (this.encoding && typeof chunk === 'string') {
      chunk = Buffer.from(chunk, this.encoding);
    }
    this.buffer.push(chunk);
    if (this.flowing === null) this.flowing = true;
    if (this.flowing) this.emitData();
    if (cb) cb();
    return this.flowing;
  }

  end(chunk, encoding, cb) {
    if (!this.writable) throw new Error('Stream is not writable');
    if (chunk) this.write(chunk, encoding);
    this.writable = false;
    if (cb) cb();
    if (this.buffer.length === 0) this.emitEnd();
  }

  emitData() {
    while (this.flowing && this.buffer.length > 0) {
      const chunk = this.buffer.shift();
      this.emit('data', chunk);
    }
    if (!this.emittedEnd && this.buffer.length === 0) this.emitEnd();
  }

  emitEnd() {
    if (this.emittedEnd) return;
    this.emittedEnd = true;
    this.readable = false;
    this.emit('end');
  }

  pipe(dest) {
    this.flowing = true;
    this.on('data', chunk => dest.write(chunk));
    this.on('end', () => dest.end());
    return dest;
  }

  resume() {
    if (!this.flowing) {
      this.flowing = true;
      this.emitData();
    }
  }

  pause() {
    this.flowing = false;
  }
}

module.exports = { Minipass };
```