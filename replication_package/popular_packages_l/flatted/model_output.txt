The `flatted` package is a lightweight and fast circular JSON parser, designed to handle circular references in JavaScript objects during serialization and deserialization. It is an alternative to the standard `JSON` object, which cannot handle circular references by default. The main features of `flatted` include:

1. **Stringifying Circular References**: The `flatted.stringify()` function allows you to serialize complex objects, including those with circular references, into a JSON-compatible format. This involves identifying unique objects within the input and replacing repeated references with unique indexes to prevent circularity.

2. **Parsing Circular Structures**: The `flatted.parse()` function rehydrates or reconstructs the object from the serialized format, maintaining the original circular references during the deserialization process.

3. **Exact JSON API Compatibility**: The methods `stringify` and `parse` support replacer and reviver functions, similar to native JSON methods, offering enhanced customization for serialization and deserialization.

4. **JSON Serialization with Circular Reference Handling**: `toJSON()` and `fromJSON()` helpers are provided to handle implicit serialization and deserialization, useful in classes that may have circular references.

5. **Naming Conventions**: The serializers produce a string array where objects and arrays are replaced by their index as strings. This avoids conflicts with numerical indexes and preserves reference integrity.

Below is a Node.js implementation of the `flatted` package:

```javascript
// flatted.js
'use strict';

const Primitive = String;
const primitive = 'string';

function stringify(value, replacer, space) {
  let index = null, // index in the array
      stringified = new Primitive('0'); // all unique items

  function flatten(object, map) {
    let tmp = (typeof object === primitive) ? object : (map.get(object) || new Primitive('' + (++index)));

    if (!map.has(object)) {
      map.set(object, tmp); // Track object with index in map

      if (typeof object === 'object' && object) {
        const isArray = Array.isArray(object), arrTmp = isArray ? [] : {};

        map.set(tmp, isArray ? [] : arrTmp); // Set storage place in case of references

        // Traverse object
        if (isArray) {
          object.forEach((value, i) => arrTmp[i] = flatten(value, map));
          tmp = arrTmp;
        } else {
          for (const key in object) {
            arrTmp[key] = flatten(object[key], map);
          }
          tmp = arrTmp;
        }
      }
    }
    return tmp;
  }

  const result = flatten(value, new Map());
  return JSON.stringify(result, replacer, space);
}

function parse(text, reviver) {
  const input = JSON.parse(text);
  const map = new Map();

  function build(object) {
    const reconstructed = Array.isArray(object) ? [] : {};

    map.set(object, reconstructed);

    if (Array.isArray(object)) {
      object.forEach((item, i) => {
        if (typeof item == primitive) {
          map.has(item) ? reconstructed[i] = map.get(item) : map.set(item, reconstructed[i] = []);
        } else {
          reconstructed[i] = item;
        }
      });
    } else {
      for (const key in object) {
        const value = object[key];
        if (typeof value == primitive) {
          map.has(value) ? reconstructed[key] = map.get(value) : map.set(value, reconstructed[key] = {});
        } else {
          reconstructed[key] = value;
        }
      }
    }
    return reconstructed;
  }

  const fixed = build(input);
  return reviver ? (function revive(obj, k) {
    const v = obj[k];
    if (v && typeof v === 'object') {
      obj[k] = null;
      for (k in v) {
        revive(v, k);
      }
      obj[k] = reviver.call(obj, k, v);
    }
  })(fixed, '') : fixed;
}

function toJSON(value) {
  return stringify(value);
}

function fromJSON(value, reviver) {
  return parse(value, reviver);
}

module.exports = {
  stringify,
  parse,
  toJSON,
  fromJSON
};
```

This code includes the implementation of `stringify`, `parse`, `toJSON`, and `fromJSON` functions, which allow manipulation of objects containing circular references, offering a JSON-compatible output. It uses `Map` to maintain identity mapping during serialization and deserialization, providing a valid reconstruction of the original object structure.