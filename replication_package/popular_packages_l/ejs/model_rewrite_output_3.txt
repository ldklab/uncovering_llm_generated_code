The provided Node.js code is a custom implementation of an Embedded JavaScript (EJS) template engine. The functionality can be summarized as follows:

1. **Initialization**: 
    - The `EJS` class is set up with default delimiters (`%`) and uses maps to cache compiled templates.
  
2. **Template Compilation**:
    - The `compile` method converts a template string into a reusable rendering function. It supports interpolation using custom delimiters. Escaped and unescaped tags are supported with `=` and `-` prefixed in the template.

3. **Rendering**:
    - The `render` method takes a template as a string or compiled function and a data object to produce the final string output.
    - The `renderFile` method reads a template from a file, then compiles and renders it asynchronously, supporting callback for handling results.
    - The `renderFileSync` method works similarly to `renderFile`, but operates synchronously.

4. **Include Another Template**:
    - The `include` method allows the inclusion of another template within a template, caching the compiled templates to enhance performance.

Here's a possible rewrite of the provided code:

```javascript
const fs = require('fs');
const path = require('path');

class EJS {
  constructor() {
    this.cache = new Map();
    this.delimiter = '%';
    this.openDelimiter = '<';
    this.closeDelimiter = '>';
  }

  compile(template, options = {}) {
    const delimiter = options.delimiter || this.delimiter;
    const open = options.openDelimiter || this.openDelimiter;
    const close = options.closeDelimiter || this.closeDelimiter;
    const regex = new RegExp(`${open}${delimiter}(.*?)${delimiter}${close}`, 'g');

    const transformedTemplate = template.replace(regex, (_, code) => {
      const trimmedCode = code.trim();
      const isEscaped = trimmedCode.startsWith('=');
      const isUnescaped = trimmedCode.startsWith('-');
      const renderExpression = isEscaped ? `echo(${trimmedCode.slice(1).trim()})` :
                          isUnescaped ? `unescape(${trimmedCode.slice(1).trim()})` :
                          trimmedCode;
      return `; ${renderExpression}; __output +=\``;
    });

    return new Function('data', 'echo', 'unescape', `
      let __output = '';
      with (data || {}) {
        __output += \`${transformedTemplate}\`;
      }
      return __output;
    `);
  }

  render(template, data, options) {
    const renderFn = this.compile(template, options);
    return renderFn(data, e => e, ue => ue);
  }

  renderFile(filePath, data, options = {}, callback) {
    fs.readFile(filePath, 'utf8', (err, content) => {
      if (err) return callback(err);
      try {
        const result = this.render(content, data, options);
        callback(null, result);
      } catch (error) {
        callback(error);
      }
    });
  }

  renderFileSync(filePath, data, options = {}) {
    const content = fs.readFileSync(filePath, 'utf8');
    return this.render(content, data, options);
  }

  include(templatePath, data) {
    const absolutePath = path.resolve(templatePath);
    if (this.cache.has(absolutePath)) {
      return this.cache.get(absolutePath)(data);
    }
    const content = fs.readFileSync(absolutePath, 'utf8');
    const compiledTemplate = this.compile(content);
    this.cache.set(absolutePath, compiledTemplate);
    return compiledTemplate(data);
  }
}

module.exports = new EJS();
```