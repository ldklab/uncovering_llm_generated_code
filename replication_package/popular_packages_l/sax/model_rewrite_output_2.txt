The given Node.js code defines a simple SAX (Simple API for XML) parser that processes XML-like data, emitting events for open tags, close tags, text, comments, and attributes. The parser can operate in either strict or non-strict mode and allows resetting its state. It utilizes the Node.js `EventEmitter` to handle these events.

### Explanation:

- **SAXParser Class**: Inherits from `EventEmitter`. It initializes with a `strict` flag and optional parameters, providing methods to reset the parser, write data, and close the stream.
  
- **reset() Method**: Resets the parser's attributes related to line, column, position, error state, and whether it's closed.

- **write(data) Method**: Handles the data parsing by calling `parse(data)` and emits an error event if an exception is caught.

- **close() Method**: Marks the parsing process as closed and emits an `end` event.

- **parse(data) Method**: A mock implementation of parsing XML-like strings, using regex to find and emit events for open tags, close tags, text content, comments, and attributes.

- **Parser Factory Functions**: 
  - `parser(strict, opt)`: Creates and returns a new `SAXParser` instance.
  - `createStream(strict, opt)`: Wraps the `SAXParser` in a stream-like interface for writing and ending data streams, allowing event piping.

### Rewritten Code:

```javascript
const EventEmitter = require('events');

class SimpleSAXParser extends EventEmitter {
  constructor(strictMode = false, options = {}) {
    super();
    this.strictMode = strictMode;
    this.options = options;
    this.resetParserState();
  }

  resetParserState() {
    this.currentLine = 1;
    this.currentColumn = 0;
    this.currentPosition = 0;
    this.currentError = null;
    this.isClosed = false;
  }

  processDataChunk(dataChunk) {
    try {
      this.simulateParsing(dataChunk);
      return this;
    } catch (parseError) {
      this.emit('error', parseError);
    }
  }

  finishParsing() {
    this.isClosed = true;
    this.emit('end');
  }

  simulateParsing(inputData) {
    let regexMatch;
    const tagStartPattern = /<([^>\/\s]+)[^>]*>/g;
    const tagEndPattern = /<\/([^>]+)>/g;
    const textContentPattern = />([^<]+)</g;
    const commentPattern = /<!--(.*?)-->/g;
    const attributePattern = /(\w+)=["']?((?:.(?!["']?\s+(?:\S+)=|["']))+.)["']?/g;
    
    while ((regexMatch = tagStartPattern.exec(inputData))) {
      const tagName = regexMatch[1];
      this.emit('opentagstart', { name: tagName, attributes: {} });

      const tagAttributes = {};
      let attributeMatch;
      while ((attributeMatch = attributePattern.exec(regexMatch[0]))) {
        tagAttributes[attributeMatch[1]] = attributeMatch[2];
        this.emit('attribute', { name: attributeMatch[1], value: attributeMatch[2] });
      }
      this.emit('opentag', { name: tagName, attributes: tagAttributes });
    }

    while ((regexMatch = tagEndPattern.exec(inputData))) {
      const tagName = regexMatch[1];
      this.emit('closetag', tagName);
    }

    while ((regexMatch = textContentPattern.exec(inputData))) {
      const textContent = regexMatch[1].trim();
      if (textContent) {
        this.emit('text', textContent);
      }
    }

    while ((regexMatch = commentPattern.exec(inputData))) {
      this.emit('comment', regexMatch[1].trim());
    }
  }
}

function createParser(strictMode = false, options = {}) {
  return new SimpleSAXParser(strictMode, options);
}

function initializeStream(strictMode = false, options = {}) {
  const saxParser = new SimpleSAXParser(strictMode, options);
  
  const streamInterface = new EventEmitter();
  streamInterface.write = (dataChunk) => saxParser.processDataChunk(dataChunk);
  streamInterface.end = () => saxParser.finishParsing();

  streamInterface.pipe = function (destination) {
    this.on('data', (data) => destination.write(data));
    return destination;
  };

  saxParser.on('end', () => streamInterface.emit('end'));
  saxParser.on('error', (error) => streamInterface.emit('error', error));
  
  return streamInterface;
}

module.exports = { createParser, initializeStream };
```