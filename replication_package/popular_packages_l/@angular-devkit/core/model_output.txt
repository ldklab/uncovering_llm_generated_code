The functionality described in the README.md is about a series of interfaces and classes designed around managing JSON schemas and Angular workspaces within a Node.js environment, benefiting Angular developers by providing shared utilities.

1. **Schema Interfaces and Classes:**
   - `SchemaValidatorResult`: This interface defines the result of a schema validation, containing the properties `success` (a boolean indicating the validation result) and optionally `errors` (an array of error messages).
   - `SchemaValidator`: An interface for a function that takes any data and returns an `Observable` of `SchemaValidatorResult`. This abstracts the process of validating data against a schema.
   - `SchemaFormatter`: An interface representing a schema formatter, containing a boolean `async` property indicating if the validation is asynchronous and a `validate` method to perform the actual validation either synchronously or asynchronously.
   - `SchemaRegistry`: This interface provides methods for compiling a schema to a validator and adding custom formatters to interpret schema-specific data formats.
   - `CoreSchemaRegistry`: A class implementing `SchemaRegistry` using `ajv`, a JSON schema validation library. It allows initialization with predefined `SchemaFormatter` instances.

2. **Workspaces:**
   - It abstracts interactions with Angular workspace file formats. Functions `readWorkspace` and `writeWorkspace` allow asynchronous reading and writing of workspaces, maintaining their format and comments.
   - `WorkspaceDefinition`: Describes a workspace that includes projects and extensions.
   - `ProjectDefinition` and `TargetDefinition`: Define the structure for projects and targets within a workspace, detailing properties like root directories and build configurations.
   - `WorkspaceHost`: An interface abstracting file system operations necessary to manage workspaces.

3. **Example Usage:**
   - The example demonstrates how to load a workspace, modify properties of a project's target, and write back changes using the described interfaces and functions.

This infrastructure is aimed at Angular application development, providing a streamlined approach to schema management and workspace manipulation.

```javascript
const { Observable, from } = require('rxjs');
const { ajv } = require('ajv'); // Mock ajv library for example purposes
const fs = require('fs');
const path = require('path');

// Schema Interfaces
class SchemaValidatorResult {
  constructor(success, errors) {
    this.success = success;
    this.errors = errors || [];
  }
}

class SchemaValidator {
  constructor(validatorFn) {
    return (data) => from(validatorFn(data));
  }
}

class SchemaFormatter {
  constructor(async, validateFn) {
    this.async = async;
    this.validate = validateFn;
  }
}

class SchemaRegistry {
  compile(schema) {
    return new Observable((subscriber) => {
      // Simulating schema compilation
      const validator = (data) => {
        const isValid = ajv.validate(schema, data);
        subscriber.next(new SchemaValidatorResult(isValid, ajv.errors));
        subscriber.complete();
      };
      subscriber.next(new SchemaValidator(validator));
      subscriber.complete();
    });
  }

  addFormat(name, formatter) {
    ajv.addFormat(name, formatter);
  }
}

class CoreSchemaRegistry extends SchemaRegistry {
  constructor(formats = {}) {
    super();
    Object.entries(formats).forEach(([name, formatter]) => this.addFormat(name, formatter));
  }
}

// Workspaces
class ProjectDefinition {
  constructor(root, extensions = {}, targets = new Map()) {
    this.root = root;
    this.extensions = extensions;
    this.targets = targets;
  }
}

class WorkspaceDefinition {
  constructor(extensions = {}, projects = new Map()) {
    this.extensions = extensions;
    this.projects = projects;
  }
}

const WorkspaceFormat = {
  JSON: 'json',
};

async function readWorkspace(directoryPath, host, format = WorkspaceFormat.JSON) {
  const content = await host.readFile(path.join(directoryPath, 'workspace.json'));
  return { workspace: JSON.parse(content) };
}

async function writeWorkspace(workspace, host, workspacePath, format = WorkspaceFormat.JSON) {
  const data = JSON.stringify(workspace, null, 2);
  await host.writeFile(workspacePath || 'workspace.json', data);
}

class WorkspaceHost {
  constructor(fileSystem) {
    this.fileSystem = fileSystem;
  }
  async readFile(filePath) {
    return fs.promises.readFile(filePath, 'utf8');
  }
  async writeFile(filePath, data) {
    return fs.promises.writeFile(filePath, data, 'utf8');
  }
  async isDirectory(directoryPath) {
    const stats = await fs.promises.stat(directoryPath);
    return stats.isDirectory();
  }
  async isFile(filePath) {
    const stats = await fs.promises.stat(filePath);
    return stats.isFile();
  }
}

function createWorkspaceHost(host) {
  return new WorkspaceHost(host);
}

// Usage Example
async function demonstrate() {
  const host = new WorkspaceHost(fs);
  const { workspace } = await readWorkspace('path/to/workspace/directory', host);

  const project = workspace.projects.get('my-app');
  if (!project) {
    throw new Error('my-app does not exist');
  }

  const buildTarget = project.targets.get('build');
  if (!buildTarget) {
    throw new Error('build target does not exist');
  }

  buildTarget.options = { ...buildTarget.options, optimization: true };

  await writeWorkspace(workspace, host, 'path/to/workspace.json');
}

demonstrate().catch(console.error);
```