The Node.js code provided implements a utility function similar to the Unix `mkdir -p` command. This `mkdirp` function can create a directory and all of its parent directories as needed. It includes both asynchronous (`mkdirp`) and synchronous (`mkdirpSync`) implementations, using the Node.js `fs` (file system) module. 

Here's a breakdown of the code:

- **Asynchronous Function (`mkdirp`)**: 
  - Accepts a directory path and optional options including mode and a custom file system object.
  - Tries to create the directory using a helper function `mkdirpNative`.
  - If a "no such file or directory" error (`ENOENT`) occurs, it recursively tries to create the parent directory first. If any other error occurs, it throws it.
  - Uses options to determine the mode of the directory, defaulting to `0o777` if not specified.

- **Helper Function (`mkdirpNative`)**:
  - Uses `fs.mkdir()` to create the directory recursively.
  - Resolves if the directory is created successfully or already exists (`EEXIST`).

- **Synchronous Function (`mkdirpSync`)**:
  - Similar to the async version but operates synchronously using `fs.mkdirSync`.
  - Handles exceptions similarly, attempting to create the parent directory on `ENOENT` errors.

- **Helper Function (`mkdirpNativeSync`)**:
  - Implements synchronous directory creation logic, resolving successfully, or on `EEXIST` while handling the parent creation on other errors.

The utility is organized into separate functions for readability and modularity, making use of Node.js' native capabilities to handle both file existence checking and recursive directory creation.

Here is the rewritten code:

```javascript
// mkdirp.js

import fs from 'fs';
import path from 'path';

const DEFAULT_MODE = 0o777;

// Asynchronous mkdirp
async function mkdirp(dir, opts = {}) {
  const mode = typeof opts === 'number' ? opts : (opts.mode || DEFAULT_MODE);
  const fsImpl = opts.fs || fs;

  try {
    const made = await makeDirAsync(dir, { mode, fs: fsImpl });
    return made;
  } catch (err) {
    if (err.code === 'ENOENT') {
      const parentDir = path.dirname(dir);
      const made = await mkdirp(parentDir, { mode, fs: fsImpl });
      await makeDirAsync(dir, { mode, fs: fsImpl });
      return made || dir;
    }
    throw err;
  }
}

async function makeDirAsync(dir, opts) {
  return new Promise((resolve, reject) => {
    opts.fs.mkdir(dir, { recursive: true, mode: opts.mode }, (err) => {
      if (err) {
        if (err.code === 'EEXIST') return resolve();
        return reject(err);
      }
      resolve(dir);
    });
  });
}

// Synchronous mkdirp
function mkdirpSync(dir, opts = {}) {
  const mode = typeof opts === 'number' ? opts : (opts.mode || DEFAULT_MODE);
  const fsImpl = opts.fs || fs;

  return makeDirSync(dir, { mode, fs: fsImpl });
}

function makeDirSync(dir, opts) {
  try {
    opts.fs.mkdirSync(dir, { recursive: true, mode: opts.mode });
    return dir;
  } catch (err) {
    if (err.code === 'EEXIST') return;
    const parentDir = path.dirname(dir);
    mkdirpSync(parentDir, { mode: opts.mode, fs: opts.fs });
    opts.fs.mkdirSync(dir, { mode: opts.mode });
    return dir;
  }
}

export { mkdirp, mkdirpSync };
```