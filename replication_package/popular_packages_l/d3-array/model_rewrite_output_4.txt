The provided Node.js code defines a package named `d3Array`, which offers basic statistical computations, search functionalities, and data transformation methods for iterables. Here's a breakdown of its functionality:

1. **Filter Helper**: A helper function, `filterValidNumbers`, filters out values that are `NaN` or `null` from an iterable, retaining only valid numeric values.

2. **Statistical Methods**: 
   - `min(iterable)`: Returns the smallest number in the iterable, or `undefined` if there are no valid numbers.
   - `max(iterable)`: Returns the largest number in the iterable, or `undefined` if there are no valid numbers.
   - `sum(iterable)`: Computes the sum of all valid numbers in the iterable.
   - `mean(iterable)`: Calculates the average of the valid numbers, or returns `undefined` if there are no valid numbers.
   - `quantile(iterable, p)`: Finds the p-th quantile of the iterable. Throws an error if `p` is not within [0, 1]. 

3. **Search and Extraction**: 
   - `extent(iterable)`: Returns an array containing the minimum and maximum values of the iterable.

4. **Transformation Methods**: 
   - `filter(iterable, test)`: Filters the iterable based on the provided test function.
   - `map(iterable, mapper)`: Maps each element of the iterable through the provided mapper function.

5. **Exports**: The entire suite of functionalities is encapsulated within `d3Array` and exported for use.

Here is a possible rewritten code block:

```javascript
// Node.js package for basic statistics, search, and transformations
const d3Array = (() => {
  // Helper to filter valid numbers
  const filterValidNumbers = (iterable) => Array.from(iterable).filter(d => !isNaN(d) && d != null);

  // Statistics Functions
  const statistics = {
    min(iterable) {
      const validNumbers = filterValidNumbers(iterable);
      return validNumbers.length ? Math.min(...validNumbers) : undefined;
    },
    max(iterable) {
      const validNumbers = filterValidNumbers(iterable);
      return validNumbers.length ? Math.max(...validNumbers) : undefined;
    },
    sum(iterable) {
      return filterValidNumbers(iterable).reduce((acc, num) => acc + num, 0);
    },
    mean(iterable) {
      const validNumbers = filterValidNumbers(iterable);
      return validNumbers.length ? statistics.sum(validNumbers) / validNumbers.length : undefined;
    },
    quantile(iterable, p) {
      if (p < 0 || p > 1) throw new RangeError("p must be within [0, 1]");
      const sorted = filterValidNumbers(iterable).sort((a, b) => a - b);
      if (!sorted.length) return undefined;
      const pos = (sorted.length - 1) * p;
      return (sorted[Math.floor(pos)] + (sorted[Math.ceil(pos)] || sorted[Math.floor(pos)])) / 2;
    },
    extent(iterable) {
      return [statistics.min(iterable), statistics.max(iterable)];
    }
  };

  // Transformation Methods
  const transformations = {
    filter(iterable, test) {
      return Array.from(iterable).filter(test);
    },
    map(iterable, mapper) {
      return Array.from(iterable).map(mapper);
    }
  };

  return {
    ...statistics,
    ...transformations
  };
})();

module.exports = d3Array;

// Example usage
// const arrayOps = require('d3-array');
// console.log(arrayOps.mean([1, 2, 3, 4])); // Outputs: 2.5
// console.log(arrayOps.extent([2, 3, -1, 5])); // Outputs: [-1, 5]
```