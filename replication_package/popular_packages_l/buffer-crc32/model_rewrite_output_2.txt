This Node.js code is implementing a CRC-32 (Cyclic Redundancy Check) checksum algorithm, which is commonly used for error-checking in data transmission. Here is a breakdown of how the code functions:

1. **Generating CRC Table**: The code first defines an empty array `crcTable` and fills it with 256 entries via the `makeCrcTable` function. Each entry represents a CRC value for all possible byte values (0-255). This table is used to speed up CRC calculations.

2. **Calculating CRC-32**: The `crc32` function computes the CRC-32 checksum for a given buffer or string. It accepts two arguments: the input `buf` and an optional `previous` CRC value. If the input is a string, it first converts it to a Buffer using UTF-8 encoding. The function then uses the precomputed `crcTable` to efficiently calculate the checksum and returns it as a Buffer.

3. **Signed and Unsigned CRC Values**: The `crc32` function is extended with two methods, `signed` and `unsigned`, which respectively return the CRC-32 checksum as a signed or unsigned 32-bit integer.

4. **Exporting the Module**: The `crc32` function, extended with `signed` and `unsigned` methods, is exported as a module.

Below is the rewritten code:

```javascript
// crc32.js
const crc32Table = new Uint32Array(256);

// Fill the CRC table for all 256 possible byte values
for (let i = 0; i < 256; i++) {
  let crc = i;
  for (let j = 0; j < 8; j++) {
    crc = (crc & 1) ? (0xEDB88320 ^ (crc >>> 1)) : (crc >>> 1);
  }
  crc32Table[i] = crc;
}

// Function to compute CRC-32 checksum
function computeCrc32(input, previous = 0) {
  let buffer = Buffer.isBuffer(input) ? input : Buffer.from(input, 'utf8');
  let crc = ~previous >>> 0;

  for (const byte of buffer) {
    crc = crc32Table[(crc ^ byte) & 0xFF] ^ (crc >>> 8);
  }

  crc = ~crc >>> 0;
  const result = Buffer.alloc(4);
  result.writeUInt32BE(crc, 0);
  return result;
}

// Extend the computeCrc32 function with additional methods
computeCrc32.signed = function(input) {
  return computeCrc32(input).readInt32BE(0);
};

computeCrc32.unsigned = function(input) {
  return computeCrc32(input).readUInt32BE(0);
};

module.exports = computeCrc32;
```