The provided Node.js code is a simplified version of a library for styling console output using ANSI escape codes. The library uses ANSI codes to apply text formatting like color, boldness, underlining, and other text styles when printing to terminal screens that support these features.

Here's how the code functions:
1. **Color Support Detection**: It first checks if the terminal supports color by examining `process.stdout.isTTY` and `process.env.FORCE_COLOR`. If the output stream is a TTY (terminal) and forcing of color isn't disabled via environment variables, `supportsColor` is set to `true`.

2. **ANSI Codes**: A `codes` object is defined, storing ANSI escape codes for various text styles. This includes `modifiers` (like bold or underline), `colors` (like red or green), and `backgrounds` (background colors).

3. **`applyStyle` Function**: A helper function that wraps a string with the start and end ANSI sequences, if `supportsColor` is `true`. Otherwise, it returns the string unmodified.

4. **Kleur Object**: The library exposes a `kleur` object. It adds methods for each style defined in the `codes` object. These methods take a string argument and apply the corresponding ANSI codes, returning the styled string if colors are enabled.

5. **Method Creation**: For each type of style (modifiers, colors, and backgrounds), methods are dynamically added to the `kleur` object. It supports both direct application and deferred chaining through `createChainer`.

6. **Module Exports**: It exports the `kleur` object. Additionally, it provides `colors`, `backgrounds`, and `modifiers` properties on `kleur` for direct access to style functions without invoking them on individual strings.

Here's a possible rewrite of the code:

```javascript
const supportsColor = (() => {
  const forceColor = process.env.FORCE_COLOR;
  return process.stdout.isTTY && forceColor !== '0';
})();

const ansiCodes = {
  modifiers: {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  colors: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    gray: [90, 39]
  },
  backgrounds: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49]
  }
};

function createStyleFunction(start, end) {
  return function(str) {
    return supportsColor ? `\x1b[${start}m${str}\x1b[${end}m` : str;
  };
}

const kleur = { enabled: supportsColor };

function addStylesToKleur(styles) {
  Object.entries(styles).forEach(([styleName, styleSequence]) => {
    const [start, end] = styleSequence;
    kleur[styleName] = function(str) {
      return arguments.length ? createStyleFunction(start, end)(str) : createChainer(styleName, start, end);
    };
  });
}

function createChainer(style, start, end) {
  const chainFunction = (str) => supportsColor ? `\x1b[${start}m${str}\x1b[${end}m` : str;
  chainFunction.style = style;
  chainFunction.asInstanceOf = 'kleur';
  chainFunction.apply = createChainer;
  return chainFunction;
}

addStylesToKleur(ansiCodes.modifiers);
addStylesToKleur(ansiCodes.colors);
addStylesToKleur(ansiCodes.backgrounds);

module.exports = kleur;

// Optionally expose categorized styles
kleur.modifiers = Object.fromEntries(Object.entries(ansiCodes.modifiers).map(([mod, codes]) => [mod, createStyleFunction(...codes)]));
kleur.colors = Object.fromEntries(Object.entries(ansiCodes.colors).map(([color, codes]) => [color, createStyleFunction(...codes)]));
kleur.backgrounds = Object.fromEntries(Object.entries(ansiCodes.backgrounds).map(([bg, codes]) => [bg, createStyleFunction(...codes)]));
```