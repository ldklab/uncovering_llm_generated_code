The functionality described in the README.md outlines `core-js`, a Node.js package that serves as a modular standard library for JavaScript. It provides polyfills for ECMAScript features up to 2023, including promises, symbols, collections, iterators, typed arrays, and other ECMAScript proposals. Additionally, it includes some cross-platform WHATWG/W3C features such as URL and URLSearchParams.

Key aspects of the `core-js` package include:

1. **Modularity**: Users can import only the features they need, reducing the bundle size and potentially improving application performance.

2. **No Global Namespace Pollution**: The package can be used without polluting the global namespace, meaning you can use its features without altering or affecting the standard JavaScript objects unless explicitly desired.

3. **Promise and Set Enhancements**: Enhancements to native JavaScript objects, like adding union methods to sets or providing additional methods like flatMap on arrays.

4. **Iterator Utilities**: Providing advanced handling of iterables with methods like drop, take, filter, and map that can be chained and finally converted to arrays with toArray().

5. **Structured Cloning**: Enabling structuredClone to work with sets, allowing objects or data structures to be clonable in a more straightforward manner.

Here's the implementation of the described functionality in code:

```markdown
// index.js

// Example implementation of core-js-lite with dummy polyfills for illustration

class CustomPromise {
  static resolve(value) {
    return new Promise((resolve) => resolve(value));
  }
}

class CustomSet extends Set {
  union(otherSet) {
    return new CustomSet([...this, ...otherSet]);
  }
}

class CustomArray {
  static from(iterable) {
    return Array.from(iterable);
  }

  static flatMap(array, callback) {
    return array.reduce((acc, value) => acc.concat(callback(value)), []);
  }
}

function structuredClone(value) {
  return JSON.parse(JSON.stringify(value));
}

class CustomIterator {
  constructor(iterable) {
    this.iterable = iterable;
  }

  static from(generator) {
    return new CustomIterator(generator);
  }

  drop(n) {
    let result = [];
    for (let item of this.iterable) {
      if (n-- > 0) continue;
      result.push(item);
    }
    return new CustomIterator(result);
  }

  take(n) {
    let result = [];
    for (let item of this.iterable) {
      if (n-- <= 0) break;
      result.push(item);
    }
    return new CustomIterator(result);
  }

  filter(callback) {
    let result = [];
    for (let item of this.iterable) {
      if (callback(item)) result.push(item);
    }
    return new CustomIterator(result);
  }

  map(callback) {
    let result = [];
    for (let item of this.iterable) {
      result.push(callback(item));
    }
    return new CustomIterator(result);
  }

  toArray() {
    return [...this.iterable];
  }
}

export {
  CustomPromise as Promise,
  CustomSet as Set,
  CustomArray as Array,
  structuredClone,
  CustomIterator as Iterator,
};

// Example usage:

import { Promise, Set, Array, structuredClone, Iterator } from './index.js';

Promise.resolve(42).then(it => console.log(it)); // => 42

Array.from(new Set([1, 2, 3]).union(new Set([3, 4, 5]))); // => [1, 2, 3, 4, 5]

Array.flatMap([1, 2], it => [it, it]); // => [1, 1, 2, 2]

Iterator.from(function* (i) { while (true) yield i++; }(1))
  .drop(1).take(5)
  .filter(it => it % 2)
  .map(it => it ** 2)
  .toArray(); // => [9, 25]

console.log(structuredClone(new Set([1, 2, 3]))); // => Set { 1, 2, 3 }
```

This code provides a simplified version of core-js features discussed in the README.md, with custom implementations for promises, sets, arrays, iterators, and structured cloning, showcasing how the functionalities can be modularly applied in Node.js.