The `Yup` library provides a robust set of functionalities for building schemas to validate, transform, and handle dynamic data types at runtime, particularly ideal for JavaScript and TypeScript projects. Here’s an overview of the key features and how `Yup` operates:

1. **Schema Construction**: With `Yup`, schemas can be defined using a chainable API to specify validation and transformation requirements for data structures. This includes checking types and coinciding constraints — for instance, ensuring numbers are positive or strings are emails.

2. **Transformation and Validation**: `Yup` schemas consist of both transforms and validations for a comprehensive data processing flow. Transforms change input data into a specified format (e.g., trimming whitespace from strings), while validations ensure the data adheres to certain rules (e.g., a number must be positive).

3. **Dynamic Typing with TypeScript**: Schema definitions in `Yup` can infer TypeScript interfaces, enabling better type safety and checks during development. Developers can ensure that schema-defined data types align with TypeScript interfaces, promoting consistency across a project.

4. **Customizable Error Handling**: Validation errors can be richly detailed, and custom error messages can be configured both in general scenarios and specific use cases for granular control over feedback.

5. **Asynchronous Validation Support**: `Yup` accounts for asynchronous data sources, such as remote validators, and integrates seamlessly with promises to handle validations that can't be determined instantly.

Below is the code for a Node.js package implementing the functionality described:

```js
// Import core modules for schema types and utilities
const {
  mixed,
  string,
  number,
  boolean,
  bool,
  date,
  object,
  array,
  ref,
  lazy,
  ValidationError,
  addMethod,
  Schema,
  setLocale,
  reach,
} = require('yup');

// Custom error messages
setLocale({
  mixed: {
    default: 'This field is invalid',
  },
  number: {
    min: 'This value should be greater than ${min}',
  },
});

// Example User Schema
let userSchema = object({
  name: string().required(),
  age: number().required().positive().integer(),
  email: string().email(),
  website: string().url().nullable(),
  createdOn: date().default(() => new Date()),
});

// Asynchronous validation example
async function validateUser(data) {
  try {
    const user = await userSchema.validate(data);
    console.log(user);
  } catch (err) {
    if (err instanceof ValidationError) {
      console.error(err.errors);
    }
  }
}

// Casting data example
function castUserData(data) {
  const parsedUser = userSchema.cast(data);
  console.log(parsedUser);
}

// Extending Yup: Adding a Custom Method
addMethod(string, 'safeEmail', function safeEmail() {
  return this.lowercase().matches(/^\S+@\S+\.\S+$/, 'Must be a valid email address');
});

// Usage of custom method
let customSchema = object({
  contactEmail: string().safeEmail(),
});

// Custom Usage
async function validateCustomUser(data) {
  try {
    const result = await customSchema.validate(data);
    console.log(result);
  } catch (err) {
    console.error(err.errors);
  }
}

// Test the package
(async () => {
  const sampleData = {
    name: 'John Doe',
    age: 29,
    email: 'john.doe@example.com',
    website: 'https://johndoe.com',
  };

  const invalidData = {
    name: 'John Doe',
    age: 29,
    email: 'not-an-email',
  };

  await validateUser(sampleData);
  castUserData({ name: 'Jane', age: '23', website: '' });

  // Test custom method validation
  await validateCustomUser({ contactEmail: 'valid@example.com' });
  await validateCustomUser({ contactEmail: 'INVALIDEMAIL' });
})();
```

This code demonstrates the usage and features of the Yup library, showcasing schema creation with transformations and validations, TypeScript integration, and extending Yup with custom operations.