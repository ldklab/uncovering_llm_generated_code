The Source Map package provides functionalities for generating and consuming source maps, which are a way to map code within a compressed file back to its position in the original file. This library mainly offers the following capabilities:

1. **Consuming Source Maps:**
   - Provides an interface to read and query source map data to map positions in the generated code back to the original source.
   - Main class: `SourceMapConsumer`.
   - Methods include loading a source map, retrieving original positions from generated ones, and listing all mappings.

2. **Generating Source Maps:**
   - Allows the creation of source maps as code transformations are made.
   - Main class: `SourceMapGenerator`.
   - Methods help add mappings from original source positions to generated positions, include original source content, and apply transformations.

3. **Manipulating Source Node:**
   - Abstraction to manage code snippets with line and column data interpolation.
   - Main class: `SourceNode`.
   - Helpful in managing transformations and combining code chunks, generating mappings simultaneously.

### Code Implementation

```javascript
// Source Map Library Implementation
class SourceMapGenerator {
  constructor({ file, sourceRoot, skipValidation } = {}) {
    this.file = file || null;
    this.sourceRoot = sourceRoot || null;
    this.skipValidation = !!skipValidation;
    this.mappings = [];
    this.sourcesContent = {};
  }

  addMapping({ generated, original, source, name }) {
    if (!this.skipValidation) {
      // Validate the mapping
    }
    this.mappings.push({ generated, original, source, name });
  }

  setSourceContent(sourceFile, sourceContent) {
    this.sourcesContent[sourceFile] = sourceContent;
  }

  toString() {
    return JSON.stringify({
      version: 3,
      file: this.file,
      sources: Object.keys(this.sourcesContent),
      sourcesContent: Object.values(this.sourcesContent),
      mappings: this._serializeMappings()
    });
  }

  _serializeMappings() {
    // Serialize mappings to a VLQ string
    return this.mappings.map(m => `${m.generated.line},${m.generated.column}`).join(';');
  }
}

class SourceMapConsumer {
  constructor(rawSourceMap) {
    this.rawSourceMap = rawSourceMap;
    this.mappings = this._parseMappings(rawSourceMap.mappings);
  }

  static async with(rawSourceMap, sourceMapUrl, callback) {
    const consumer = await new SourceMapConsumer(rawSourceMap);
    try {
      return await callback(consumer);
    } finally {
      consumer.destroy();
    }
  }

  originalPositionFor({ line, column }) {
    const mapping = this.mappings.find(m => m.generated.line === line && m.generated.column === column);
    if (!mapping) return { source: null, line: null, column: null, name: null };
    return { source: mapping.source, line: mapping.original.line, column: mapping.original.column, name: mapping.name };
  }

  generatedPositionFor({ source, line, column }) {
    const mapping = this.mappings.find(m => m.source === source && m.original.line === line && m.original.column === column);
    if (!mapping) return { line: null, column: null };
    return { line: mapping.generated.line, column: mapping.generated.column };
  }

  eachMapping(callback, context, order) {
    const mappings = order === SourceMapConsumer.ORIGINAL_ORDER ? [...this.mappings].sort((a, b) => a.original.line - b.original.line) : this.mappings;
    mappings.forEach(callback, context);
  }

  destroy() {
    this.mappings = null;
  }

  _parseMappings(mappings) {
    // Parse the mapping string into an array of mapping objects
    return mappings.split(';').map(m => {
      const [generatedLine, generatedColumn, source, originalLine, originalColumn, name] = m.split(',');
      return {
        generated: { line: +generatedLine, column: +generatedColumn },
        original: { line: +originalLine, column: +originalColumn },
        source,
        name,
      };
    });
  }
}

class SourceNode {
  constructor(line, col, source, chunk, name) {
    this.children = [];
    if (chunk) this.add(chunk);
    this.line = line || null;
    this.column = col || null;
    this.source = source || null;
    this.name = name || null;
  }

  add(chunk) {
    if (Array.isArray(chunk)) {
      chunk.forEach(subChunk => this.add(subChunk));
    } else {
      this.children.push(chunk);
    }
  }

  toString() {
    return this.children.map(child => (child instanceof SourceNode ? child.toString() : child)).join('');
  }

  toStringWithSourceMap(startOfSourceMap) {
    const map = new SourceMapGenerator(startOfSourceMap);
    // Use walk to add mappings to the SourceMapGenerator
    this.walk((chunk, loc) => {
      map.addMapping({ source: loc.source, original: loc, generated: loc, name: loc.name });
    });
    return {
      code: this.toString(),
      map
    };
  }

  walk(fn) {
    this.children.forEach(child => {
      if (child instanceof SourceNode) {
        child.walk(fn);
      } else {
        fn(child, { source: this.source, line: this.line, column: this.column, name: this.name });
      }
    });
  }
}

module.exports = {
  SourceMapGenerator,
  SourceMapConsumer,
  SourceNode
};
```
