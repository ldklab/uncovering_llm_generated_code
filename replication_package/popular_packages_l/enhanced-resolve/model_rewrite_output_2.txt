The provided Node.js code defines a class `EnhancedResolve` which is a customizable module resolution system. Here's a breakdown of its functionality:

1. **Initialization**: The constructor accepts an `options` object to define custom behaviors such as different file extensions (`extensions`), alias resolutions (`alias`), a custom file system (`fileSystem`), and an array of `plugins` that can hook into the resolution process.

2. **Resolve Method**: The `resolve` method attempts to resolve a module's path based on the provided context, path, and request string. It features a plugin mechanism where plugins subscribed to hooks ('before-resolve' and 'after-resolve') can modify the resolving process. The resolved path or an error is provided via a callback function.

3. **Sync Resolution**: The `_resolveSync` method tries appending different extensions to the request and checks the file system for existence. If a valid path is found, it returns it; otherwise, it throws an error.

4. **Plugin Application**: The `_applyPlugins` method sequentially executes functions from plugins that target specific hooks, enabling custom logic injections.

5. **Static Creation**: The `EnhancedResolve` class provides a static method `create` for convenience, which simply returns a new instance of itself.

6. **Sample Plugin**: There is an example `SamplePlugin` class that can be used to create plugins to be used with `EnhancedResolve`. It defines which hooks the plugin applies to and a placeholder for custom logic.

Here's a possible rewrite of this Node.js code:

```javascript
const fs = require('fs');

class EnhancedResolve {
  constructor(config = {}) {
    this.config = {
      extensions: config.extensions || ['.js', '.json', '.node'],
      alias: config.alias || {},
      fileSystem: config.fileSystem || fs,
      plugins: config.plugins || [],
      ...config,
    };
  }

  resolve(context, basePath, moduleName, callback) {
    this._triggerPlugins('before-resolve', { context, basePath, moduleName }, error => {
      if (error) return callback(error);

      let finalPath;
      try {
        finalPath = this._resolvePath(basePath, moduleName);
      } catch (error) {
        return callback(error);
      }

      this._triggerPlugins('after-resolve', { context, basePath: finalPath, moduleName }, error => {
        if (error) return callback(error);
        callback(null, finalPath);
      });
    });
  }

  _resolvePath(basePath, moduleName) {
    for (const extension of this.config.extensions) {
      const pathToCheck = `${basePath}/${moduleName}${extension}`;
      if (this.config.fileSystem.existsSync(pathToCheck)) {
        return pathToCheck;
      }
    }
    throw new Error(`Cannot resolve module '${moduleName}' in '${basePath}'`);
  }

  static create(config) {
    return new EnhancedResolve(config);
  }

  _triggerPlugins(hookName, data, callback) {
    const applicablePlugins = this.config.plugins.filter(plugin => plugin.shouldApply(hookName));
    let currentIndex = 0;

    const moveNext = (error) => {
      if (error || currentIndex === applicablePlugins.length) return callback(error);
      applicablePlugins[currentIndex++].execute(data, moveNext);
    };

    moveNext();
  }
}

class SamplePlugin {
  constructor(hookTargets, destination) {
    this.hookTargets = hookTargets;
    this.destination = destination;
  }

  shouldApply(hookName) {
    return this.hookTargets.includes(hookName);
  }

  execute(data, callback) {
    callback();
  }
}

module.exports = {
  EnhancedResolve,
  SamplePlugin,
};
```