This Node.js code defines a custom resolver for module imports, tailored for TypeScript projects, intended to be used with ESLint. It uses the `enhanced-resolve` library to establish module paths based on a set of defaults and configuration options provided by the user.

Here's the functionality breakdown:
1. **Default Settings:** Several arrays define the default resolution policy, including supported file extensions (`defaultExtensions`), aliases for extensions (`defaultExtensionAlias`), and fields checked for resolving entry points of modules (`defaultMainFields`).

2. **Resolver Creation:** A function `resolve` sets up and uses `enhanced-resolve` to determine the file path for a given module from a source path. It returns a promise that resolves the path or catches an error if the module is not found.

3. **Versioning and Resolution Method:** A function `interfaceVersion` simply returns `2` as the interface version. Another function `resolveModuleDependency` uses the `resolve` function and returns an object indicating whether the module was found and its path.

4. **Exported Module:** The module exports a set of utilities and default configurations for external use, compatible with ESLint plugins.

Here's a rewritten version of the code:

```javascript
// eslint-import-resolver-typescript-rewrite.js
const path = require('path');
const enhancedResolve = require('enhanced-resolve');

const DEFAULT_CONDITIONS = [
  "types", "import", "esm2020", "es2020", "es2015", "require", 
  "node", "node-addons", "browser", "default"
];

const DEFAULT_EXTENSIONS = [
  ".ts", ".tsx", ".d.ts", ".js", ".jsx", ".json", ".node"
];

const DEFAULT_EXTENSION_ALIASES = {
  ".js": [".ts", ".tsx", ".d.ts", ".js"],
  ".jsx": [".tsx", ".d.ts", ".jsx"],
  ".cjs": [".cts", ".d.cts", ".cjs"],
  ".mjs": [".mts", ".d.mts", ".mjs"]
};

const DEFAULT_MAIN_FIELDS = [
  "types", "typings", "fesm2020", "fesm2015", 
  "esm2020", "es2020", "module", "jsnext:main", "main"
];

async function resolveModuleSource(source, file, config = {}) {
  const resolver = enhancedResolve.create({
    extensions: config.extensions || DEFAULT_EXTENSIONS,
    conditionNames: config.conditionNames || DEFAULT_CONDITIONS,
    mainFields: config.mainFields || DEFAULT_MAIN_FIELDS,
    alias: config.extensionAlias || DEFAULT_EXTENSION_ALIASES,
    ...config
  });

  return new Promise((resolve, reject) => {
    resolver(path.dirname(file), source, (err, result) => {
      if (err) return reject(err);
      resolve(result);
    });
  });
}

function getInterfaceVersion() {
  return 2;
}

async function resolveDependency(source, file, config) {
  try {
    const resolvedPath = await resolveModuleSource(source, file, config);
    return { found: true, path: resolvedPath };
  } catch {
    return { found: false };
  }
}

module.exports = {
  interfaceVersion: getInterfaceVersion,
  resolve: resolveDependency,
  defaultConditionNames: DEFAULT_CONDITIONS,
  defaultExtensions: DEFAULT_EXTENSIONS,
  defaultExtensionAlias: DEFAULT_EXTENSION_ALIASES,
  defaultMainFields: DEFAULT_MAIN_FIELDS
};
```