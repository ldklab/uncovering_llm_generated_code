The provided Node.js code defines a `Graphemer` class, which is designed to break down a string into its individual grapheme clusters according to simplified Unicode grapheme rules. This task involves handling various character combinations, such as surrogate pairs and combining marks, using a basic implementation. The class offers methods to split a string into graphemes, iterate over graphemes, and count them. The `breakRules` object contains simplified logic for surrogate pairs and combining marks, which would otherwise be based on complex Unicode rules. The class is designed to be exportable as a module.

Here is a possible rewrite of the code:

```javascript
// graphemer.js

class Graphemer {
    constructor() {
        this.breakRules = this.loadBreakRules();
    }
    
    loadBreakRules() {
        return {
            SurrogatePair: (current, next) => {
                return (0xD800 <= current && current <= 0xDBFF) &&
                       (0xDC00 <= next && next <= 0xDFFF);
            },
            CombiningMark: (current, next) => {
                return (this.isBaseChar(current) && this.isCombiningMark(next));
            },
        };
    }
    
    isBaseChar(codePoint) {
        return codePoint >= 0x0041 && codePoint <= 0x007A;
    }
    
    isCombiningMark(codePoint) {
        return codePoint >= 0x0300 && codePoint <= 0x036F;
    }

    splitGraphemes(string) {
        let graphemes = [];
        let currentGrapheme = '';
        for (let i = 0; i < string.length; i++) {
            const currentChar = string.charCodeAt(i);
            const nextChar = string.charCodeAt(i + 1);

            currentGrapheme += string[i];
            
            if (!this.shouldBreak(currentChar, nextChar)) {
                continue;
            }

            graphemes.push(currentGrapheme);
            currentGrapheme = '';
        }
        
        if (currentGrapheme) {
            graphemes.push(currentGrapheme);
        }
        
        return graphemes;
    }

    iterateGraphemes(string) {
        const graphemes = this.splitGraphemes(string);
        return graphemes.values();
    }

    countGraphemes(string) {
        return this.splitGraphemes(string).length;
    }
    
    shouldBreak(current, next) {
        if (next === undefined) return true;
        if (this.breakRules.SurrogatePair(current, next)) return false;
        if (this.breakRules.CombiningMark(current, next)) return false;
        return true;
    }
}

if (typeof module !== 'undefined' && module.exports) {
    module.exports.default = Graphemer;
}
```