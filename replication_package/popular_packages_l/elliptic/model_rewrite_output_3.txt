The Node.js code provides a class `Elliptic` that facilitates operations using elliptic curve cryptography. It leverages the `elliptic` library for cryptographic operations and `bn.js` for handling big numbers. The main functionalities offered by the class are:

1. **Initialization**: The class is initialized with a curve name and sets up the elliptic curve accordingly.
2. **Key Generation**: Generates a key pair for the defined curve.
3. **Signing**: Signs a message hash using a private key from a key pair.
4. **Verification**: Verifies a given signature against a message hash and public key.
5. **ECDH**: Derives a shared secret using Elliptic Curve Diffie-Hellman (ECDH) from two key pairs.
6. **Public Key Encoding**: Converts the public key of a key pair into various formats, including hex strings and buffers.
7. **Public Key Importing**: Imports a public key from various formats back into a `Key` object suitable for operations.

Here's the rewritten version of the code:

```javascript
// elliptic.js

const elliptic = require('elliptic');
const { BN } = require('bn.js');

class Elliptic {
  constructor(curve) {
    this.curveName = curve;
    this.curve = new elliptic.ec(curve);
  }

  generateKeyPair() {
    return this.curve.genKeyPair();
  }

  signMessage(key, messageHash) {
    return key.sign(messageHash);
  }

  verifySignature(publicKey, messageHash, signature) {
    return publicKey.verify(messageHash, signature);
  }

  deriveSharedSecret(privateKey, publicKey) {
    return privateKey.derive(publicKey);
  }

  getPublicKeyFormats(key) {
    const pubPoint = key.getPublic();
    const x = pubPoint.getX();
    const y = pubPoint.getY();

    const hexFormat = pubPoint.encode('hex');
    const objectHexFormat = { x: x.toString('hex'), y: y.toString('hex') };
    const objectBufferFormat = { x: x.toBuffer(), y: y.toBuffer() };
    const arrayBufferFormat = { x: x.toArrayLike(Buffer), y: y.toArrayLike(Buffer) };

    return [hexFormat, objectHexFormat, objectBufferFormat, arrayBufferFormat];
  }

  importPublicKey(publicKey) {
    return this.curve.keyFromPublic(publicKey, 'hex');
  }
}

const secp256k1 = new Elliptic('secp256k1');
const messageHash = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

const keyPair = secp256k1.generateKeyPair();
const signature = secp256k1.signMessage(keyPair, messageHash);
console.log(secp256k1.verifySignature(keyPair, messageHash, signature.toDER()));

module.exports = Elliptic;
```