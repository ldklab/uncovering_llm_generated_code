The provided Node.js code implements a simple query system for JavaScript Abstract Syntax Trees (ASTs) utilizing the Esprima library to parse JavaScript code. The main class, `ESQuery`, allows querying of ASTs using a CSS-selector-like syntax (although in a very basic form). The functionality can be broken down as follows:

1. **AST Parsing:** The `esprima.parseScript` method is used to parse a string of JavaScript code into an AST.

2. **Querying Mechanism:** The `ESQuery` class allows traversing the AST to find nodes based on a selector, which is parsed into a structured query object.

3. **Selector Parsing:** `parseSelector` splits a selector string into components and converts them into query objects based on the type of selector (node type, attribute, pseudo-class, or combinators like child selectors).

4. **AST Traversal and Matching:** The `findMatches` method recursively traverses the AST to find nodes that match the query using `isMatch`, which determines if a node matches based on its type, attributes, or the specified pseudo-conditions.

5. **Example Usage:** An example demonstrates parsing a piece of JavaScript code and querying the AST for `ForStatement` nodes, printing the results.

Here's a possible rewrite of the provided code:

```javascript
const esprima = require('esprima');

class ESQuery {
    constructor(ast) {
        this.ast = ast;
    }

    query(selector) {
        const queryObj = this.parseSelector(selector);
        return this.findMatches(this.ast, queryObj);
    }
    
    parseSelector(selector) {
        const components = selector.split(' ');
        return components.map(component => this.parseComponent(component));
    }

    parseComponent(component) {
        if (component.includes('[')) {
            const [attr, value] = component.match(/\[(.*?)\]/)[1].split('=');
            return { type: 'attribute', attribute: attr, value: value };
        }
        if (component.startsWith(':')) {
            return { type: 'pseudo', pseudo: component.slice(1) };
        }
        if (component === '>') {
            return { type: 'combinator', combinator: 'child' };
        }
        return { type: 'node', nodeType: component };
    }

    findMatches(node, queryObj, results = [], parent = null) {
        for (let query of queryObj) {
            if (this.isMatch(node, query, parent)) {
                results.push(node);
            }
            if (node.body && Array.isArray(node.body)) {
                node.body.forEach(child => this.findMatches(child, queryObj, results, node));
            }
        }
        return results;
    }

    isMatch(node, query, parent) {
        switch (query.type) {
            case 'node':
                return node.type === query.nodeType;
            case 'attribute':
                return node[query.attribute] === query.value;
            case 'pseudo':
                return this.matchPseudo(node, query.pseudo);
            case 'combinator':
                return parent && parent.type === query.parentNodeType;
            default:
                return false;
        }
    }
    
    matchPseudo(node, pseudo) {
        if (pseudo === 'first-child') {
            return node.parent && node.parent.body[0] === node;
        }
        if (pseudo === 'last-child') {
            return node.parent && node.parent.body[node.parent.body.length - 1] === node;
        }
        return false;
    }
}

const code = `
    function example(a, b) {
        return a + b;
    }

    for (let i = 0; i < 10; i++) {
        console.log(i);
    }
`;

const ast = esprima.parseScript(code);
const esquery = new ESQuery(ast);

const results = esquery.query('ForStatement');
console.log('Query Results:', results);
```