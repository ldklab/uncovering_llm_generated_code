The Node.js package `semver` is designed to help manage and manipulate semantic versioning, which is a specification for assigning version numbers. The package provides utilities to validate, compare, increment, and coerce version numbers. Here's a breakdown of its key components and functionalities:

1. **Validation and Cleaning**:
   - `valid(v)`: Checks if the given version string `v` is valid according to semantic versioning rules and returns it if valid, otherwise returns `null`.
   - `clean(v)`: Strips extra characters and spaces to convert the input string into a valid semver format, or returns `null` if it fails.

2. **Comparison**:
   - Functions such as `gt(v1, v2)`, `lt(v1, v2)`, `eq(v1, v2)`, etc., provide greater than, less than, equal, and other comparison functionalities for two version strings.

3. **Incrementing**:
   - `inc(v, release, options, identifier, identifierBase)`: Increments a version based on a release type (major, minor, patch, etc.), optionally specifying an identifier for pre-release versions.

4. **Range Checking**:
   - `satisfies(version, range)`: Checks if a version matches a given range.
   - `maxSatisfying(versions, range)`, `minSatisfying(versions, range)`: Find the maximum or minimum version within a list that satisfies a specified range.

5. **Coercion**:
   - `coerce(version, options)`: Attempts to convert a non-semver string into a valid semver string if possible.

6. **Range Parsing and Manipulation**:
   - The package can work with version ranges using comparators and supports complex range expressions like tilde `~`, caret `^`, hyphenated ranges, etc.

7. **Utility Constants**:
   - Provides constants like `RELEASE_TYPES` and `SEMVER_SPEC_VERSION` for understanding and interacting with the developed features using semantic versioning.

Below is a basic implementation of the `semver` Node.js package functionality in JavaScript:

```javascript
// semver.js

class SemVer {
  constructor(version) {
    const parsed = SemVer.parse(version);
    if (!parsed) {
      throw new Error(`Invalid version: ${version}`);
    }
    this.major = parsed.major;
    this.minor = parsed.minor;
    this.patch = parsed.patch;
    this.prerelease = parsed.prerelease || [];
    this.build = parsed.build || [];
  }

  static parse(version) {
    const regex = /^v?(?<major>\d+)\.(?<minor>\d+)\.(?<patch>\d+)(?:-(?<prerelease>[\da-z\-\.]+))?(?:\+(?<build>[\da-z\-\.]+))?$/i;
    const match = version.trim().match(regex);
    if (!match) return null;
    const { groups } = match;
    return {
      major: parseInt(groups.major, 10),
      minor: parseInt(groups.minor, 10),
      patch: parseInt(groups.patch, 10),
      prerelease: groups.prerelease ? groups.prerelease.split('.') : [],
      build: groups.build ? groups.build.split('.') : []
    };
  }

  format() {
    let version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) version += `-${this.prerelease.join('.')}`;
    if (this.build.length) version += `+${this.build.join('.')}`;
    return version;
  }

  compare(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other);
    }
    if (this.major !== other.major) return compareInts(this.major, other.major);
    if (this.minor !== other.minor) return compareInts(this.minor, other.minor);
    if (this.patch !== other.patch) return compareInts(this.patch, other.patch);

    const preCompare = compareArrays(this.prerelease, other.prerelease);
    if (preCompare !== 0) return preCompare;

    return compareArrays(this.build, other.build);
  }

  increment(release, identifier) {
    switch (release) {
      case 'pre':
        this.prerelease = [identifier || '0'];
        break;
      case 'patch':
        this.patch++;
        this.prerelease = [];
        break;
      case 'minor':
        this.minor++;
        this.patch = 0;
        this.prerelease = [];
        break;
      case 'major':
        this.major++;
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      default:
        throw new Error(`Invalid release type: ${release}`);
    }
    return this;
  }
}

function compareInts(a, b) {
  return (a > b) - (a < b);
}

function compareArrays(a, b) {
  const length = Math.min(a.length, b.length);
  for (let i = 0; i < length; i++) {
    if (a[i] !== b[i]) {
      return compareInts(a[i], b[i]);
    }
  }
  return compareInts(a.length, b.length);
}

function valid(version) {
  try {
    const semver = new SemVer(version);
    return semver.format();
  } catch {
    return null;
  }
}

function clean(version) {
  const trimmed = version.trim();
  const semver = valid(trimmed);
  if (!semver) return null;
  return semver.replace(/^v/, '').trim();
}

function satisfies(version, range) {
  const [rangeOperator, rangeVersion] = parseRange(range);
  const semver = new SemVer(version);
  const rangeSemver = new SemVer(rangeVersion);
  return satisfiesComparator(semver, rangeOperator, rangeSemver);
}

function parseRange(range) {
  const [operator, version] = range.match(/^([<>=]*)?([\d\.]+)/).slice(1, 3);
  return [operator || '=', version];
}

function satisfiesComparator(semver, operator, rangeSemver) {
  const comparison = semver.compare(rangeSemver);
  switch (operator) {
    case '=':
      return comparison === 0;
    case '>':
      return comparison > 0;
    case '>=':
      return comparison >= 0;
    case '<':
      return comparison < 0;
    case '<=':
      return comparison <= 0;
    default:
      return false;
  }
}

module.exports = {
  valid,
  clean,
  SemVer,
  compare: (v1, v2) => new SemVer(v1).compare(v2),
  satisfies
};

// Usage Example:

const semver = require('./semver');

console.log(semver.valid('1.2.3')); // '1.2.3'
console.log(semver.clean('  =v1.2.3   ')); // '1.2.3'
console.log(semver.satisfies('1.2.3', '>=1.0.0')); // true
```

This package utilizes object-oriented JavaScript and regex for parsing versions and includes key utility functions such as validation, comparison, cleaning, incrementing, and checking if versions satisfy specific range criteria.