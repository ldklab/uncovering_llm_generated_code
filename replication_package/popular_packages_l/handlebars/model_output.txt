The functionality described in the Handlebars.js package README.md revolves around a templating engine that is based on the Mustache templating language. Handlebars.js is designed to separate the logic of an application from its presentation layer by allowing templates to be written in a way that does not include any actual logic code.

Here's a brief summary of its primary features and functionality:

1. **Logicless Templating**: Handlebars maintains the conceptual framework of Mustache, focusing on separating presentation from business logic. It doesn't have if-else conditions or for-loops; instead, it relies on helper functions for logic.

2. **Template Compilation**: Templates written in Handlebars need to be compiled into a function which then can accept a context object to render HTML or any text format outputs.

3. **Syntax and Usage**: Handlebars introduces extensions over Mustache capabilities like nested paths, helpers, block expressions, and more. You embed variables in templates using double curly braces `{{ }}`.

4. **Precompilation**: It supports precompiling templates to JavaScript code to improve runtime performance, suitable for scenarios where templates don't change frequently.

5. **Helpers and Partials**: Handlebars provides mechanisms such as helpers for reusable functions and partials for incorporating templates within templates. 

6. **Supported Environments**: It works with Node.js and major browsers (including older ones like IE6), making it versatile for both server-side and client-side rendering tasks.

Below is a sample Node.js package implementing a basic version of the Handlebars.js functionality:

```markdown
// package.json
{
  "name": "basic-handlebars",
  "version": "1.0.0",
  "description": "A basic implementation of Handlebars-like templating engine.",
  "main": "index.js",
  "dependencies": {},
  "devDependencies": {},
  "scripts": {
    "test": "node test.js"
  },
  "author": "Your Name",
  "license": "MIT"
}

// index.js
class BasicHandlebars {
  constructor() {
    this.helpers = {};
  }

  compile(template) {
    return (context) => this.render(template, context);
  }

  render(template, context) {
    return template.replace(/\{\{(\w+)\}\}/g, (match, prop) => {
      return this.resolvePath(context, prop);
    });
  }

  resolvePath(context, prop) {
    return context[prop] ?? '';
  }

  registerHelper(name, fn) {
    this.helpers[name] = fn;
  }

  applyHelpers(template, context) {
    return template.replace(/\{\{#(\w+) (.+?)\}\}(.*?)\{\{\/\1\}\}/gs, (match, helper, args, inner) => {
      if (this.helpers[helper]) {
        return this.helpers[helper](JSON.parse(args), inner, context);
      }
      return match;
    });
  }
}

module.exports = BasicHandlebars;

// test.js
const BasicHandlebars = require('./index');

const source = "<p>Hello, my name is {{name}}. I am from {{hometown}}.</p>";
const data = { name: "Alan", hometown: "Somewhere, TX" };

const handlebars = new BasicHandlebars();
const template = handlebars.compile(source);
const result = template(data);

console.log(result); 
// Expected Output:
// <p>Hello, my name is Alan. I am from Somewhere, TX.</p>
```

In the code provided, we defined a very basic `BasicHandlebars` class with essential features like compiling a template, replacing placeholders with context data, and registering helpers. This serves as a simple illustration of part of the functionality Handlebars.js can provide, allowing for a mustache-like syntax with some placeholder resolution capabilities.