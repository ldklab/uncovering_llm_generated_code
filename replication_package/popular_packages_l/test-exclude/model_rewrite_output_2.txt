The provided Node.js code defines a `TestExclude` class used for determining whether files in a directory should be instrumented (processed for test coverage or similar tasks) based on specified criteria. Here is a breakdown of the functionality:

1. **Constructor**: Initializes the `TestExclude` instance with options for the current working directory (`cwd`), files to exclude (`exclude`), whether to exclude `node_modules` (`excludeNodeModules`), files to include (`include`), and valid file extensions for processing (`extension`).

2. **getDefaultExcludes**: Provides default patterns for files to exclude if not specified otherwise, such as test files.

3. **shouldInstrument**: Determines whether a given file should be instrumented based on:
   - If the file is in the `cwd`.
   - If the file is in `node_modules` when such files should be excluded.
   - If the file has the right extension.
   - If the file is not explicitly excluded and is included by the patterns.

4. **globSync & glob**: These methods retrieve all files in a directory matching the instrument criteria.
   - `globSync`: Synchronously reads files in the directory and filters them.
   - `glob`: Asynchronous version of `globSync` using Promises.

5. **recursiveReadDirSync**: Recursively reads directories to assemble a list of files.

The code ends with a module export for `TestExclude` and a usage example, testing `shouldInstrument` and `globSync`. Here's the rewritten version:

```javascript
const fs = require('fs');
const path = require('path');
const micromatch = require('micromatch');

class TestExclude {
    constructor(options = {}) {
        this.cwd = options.cwd || process.cwd();
        this.exclude = options.exclude || [
            '**/test.js',
            '**/*.spec.js',
        ];
        this.excludeNodeModules = options.excludeNodeModules !== undefined ? options.excludeNodeModules : true;
        this.include = options.include || ['**'];
        this.extension = options.extension || ['.js', '.cjs', '.mjs', '.ts', '.tsx', '.jsx'];
    }

    shouldInstrument(filename) {
        if (!filename.startsWith(this.cwd)) return false;
        
        const relativeFilename = path.relative(this.cwd, filename);
        if (this.excludeNodeModules && relativeFilename.includes('node_modules')) return false;
        if (!this.extension.includes(path.extname(relativeFilename))) return false;
        if (micromatch.any(relativeFilename, this.exclude)) return false;
        
        return micromatch.any(relativeFilename, this.include);
    }

    globSync(cwd = this.cwd) {
        return this.recursiveReadDirSync(cwd).filter(file => this.shouldInstrument(file));
    }

    glob(cwd = this.cwd) {
        return Promise.resolve().then(() => this.globSync(cwd));
    }

    recursiveReadDirSync(dirPath, arrayOfFiles = []) {
        fs.readdirSync(dirPath).forEach(file => {
            const filePath = path.join(dirPath, file);
            fs.statSync(filePath).isDirectory()
                ? this.recursiveReadDirSync(filePath, arrayOfFiles)
                : arrayOfFiles.push(filePath);
        });
        return arrayOfFiles;
    }
}

module.exports = TestExclude;

// Usage example
const excludeInstance = new TestExclude();
console.log(excludeInstance.shouldInstrument(path.join(process.cwd(), 'index.js')));
console.log(excludeInstance.globSync());
```