The `foreground-child` Node.js module provides a way to run a child process as if it's the main process of the application. This module takes care of setting up standard input/output streams between the parent and child processes, and ensures that when the child process exits, the parent process also exits with the same exit code or signal. Below is an overview of its functionalities and details:

1. **Running Child Processes**: You can use `foregroundChild` to launch a child process with a given command and optional arguments. The process will run in the foreground meaning that the parent will exit once the child process exits. If the child process receives a signal, the parent will also exit in a similar manner.

2. **Custom Spawn Options**: You can pass custom options to tailor how the child process is spawned. For example, you can specify whether the command should be executed in a shell.

3. **Callback Support**: An optional callback can be executed before the foreground process exits. The callback can return a Promise, which allows for asynchronous operations. Depending on the callback's return value, you can control the parent process's termination behavior (e.g., exit with a specific code or signal, or prevent exit).

4. **Signal Handling**: The module provides utilities like `proxySignals` to pass signals received by the parent process to the child process, ensuring consistent behavior when handling interrupts.

5. **Watchdog Process**: A special watchdog process is automatically spawned to ensure that child processes don't become orphaned on certain signals like SIGKILL, which cannot be caught by the parent.

6. **Caveats**: The module shares the standard IO descriptors with the child process, and if there's any IPC channel, it uses descriptor 3. Special care is needed when dealing with custom file descriptors.

Here's the complete implementation of the `foreground-child` module:

```js
// index.js
import { spawn } from 'child_process'
import process from 'process'

export function foregroundChild(cmd, args, optionsOrCallback, maybeCallback) {
  let options = typeof optionsOrCallback === 'function' ? {} : optionsOrCallback
  let callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : maybeCallback
  
  const cmdWithArgs = typeof args === 'string' ? [args] : args
  const optionsWithStdio = { ...options, stdio: [0, 1, 2, 'ipc'] }

  const child = spawn(cmd, cmdWithArgs, optionsWithStdio)

  function handleExit(code, signal) {
    if (!callback) {
      process.exit(code || (signal ? 1 : 0))
    } else {
      const result = callback()
      if (result instanceof Promise) {
        result.then(res => handleCallbackResult(res, code, signal)).catch(() => process.exit(1))
      } else {
        handleCallbackResult(result, code, signal)
      }
    }
  }

  function handleCallbackResult(result, code, signal) {
    if (typeof result === 'number') {
      process.exit(result)
    } else if (typeof result === 'string') {
      process.kill(process.pid, result)
    } else if (result !== false) {
      process.exit(code || (signal ? 1 : 0))
    }
  }
  
  child.on('exit', handleExit)
  child.on('error', () => process.exit(1))
  return child
}

// proxy-signals.js
import process from 'process'

export function proxySignals(childProcess) {
  const signals = ['SIGINT', 'SIGTERM', 'SIGHUP', 'SIGBREAK']
  signals.forEach(signal => 
    process.on(signal, () => childProcess.kill(signal))
  )
}

// watchdog.js
import { spawn } from 'child_process'
import process from 'process'

export function watchdog(childProcess) {
  const watchdogProcess = spawn(process.argv[0], [
    '-e',
    `
      process.stdin.resume()
      process.on('SIGHUP', () => {
        setTimeout(() => process.kill(${childProcess.pid}, 'SIGKILL'), 500)
      })
    `
  ])
  
  process.on('exit', () => watchdogProcess.kill('SIGHUP'))
  return watchdogProcess
}
```