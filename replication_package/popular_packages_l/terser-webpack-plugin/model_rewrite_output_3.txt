The provided Node.js code defines a TerserPlugin class for Webpack, specifically to handle JavaScript file minification using Terser. The plugin is configured to match specific JavaScript files, run minification processes in parallel, and extract comments where necessary. Here's a detailed functionality breakdown:

- **Constructor**: Initializes default options like test regex for JavaScript files, parallel processing, comments extraction, and customizable Terser options. Options can be overridden via the `options` parameter.

- **apply Method**: Integrates the plugin into the Webpack compiler's lifecycle.
  - Hooks into the compilation process using `optimizeChunkAssets` to trigger on asset optimization.
  - Collects files based on configuration (e.g., test, include, exclude).
  - Tasks for minification are created and run in parallel using the specified or default number of CPU cores.
  
- **Minification**:
  - Each file is processed to generate a minified version using Terser.
  - Extracted comments are handled separately and written to a `.LICENSE.txt` file.
  
- **isFile Method**: Evaluates if a file matches the specified criteria of the plugin configuration.

- **runTasksInParallel Method**: Executes minification tasks concurrently respecting given parallel limits.

Below is the rewritten version of the provided code:

```javascript
// terser-webpack-plugin/index.js

const { cpus } = require('os');
const { terserMinify } = require('terser');

class TerserPlugin {
  constructor(options = {}) {
    this.options = {
      test: /\.m?js(\?.*)?$/i,
      parallel: true,
      extractComments: true,
      terserOptions: {},
      ...options,
    };
  }

  apply(compiler) {
    const { test, include, exclude, parallel, minify, terserOptions, extractComments } = this.options;

    compiler.hooks.compilation.tap('TerserPlugin', (compilation) => {
      compilation.hooks.optimizeChunkAssets.tapPromise('TerserPlugin', async (chunks) => {
        const files = {};

        chunks.forEach((chunk) => {
          chunk.files.forEach((file) => {
            if (this.isFile(file, test, include, exclude)) {
              files[file] = compilation.assets[file];
            }
          });
        });

        const tasks = Object.keys(files).map((file) => async () => {
          const asset = files[file];
          const source = asset.source();

          let result;
          try {
            const minifyFunc = minify || terserMinify;
            result = await minifyFunc({ [file]: source }, null, terserOptions, extractComments);
          } catch (error) {
            compilation.errors.push(error);
            return;
          }

          compilation.assets[file] = {
            source: () => result.code,
            size: () => Buffer.byteLength(result.code, 'utf8'),
          };

          if (result.extractedComments && extractComments) {
            const commentsFile = `${file}.LICENSE.txt`;
            compilation.assets[commentsFile] = {
              source: () => result.extractedComments.join('\n\n'),
              size: () => result.extractedComments.reduce((sum, comment) => sum + comment.length + 2, 0),
            };
          }
        });

        const parallelCount = this.calculateParallelTasks(parallel);
        await this.runTasksInParallel(tasks, parallelCount);
      });
    });
  }

  isFile(filename, test, include, exclude) {
    return (
      (!test || new RegExp(test).test(filename)) &&
      (!include || new RegExp(include).test(filename)) &&
      (!exclude || !new RegExp(exclude).test(filename))
    );
  }

  async runTasksInParallel(tasks, parallelCount) {
    const parallelTasks = tasks.splice(0, parallelCount);
    await Promise.all(parallelTasks.map((task) => task()));
    if (tasks.length > 0) {
      await this.runTasksInParallel(tasks, parallelCount);
    }
  }

  calculateParallelTasks(parallel) {
    return parallel === true ? cpus().length - 1 : parallel;
  }
}

module.exports = TerserPlugin;
```