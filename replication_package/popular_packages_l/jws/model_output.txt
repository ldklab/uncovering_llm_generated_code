The `node-jws` library is a Node.js implementation of JSON Web Signatures (JWS) according to the draft-ietf-jose-json-web-signature-08 specification, with the exception of X.509 Certificate Chain support. It offers both synchronous and streaming APIs for creating and verifying JWS.

Key features and functions of the library include:

1. **Supported Algorithms**: The library supports several algorithms for creating and verifying signatures, including HMAC (HS256, HS384, HS512), RSA (RS256, RS384, RS512), RSASSA-PSS (PS256, PS384, PS512), ECDSA (ES256, ES384, ES512), and no signature (none).

2. **Synchronous API**:
   - `jws.sign(options)`: Generates a JWS using specified options that include header (mandatory with `alg`), payload, and either a secret or private key. Returns the JWS as a string.
   - `jws.verify(signature, algorithm, secretOrKey)`: Verifies a given JWS signature against a secret or key according to the specified algorithm. Returns `true` if valid, `false` otherwise.
   - `jws.decode(signature)`: Decodes a JWS signature into its component parts: header, payload, and signature.

3. **Streaming API**:
   - `jws.createSign(options)`: Returns a SignStream object to create a JWS over streams. It emits a 'done' event with the signature.
   - `jws.createVerify(options)`: Returns a VerifyStream object to verify JWS over streams. It emits a 'done' event indicating whether the signature is valid.

4. **Classes**:
   - `SignStream`: A Readable Stream that emits the calculated signature. It can accept a payload and key/secret via Writable streams.
   - `VerifyStream`: Similar to `SignStream`, it verifies the signature and emits a result.

Example usage is provided for both synchronous and streaming methods. The streaming versions are useful for handling data as streams when they aren't immediately available as strings or buffers.

Below is the implementation of a minimal version of this library:

```js
const crypto = require('crypto');
const { Readable, Writable } = require('stream');

const jws = {
  ALGORITHMS: [
    'HS256', 'HS384', 'HS512',
    'RS256', 'RS384', 'RS512',
    'PS256', 'PS384', 'PS512',
    'ES256', 'ES384', 'ES512',
    'none'
  ],

  sign({ header, payload, secret, privateKey, encoding = 'utf8' }) {
    if (!header || !header.alg || !this.ALGORITHMS.includes(header.alg)) {
      throw new Error('Invalid algorithm');
    }
    const encodedHeader = Buffer.from(JSON.stringify(header)).toString('base64url');
    const encodedPayload = Buffer.from(typeof payload === 'string' ? payload : JSON.stringify(payload)).toString('base64url');
    const signature = this.#createSignature(encodedHeader, encodedPayload, secret || privateKey, header.alg);
    return `${encodedHeader}.${encodedPayload}.${signature}`;
  },

  verify(signature, algorithm, secretOrKey) {
    const [encodedHeader, encodedPayload, signaturePart] = signature.split('.');
    if (!encodedHeader || !encodedPayload || !signaturePart) {
      return false;
    }
    const header = JSON.parse(Buffer.from(encodedHeader, 'base64url').toString('utf8'));
    if (header.alg !== algorithm) {
      return false;
    }
    const expectedSignature = this.#createSignature(encodedHeader, encodedPayload, secretOrKey, algorithm);
    return expectedSignature === signaturePart;
  },
  
  decode(signature) {
    const [encodedHeader, encodedPayload, signaturePart] = signature.split('.');
    return {
      header: JSON.parse(Buffer.from(encodedHeader, 'base64url').toString('utf8')),
      payload: Buffer.from(encodedPayload, 'base64url').toString('utf8'),
      signature: signaturePart
    };
  },

  createSign({ header, payload, privateKey, secret }) {
    const signStream = new SignStream(header, privateKey || secret);
    if (payload) {
      signStream.write(payload);
      signStream.end();
    }
    return signStream;
  },

  createVerify({ signature, algorithm, key, publicKey, secret }) {
    const verifyStream = new VerifyStream(signature, algorithm, publicKey || key || secret);
    if (signature) {
      verifyStream.write(signature);
      verifyStream.end();
    }
    return verifyStream;
  },

  #createSignature(encodedHeader, encodedPayload, key, alg) {
    const data = `${encodedHeader}.${encodedPayload}`;
    switch (alg.slice(0, 2)) {
      case 'HS': // HMAC
        return crypto.createHmac(alg.replace('HS', 'sha'), key).update(data).digest('base64url');
      case 'RS': // RSA
      case 'ES': // ECDSA
      case 'PS': // RSASSA-PSS
        return crypto.sign(alg.replace('ES', 'ecdsa').replace('RS', 'RSA-SHA').replace('PS', 'RSA-SHA'), Buffer.from(data), key).toString('base64url');
      case 'no': // none
        return '';
      default:
        throw new Error('Unsupported algorithm');
    }
  }
};

class SignStream extends Writable {
  constructor(header, key) {
    super();
    this.header = header;
    this.key = key;
    this.chunks = [];
  }

  _write(chunk, encoding, callback) {
    this.chunks.push(chunk);
    callback();
  }

  end() {
    const payload = Buffer.concat(this.chunks).toString();
    const signature = jws.sign({ header: this.header, payload, privateKey: this.key });
    this.emit('done', signature);
  }
}

class VerifyStream extends Writable {
  constructor(signature, algorithm, key) {
    super();
    this.signature = signature;
    this.algorithm = algorithm;
    this.key = key;
  }

  _write(chunk, encoding, callback) {
    this.signature = chunk.toString();
    callback();
  }

  end() {
    const valid = jws.verify(this.signature, this.algorithm, this.key);
    this.emit('done', valid, valid ? jws.decode(this.signature) : null);
  }
}

module.exports = jws;
```
