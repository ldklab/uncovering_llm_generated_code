The provided Node.js code defines a module for JSON Web Signature (JWS) generation, verification, and streaming operations. Here's a breakdown of its functionality:

1. **Supported Algorithms**: The module supports a range of algorithms for signing and verifying tokens, including HMAC, RSA, ECDSA, and none.

2. **Signing**: The `sign` method creates a JWS given a header specifying the algorithm, a payload, and a secret or private key. It encodes the header and payload in base64url format and appends a signature generated based on the chosen algorithm.

3. **Verification**: The `verify` method checks whether a token's signature is valid by comparing it to a newly calculated signature using the provided secret or key and specified algorithm.

4. **Decoding**: The `decode` method extracts and returns the header, payload, and signature parts of a JWS without verifying the signature.

5. **Streaming**: The module includes implementations of `SignStream` and `VerifyStream`, which are writable streams for signing and verifying tokens. These streams handle data in chunks and emit events once the signing or verification process is completed.

6. **Private Helper Function**: The `#createSignature` private method generates signatures using the specified algorithm and key.

Here is the reorganized and slightly modified version of the original code:

```javascript
const crypto = require('crypto');
const { Writable } = require('stream');

const jws = {
  ALGORITHMS: [
    'HS256', 'HS384', 'HS512',
    'RS256', 'RS384', 'RS512',
    'PS256', 'PS384', 'PS512',
    'ES256', 'ES384', 'ES512',
    'none'
  ],

  sign(options) {
    const { header, payload, secret, privateKey, encoding = 'utf8' } = options;
    if (!header || !header.alg || !this.ALGORITHMS.includes(header.alg)) {
      throw new Error('Invalid algorithm');
    }
    const encodedHeader = Buffer.from(JSON.stringify(header), encoding).toString('base64url');
    const encodedPayload = Buffer.from(typeof payload === 'string' ? payload : JSON.stringify(payload), encoding).toString('base64url');
    const signature = this.#createSignature(encodedHeader, encodedPayload, secret || privateKey, header.alg);
    return `${encodedHeader}.${encodedPayload}.${signature}`;
  },

  verify(signature, algorithm, secretOrKey) {
    const [encodedHeader, encodedPayload, signaturePart] = signature.split('.');
    if (!encodedHeader || !encodedPayload || !signaturePart) {
      return false;
    }
    const header = JSON.parse(Buffer.from(encodedHeader, 'base64url').toString('utf8'));
    if (header.alg !== algorithm) {
      return false;
    }
    const expectedSignature = this.#createSignature(encodedHeader, encodedPayload, secretOrKey, algorithm);
    return expectedSignature === signaturePart;
  },

  decode(signature) {
    const [encodedHeader, encodedPayload, signaturePart] = signature.split('.');
    return {
      header: JSON.parse(Buffer.from(encodedHeader, 'base64url').toString('utf8')),
      payload: Buffer.from(encodedPayload, 'base64url').toString('utf8'),
      signature: signaturePart
    };
  },

  createSign(options) {
    const { header, payload, secret, privateKey } = options;
    const signStream = new SignStream(header, privateKey || secret);
    if (payload) {
      signStream.write(payload);
      signStream.end();
    }
    return signStream;
  },

  createVerify(options) {
    const { signature, algorithm, key, publicKey, secret } = options;
    const verifyStream = new VerifyStream(signature, algorithm, publicKey || key || secret);
    return verifyStream;
  },

  #createSignature(encodedHeader, encodedPayload, key, alg) {
    const data = `${encodedHeader}.${encodedPayload}`;
    switch (alg.slice(0, 2)) {
      case 'HS':
        return crypto.createHmac(alg.replace('HS', 'sha'), key).update(data).digest('base64url');
      case 'RS':
      case 'ES':
      case 'PS':
        return crypto.sign(alg.replace('ES', 'ecdsa').replace('RS', 'RSA-SHA').replace('PS', 'RSA-SHA'), data, key).toString('base64url');
      case 'no':
        return '';
      default:
        throw new Error('Unsupported algorithm');
    }
  }
};

class SignStream extends Writable {
  constructor(header, key) {
    super();
    this.header = header;
    this.key = key;
    this.chunks = [];
  }

  _write(chunk, encoding, callback) {
    this.chunks.push(chunk);
    callback();
  }

  end() {
    const payload = Buffer.concat(this.chunks).toString();
    const signature = jws.sign({ header: this.header, payload, privateKey: this.key });
    this.emit('done', signature);
  }
}

class VerifyStream extends Writable {
  constructor(signature, algorithm, key) {
    super();
    this.signature = signature;
    this.algorithm = algorithm;
    this.key = key;
  }

  _write(chunk, encoding, callback) {
    this.signature = chunk.toString();
    callback();
  }

  end() {
    const valid = jws.verify(this.signature, this.algorithm, this.key);
    this.emit('done', valid, valid ? jws.decode(this.signature) : null);
  }
}

module.exports = jws;
```