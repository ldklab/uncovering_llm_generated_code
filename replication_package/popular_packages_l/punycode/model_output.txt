The Punycode.js library is a JavaScript implementation of the Punycode algorithm, which is used to convert Unicode strings (e.g., written in various natural languages) into ASCII strings suitable for domain names and email addresses. This is achieved by representing non-ASCII characters in ASCII-only character sets, compliant with RFCs 3492 and 5891. Here's a concise breakdown of each functionality described in the README:

1. **punycode.decode(string)**: Takes a Punycode string made up of ASCII symbols and converts it into a Unicode string. This is useful for understanding the original text from a Punycode-encoded domain name.

2. **punycode.encode(string)**: Takes a Unicode string, which might include non-ASCII characters, and converts it into a Punycode string. This is used to convert domain names into a format compatible with the ASCII-based DNS system.

3. **punycode.toUnicode(input)**: Converts a Punycode string representing domain names or email addresses back to Unicode. This function only converts parts of the string that are encoded as Punycode.

4. **punycode.toASCII(input)**: Converts a Unicode string to a Punycode string, applicable for domain names or email addresses. It only converts non-ASCII parts, allowing ASCII parts to remain unchanged.

5. **punycode.ucs2.decode(string)**: Converts a string into an array of Unicode code points. This can handle surrogate pairs, converting them into single code points.

6. **punycode.ucs2.encode(codePoints)**: Converts an array of Unicode code points back into a string. This reverses the operation of ucs2.decode.

7. **punycode.version**: Provides the version of the Punycode.js library being used.

Given these functionalities, we can implement a basic version of the described Punycode.js library:

```js
// Punycode.js
const punycode = (() => {
  
  function decode(input) {
    // Convert Punycode to Unicode
    return decodePunycode(input);
  }

  function encode(input) {
    // Convert Unicode to Punycode
    return encodePunycode(input);
  }

  function toUnicode(input) {
    return input.split('.').map(part => {
      return part.startsWith('xn--') ? decode(part.slice(4)) : part;
    }).join('.');
  }

  function toASCII(input) {
    return input.split('.').map(part => {
      return /[^\x00-\x7F]/.test(part) ? 'xn--' + encode(part) : part;
    }).join('.');
  }

  function ucs2decode(string) {
    const output = [];
    let counter = 0;
    const length = string.length;

    while (counter < length) {
      const value = string.charCodeAt(counter++);
      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // High surrogate, and there is a next character.
        const extra = string.charCodeAt(counter++);
        if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        } else {
          // It's invalid; append a substitute character.
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }

  function ucs2encode(array) {
    return array.map(value => {
      if (value > 0xFFFF) {
        value -= 0x10000;
        return String.fromCharCode((value >>> 10) + 0xD800, (value & 0x3FF) + 0xDC00);
      }
      return String.fromCharCode(value);
    }).join('');
  }

  return {
    decode: decode,
    encode: encode,
    toUnicode: toUnicode,
    toASCII: toASCII,
    ucs2: {
      decode: ucs2decode,
      encode: ucs2encode,
    },
    version: '2.0.0'
  };

  // Placeholder for actual Punycode encode/decode logic
  function decodePunycode(input) {
    // Write the actual decoding logic here
    return `${input}`;
  }

  function encodePunycode(input) {
    // Write the actual encoding logic here
    return `${input}`;
  }
})();

module.exports = punycode;
```

In this implementation, the core Punycode encoding and decoding logic would need to be filled out according to the Punycode algorithm, as described in RFC 3492. The library provides modular functions to convert between Unicode and Punycode, accommodating the needs for handling internationalized domain names (IDNs) and ensuring compatibility with legacy systems that only support ASCII.