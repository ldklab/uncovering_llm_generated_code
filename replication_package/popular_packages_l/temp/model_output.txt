The `temp` package for Node.js provides functionality for creating and managing temporary files, directories, and streams. It automatically handles naming these files/directories uniquely under the system's temporary directory and can automatically clean them up if configured to do so.

Main features include:
1. **Temporary Files**: Create temporary files using `open` and `openSync`. These functions provide an optional ability to set filenames using prefixes and/or suffixes and return an object containing the file path and file descriptor. Files can be set to automatically delete on process exit when `track()` is called.

2. **Temporary Directories**: Create temporary directories with `mkdir` and `mkdirSync`, with similar affix options for naming. These directories are registered for cleanup if tracking is enabled.

3. **Temporary Streams**: Create writable streams using `createWriteStream`, which automatically gains an associated temporary path and gets registered for cleanup.

4. **Affixes**: When creating files or directories, you can specify affixes (prefix/suffix) or a specific directory to customize their names.

5. **Cleanup Management**: By calling `track()`, the module will keep track of all temporary items created and remove them on process exit. Manual cleanup can be triggered using `cleanup()` or `cleanupSync()`.

6. **Manual Path Generation**: Use the `path` method to generate a unique path in the temporary directory.

Here's the implementation:

```javascript
const fs = require('fs');
const os = require('os');
const path = require('path');
const crypto = require('crypto');

let trackedFiles = [];
let trackedDirs = [];

function generateUniqueName(prefix = '', suffix = '', dir = os.tmpdir()) {
  const uniqueId = crypto.randomBytes(16).toString('hex');
  return path.join(dir, `${prefix}${uniqueId}${suffix}`);
}

function trackFile(filePath) {
  trackedFiles.push(filePath);
}

function trackDir(dirPath) {
  trackedDirs.push(dirPath);
}

function cleanupSync() {
  let filesDeleted = 0;
  let dirsDeleted = 0;

  trackedFiles.forEach(filePath => {
    try {
      fs.unlinkSync(filePath);
      filesDeleted++;
    } catch (err) {
      console.error(`Failed to delete file: ${filePath}`, err);
    }
  });

  trackedDirs.forEach(dirPath => {
    try {
      fs.rmdirSync(dirPath);
      dirsDeleted++;
    } catch (err) {
      console.error(`Failed to delete dir: ${dirPath}`, err);
    }
  });

  trackedFiles = [];
  trackedDirs = [];
  
  return { files: filesDeleted, dirs: dirsDeleted };
}

function cleanup(callback) {
  try {
    const result = cleanupSync();
    callback(null, result);
  } catch (err) {
    callback(err);
  }
}

function track() {
  process.on('exit', cleanupSync);
  return module.exports;
}

function open(options, callback) {
  if (typeof options === 'string') options = { prefix: options };

  const filePath = generateUniqueName(options.prefix, options.suffix, options.dir);
  fs.open(filePath, 'w', (err, fd) => {
    if (err) return callback(err);
    trackFile(filePath);
    callback(null, { path: filePath, fd });
  });
}

function openSync(options = {}) {
  const filePath = generateUniqueName(options.prefix, options.suffix, options.dir);
  const fd = fs.openSync(filePath, 'w');
  trackFile(filePath);
  return { path: filePath, fd };
}

function mkdir(options, callback) {
  if (typeof options === 'string') options = { prefix: options };

  const dirPath = generateUniqueName(options.prefix, options.suffix, options.dir);
  fs.mkdir(dirPath, err => {
    if (err) return callback(err);
    trackDir(dirPath);
    callback(null, dirPath);
  });
}

function mkdirSync(options = {}) {
  const dirPath = generateUniqueName(options.prefix, options.suffix, options.dir);
  fs.mkdirSync(dirPath);
  trackDir(dirPath);
  return dirPath;
}

function createWriteStream(options = {}) {
  const filePath = generateUniqueName(options.prefix, options.suffix, options.dir);
  const stream = fs.createWriteStream(filePath);
  stream.path = filePath;
  trackFile(filePath);
  return stream;
}

function path(options = {}) {
  return generateUniqueName(options.prefix, options.suffix, options.dir);
}

module.exports = {
  open,
  openSync,
  mkdir,
  mkdirSync,
  createWriteStream,
  path,
  track,
  cleanup,
  cleanupSync
};
```