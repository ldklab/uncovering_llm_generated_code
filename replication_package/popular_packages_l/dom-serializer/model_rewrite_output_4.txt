The Node.js code defines a class `DomSerializer` that is responsible for serializing a DOM-like node structure into a string representation of HTML or XML. The class accepts a set of options to customize the serialization process, including whether to encode or decode entities, handle empty attributes, allow self-closing tags, and work in XML mode. The main functionality revolves around traversing the DOM nodes, determining their type (e.g., tag, text, comment), and rendering them accordingly. The serializer caters to different node types and constructs appropriate string outputs, handling attributes, child nodes, and different types of tags (standard, self-closing, comments, etc.). The class provides a `render` method to initiate serialization, and a function is exported to facilitate ease of use.

Here's the rewritten code:

```javascript
// dom-serializer.js

class DomSerializer {
  constructor(options = {}) {
    this.options = {
      encodeEntities: 'utf8',
      decodeEntities: true,
      emptyAttrs: false,
      selfClosingTags: false,
      xmlMode: false,
      ...options,
    };
  }

  render(node) {
    return Array.isArray(node)
      ? node.map((n) => this.renderNode(n)).join('')
      : this.renderNode(node);
  }

  renderNode(node) {
    switch (node.type) {
      case 'tag':
      case 'script':
      case 'style':
        return this.renderTag(node);
      case 'text':
        return this.options.decodeEntities
          ? this.decodeEntities(node.data)
          : node.data;
      case 'comment':
        return `<!--${node.data}-->`;
      case 'directive':
      case '!doctype':
        return `<!${node.data}>`;
      default:
        return '';
    }
  }

  renderTag(node) {
    const tagName =
      this.options.xmlMode === 'foreign' ? node.name.toLowerCase() : node.name;
    const attrs = this.renderAttributes(node.attribs);
    const hasChildren = node.children && node.children.length > 0;
    const isSelfClosing = this.isSelfClosing(node);

    if (isSelfClosing && !hasChildren) {
      return `<${tagName}${attrs}${
        this.options.selfClosingTags ? ' /' : ''
      }>`;
    }

    return `<${tagName}${attrs}>${this.render(node.children)}</${tagName}>`;
  }

  renderAttributes(attribs = {}) {
    return Object.entries(attribs)
      .map(([key, value]) => {
        return value === '' && !this.options.emptyAttrs
          ? ` ${key}`
          : ` ${key}="${value.replace(/\"/g, '&quot;')}"`;
      })
      .join('');
  }

  isSelfClosing(node) {
    return node.name && (!node.children || node.children.length === 0);
  }

  decodeEntities(data) {
    return data
      .replace(/&quot;/g, '"')
      .replace(/&amp;/g, '&')
      .replace(/&gt;/g, '>')
      .replace(/&lt;/g, '<');
  }
}

module.exports = {
  default(node, options) {
    const serializer = new DomSerializer(options);
    return serializer.render(node);
  },
};
```