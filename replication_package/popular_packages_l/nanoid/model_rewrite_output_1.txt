The provided Node.js script is designed to generate unique identifiers using both secure and non-secure methods. The main components are as follows:

1. `getRandomBytes(size)`: Asynchronously generates a specified number of random bytes using Node.js's `crypto.randomBytes` method.

2. `nanoid(size, alphabet)`: An asynchronous function that generates a secure, URL-friendly unique identifier of a specified size, using an optional custom alphabet.

3. `nonSecureNanoid(size, alphabet)`: Generates a non-secure unique identifier by leveraging JavaScript's `Math.random` function.

4. `customAlphabet(alphabet, size)`: Creates a function that generates non-secure IDs using a specified alphabet and size.

5. `customRandom(alphabet, size, random)`: Allows the creation of a custom ID generator using a user-defined random function and a specified alphabet and size.

6. `example()`: Demonstrates usage of the secure and non-secure ID generation functions and prints the IDs to the console.

The module exports functions for generating IDs with both secure and non-secure methods, as well as for creating custom generators.

```javascript
import crypto from 'crypto';

// Default alphabet for URL-friendly IDs
const urlAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';

// Generate random bytes securely
function getRandomBytes(size) {
  return new Promise((resolve, reject) => {
    crypto.randomBytes(size, (err, buf) => {
      if (err) reject(err);
      else resolve(buf);
    });
  });
}

// Nano ID function to generate secure IDs
async function nanoid(size = 21, alphabet = urlAlphabet) {
  const bytes = await getRandomBytes(size);
  let id = '';
  const mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1;
  let step = Math.ceil((1.6 * mask * size) / alphabet.length);

  while (true) {
    const random = await getRandomBytes(step);
    let i = step;
    while (i--) {
      const byte = random[i] & mask;
      if (alphabet[byte]) {
        id += alphabet[byte];
        if (id.length === size) return id;
      }
    }
  }
}

// Non-secure Nano ID function using Math.random
function nonSecureNanoid(size = 21, alphabet = urlAlphabet) {
  let id = '';
  while (size--) {
    id += alphabet[(Math.random() * alphabet.length) | 0];
  }
  return id;
}

// Custom Alphabet Generator
function customAlphabet(alphabet, size = 21) {
  return () => nonSecureNanoid(size, alphabet);
}

// Custom Random ID Generator
function customRandom(alphabet, size, random) {
  return () => {
    let id = '';
    while (size--) {
      id += alphabet[random(size)];
    }
    return id;
  }
}

// Example usage
async function example() {
  console.log('Secure NanoID:', await nanoid());
  console.log('Non-secure NanoID:', nonSecureNanoid());
  const customId = customAlphabet('abcdef', 10);
  console.log('Custom Alphabet ID:', customId());
}

example().catch(console.error);

export {
  nanoid,
  nonSecureNanoid,
  customAlphabet,
  customRandom,
  urlAlphabet
};
```