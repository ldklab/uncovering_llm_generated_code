The provided Node.js code is a module that creates unique identifiers or IDs using random bytes. It accomplishes this using both a secure method leveraging Node's `crypto` module and a non-secure method using `Math.random`. The code allows for customization of the ID characteristics including length and character set. 

### Functionality:

1. **Generate Secure Random Bytes:** 
   - Uses `crypto.randomBytes` to produce cryptographically secure random bytes.

2. **`nanoid(size, alphabet)`:** 
   - Asynchronously generates a secure URL-friendly unique ID, with default length 21, using a given alphabet.

3. **`nonSecureNanoid(size, alphabet)`:**
   - Generates a non-secure URL-friendly unique ID using `Math.random`, defaulting to a 21-character length with the specified alphabet.

4. **`customAlphabet(alphabet, size)`:**
   - Creates a function to generate non-secure IDs with a custom alphabet and size.

5. **`customRandom(alphabet, size, random)`:**
   - Allows custom random string generation by supplying a randomizer function, alphabet, and size.

6. **`example()` Function:**
   - Demonstrates the use of both secure and non-secure ID generators along with a custom alphabet-based generator.

```js
import crypto from 'crypto';

// Default alphabet for URL-friendly IDs
const urlAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';

// Generate random bytes securely
function getRandomBytes(size) {
  return new Promise((resolve, reject) => {
    crypto.randomBytes(size, (err, buf) => {
      if (err) reject(err);
      else resolve(buf);
    });
  });
}

// Nano ID function to generate IDs
async function nanoid(size = 21, alphabet = urlAlphabet) {
  const bytes = await getRandomBytes(size);
  let id = '';
  const mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1;
  let step = Math.ceil((1.6 * mask * size) / alphabet.length);

  while (true) {
    const random = await getRandomBytes(step);
    let i = step;
    while (i--) {
      const byte = random[i] & mask;
      if (alphabet[byte]) {
        id += alphabet[byte];
        if (id.length === size) return id;
      }
    }
  }
}

// Non-secure Nano ID function using Math.random
function nonSecureNanoid(size = 21, alphabet = urlAlphabet) {
  let id = '';
  while (size--) {
    id += alphabet[(Math.random() * alphabet.length) | 0];
  }
  return id;
}

// Custom Alphabet Generator
function customAlphabet(alphabet, size = 21) {
  return () => nonSecureNanoid(size, alphabet);
}

// Custom Random ID Generator
function customRandom(alphabet, size, random) {
  return () => {
    let id = '';
    while (size--) {
      id += alphabet[random(size)];
    }
    return id;
  }
}

// Example usage
async function example() {
  console.log('Secure NanoID:', await nanoid());
  console.log('Non-secure NanoID:', nonSecureNanoid());
  const customId = customAlphabet('abcdef', 10);
  console.log('Custom Alphabet ID:', customId());
}

example().catch(console.error);

export {
  nanoid,
  nonSecureNanoid,
  customAlphabet,
  customRandom,
  urlAlphabet
};
```