The functionality of the Node.js code involves three utility functions for asynchronous operations:

1. **each**: Iterates over a collection, applying an `iteratee` function to each item in parallel. The iteratee function takes an item and a callback to finalize its execution. Once all items have been processed, it invokes a final callback. If any iteratee invokes the callback with an error, the final callback is invoked immediately with the error.

2. **eachSeries**: Similar to `each`, but processes each item in the collection sequentially rather than in parallel. It waits for the current item's iteratee function to complete before moving on to the next one. If there's an error, it calls the callback immediately.

3. **parallel**: Executes multiple asynchronous `tasks` in parallel. Each task is a function that accepts a callback to signal completion. Once all tasks are completed, the final callback is invoked with the results. If a task completes with an error, the final callback is called immediately with that error.

Here's a possible rewrite of the presented code:

```javascript
function each(collection, iteratee, finalCallback) {
  const total = collection.length;
  let completed = 0;

  if (total === 0) return finalCallback(null);
  
  collection.forEach(item => {
    iteratee(item, err => {
      if (err) {
        finalCallback(err);
        finalCallback = () => {}; // Prevent further calls
      } else {
        completed++;
        if (completed === total) finalCallback(null);
      }
    });
  });
}

function eachSeries(collection, iteratee, finalCallback) {
  const total = collection.length;
  let index = 0;

  function iterate() {
    if (index >= total) return finalCallback(null);
    
    iteratee(collection[index], err => {
      if (err) return finalCallback(err);
      index++;
      iterate();
    });
  }

  iterate();
}

function parallel(tasks, finalCallback) {
  const results = [];
  const total = tasks.length;
  let completed = 0;

  if (total === 0) return finalCallback(null, results);

  tasks.forEach((task, idx) => {
    task((err, result) => {
      if (err) {
        finalCallback(err);
        finalCallback = () => {}; // Prevent further calls
      } else {
        results[idx] = result;
        completed++;
        if (completed === total) finalCallback(null, results);
      }
    });
  });
}

// Usage examples:

// each([1, 2, 3], (item, callback) => {
//   setTimeout(() => {
//     console.log(item);
//     callback(null);
//   }, 100);
// }, (err) => {
//   if (err) console.error(err);
//   else console.log('Completed each');
// });

// eachSeries([1, 2, 3], (item, callback) => {
//   setTimeout(() => {
//     console.log(item);
//     callback(null);
//   }, 100);
// }, (err) => {
//   if (err) console.error(err);
//   else console.log('Completed eachSeries');
// });

// parallel([
//   function(callback) {
//     setTimeout(() => {
//       callback(null, 'one');
//     }, 200);
//   },
//   function(callback) {
//     setTimeout(() => {
//       callback(null, 'two');
//     }, 100);
//   }
// ], (err, results) => {
//   if (err) console.error(err);
//   else console.log(results); // ['one', 'two']
// });
```