The `style-loader` is a Node.js package primarily used with webpack, a module bundler, to facilitate the injection of CSS styles into the Document Object Model (DOM) during development. The primary goal of the `style-loader` is to add styles dynamically into the `<head>` section of the generated HTML document. This is particularly useful during development for immediately reflecting style changes without requiring a full page refresh.

Here's a detailed breakdown of its functionality:

1. **Installation and Setup**: 
    - Install using npm, yarn, or pnpm.
    - Use the style-loader typically in combination with `css-loader` in a webpack configuration.

2. **Configuration via Webpack**: 
    - Define rules to process `.css` files using both `style-loader` and `css-loader`.
    - Various `injectType` options determine how styles are injected:
        - Multiple `<style>` tags (`styleTag`).
        - A single `<style>` tag (`singletonStyleTag`).
        - Conditional injection based on browser type (`autoStyleTag`, `lazyStyleTag`, etc.).
        - Using `<link>` tags for importing CSS (`linkTag`).

3. **Advanced Configuration Options**:
    - Customize the insertion point of the injected styles using `insert` options.
    - Attach attributes like `id`, `nonce`, etc., to the `<style>` or `<link>` tags using `attributes`.
    - Set a custom function to transform style tags with `styleTagTransform`.
    - Manage CSS module IDs with `base` to avoid collisions.

4. **Security and Production Use**: 
    - Primarily for development due to its dynamic nature.
    - Recommended for production to use plugins like `mini-css-extract-plugin` to extract CSS into separate files.

5. **Other Features**:
    - Configurations to support CSS Modules, enabling named exports for classes.
    - Integration with content security policies using nonce.
    - Source map support for easier debugging.
    - Compatibility adjustments for various browsers and custom environments.

Here's a hypothetical implementation of such functionality for use with Node.js and webpack:

```javascript
// style-loader/index.js
const path = require('path');
const { getOptions } = require('loader-utils');

function insertStyleIntoDOM(css, options) {
  const styleTag = document.createElement('style');
  styleTag.type = 'text/css';

  if (options.attributes) {
    Object.keys(options.attributes).forEach(attr => {
      styleTag.setAttribute(attr, options.attributes[attr]);
    });
  }

  styleTag.appendChild(document.createTextNode(css));
  const target = document.querySelector(options.insert || 'head');
  target.appendChild(styleTag);
}

module.exports = function(source) {
  const options = getOptions(this) || {};
  const esModule = options.esModule !== false;

  return `${esModule ? 'const' : 'var'} css = ${JSON.stringify(source)};
    (${insertStyleIntoDOM.toString()})(css, ${JSON.stringify(options)});
    export default css;`;
};

// webpack.config.js example
// Assuming `style-loader` is in your project directory, this showcases how to integrate it with webpack.
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const devMode = process.env.NODE_ENV !== 'production';

module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/i,
        use: [
          devMode ? path.resolve(__dirname, './style-loader') : MiniCssExtractPlugin.loader,
          {
            loader: 'css-loader',
            options: {
              sourceMap: true,
              modules: {
                namedExport: true,
                localIdentName: '[name]__[local]--[hash:base64:5]'
              }
            }
          }
        ]
      }
    ]
  },
  plugins: [].concat(devMode ? [] : [new MiniCssExtractPlugin()]),
};
```

In this code:
- We're creating a loader `style-loader` that takes CSS and injects it dynamically into the DOM.
- In `webpack.config.js`, we illustrate using this loader during development and switching to a plugin like `mini-css-extract-plugin` to handle CSS extraction in production. The configuration also includes options for CSS Modules, allowing for scoped class names and easily manageable styles.