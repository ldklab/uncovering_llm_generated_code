The `typed-array-byte-offset` package provides a robust way to get the byte offset of a Typed Array. It returns the byte offset of the array within its ArrayBuffer if the provided input is a Typed Array. If the input is not a Typed Array, it returns `false`. The package is designed to work reliably across different JavaScript environments, even if the `byteOffset` property has been overridden.

### Key Features:
- **Type Checking**: It checks if the input is a Typed Array.
- **Byte Offset Access**: It retrieves the `byteOffset` property of genuine Typed Array instances.
- **Cross-realm Compatibility**: Works correctly regardless of the JavaScript execution context.
- **Override Safety**: Remains functional even if someone overrides native properties like `byteOffset`.

### Usage Example:
The example demonstrates various scenarios where the function is called with different inputs:
- Non-Typed Array inputs like `undefined`, `null`, numbers, and strings return `false`.
- Typed Arrays like `Int8Array`, `Uint8Array`, etc., initialized with specified byte offsets, return the correct byte offset value.

### Implementation:
The implementation involves checking whether the input object is a Typed Array and if so, getting its `byteOffset`. If the input is not a Typed Array, the function returns `false`.

```js
// typed-array-byte-offset.js
function typedArrayByteOffset(input) {
  if (input && typeof input === 'object' && input instanceof Object.getPrototypeOf(Int8Array)) {
    return input.byteOffset;
  }
  return false;
}

module.exports = typedArrayByteOffset;

// test.js
var typedArrayByteOffset = require('./typed-array-byte-offset');
var assert = require('assert');

function runTests() {
  assert.equal(false, typedArrayByteOffset(undefined));
  assert.equal(false, typedArrayByteOffset(null));
  assert.equal(false, typedArrayByteOffset(false));
  assert.equal(false, typedArrayByteOffset(true));
  assert.equal(false, typedArrayByteOffset([]));
  assert.equal(false, typedArrayByteOffset({}));
  assert.equal(false, typedArrayByteOffset(/a/g));
  assert.equal(false, typedArrayByteOffset(new RegExp('a', 'g')));
  assert.equal(false, typedArrayByteOffset(new Date()));
  assert.equal(false, typedArrayByteOffset(42));
  assert.equal(false, typedArrayByteOffset(NaN));
  assert.equal(false, typedArrayByteOffset(Infinity));
  assert.equal(false, typedArrayByteOffset(new Number(42)));
  assert.equal(false, typedArrayByteOffset('foo'));
  assert.equal(false, typedArrayByteOffset(Object('foo')));
  assert.equal(false, typedArrayByteOffset(function () {}));
  assert.equal(false, typedArrayByteOffset(function* () {}));
  assert.equal(false, typedArrayByteOffset(x => x * x));
  assert.equal(false, typedArrayByteOffset([]));

  const buffer = new ArrayBuffer(32);

  assert.equal(8, typedArrayByteOffset(new Int8Array(buffer, 8)));
  assert.equal(8, typedArrayByteOffset(new Uint8Array(buffer, 8)));
  assert.equal(8, typedArrayByteOffset(new Uint8ClampedArray(buffer, 8)));
  assert.equal(4, typedArrayByteOffset(new Int16Array(buffer, 4)));
  assert.equal(4, typedArrayByteOffset(new Uint16Array(buffer, 4)));
  assert.equal(8, typedArrayByteOffset(new Int32Array(buffer, 8)));
  assert.equal(8, typedArrayByteOffset(new Uint32Array(buffer, 8)));
  assert.equal(16, typedArrayByteOffset(new Float32Array(buffer, 16)));
  assert.equal(16, typedArrayByteOffset(new Float64Array(buffer, 16)));
  assert.equal(16, typedArrayByteOffset(new BigInt64Array(buffer, 16)));
  assert.equal(16, typedArrayByteOffset(new BigUint64Array(buffer, 16)));

  console.log('All tests passed');
}

runTests();
```

In this implementation, the condition checks if the input object is an instance of a Typed Array by using `instanceof` with the prototype of `Int8Array`, which helps in recognizing any Typed Array. The function then safely extracts and returns the `byteOffset`, or returns `false` if the object is not a Typed Array. The test script includes various assertions to validate the behavior with different input types.