The given Node.js code is a function named `jsesc` which aims to convert JavaScript values (strings, numbers, arrays, objects) into a string representation that is safer to use within JavaScript code environments. This functionality is typically needed to safely serialize data for use in JavaScript scripts or within JSON contexts, preserving the ability to deserialize back into the original form later.

Here's a breakdown of what this function does:
- **Options**: It allows various configurations through options. These include what kind of quotes to use, how numbers should be represented, and whether strings should be wrapped in quotes.
- **String Escaping**: It provides a mechanism for escaping characters in strings, especially non-ASCII characters and potentially dangerous control characters.
- **Wrap String**: It wraps strings in specified quotes unless the `wrap` option is false.
- **Stringify**: Depending on the data type (number, string, array, or object), it converts the data into a string form. Numbers can be formatted in various bases (binary, octal, hexadecimal). Arrays and objects are recursively processed and represented as JSON-like structures.

Here is a possible rewrite of the code with the same functionality:

```javascript
const jsesc = (value, options = {}) => {
    const defaultOptions = {
        quotes: 'single',
        numbers: 'decimal',
        wrap: false,
        es6: false,
        escapeEverything: false,
        minimal: false,
        isScriptContext: false,
        compact: true,
        indent: '\t',
        indentLevel: 0,
        json: false,
        lowercaseHex: false
    };
    
    options = { ...defaultOptions, ...options };

    const escapeChar = char => {
        const codePoint = char.codePointAt(0);
        let hexDigits = codePoint.toString(16);
        if (options.lowercaseHex) hexDigits = hexDigits.toLowerCase();
        if (options.es6 && codePoint > 0xFFFF) {
            return '\\u{' + hexDigits + '}';
        }
        return '\\u' + ('0000' + hexDigits).slice(-4);
    };

    const escapeString = string => {
        if (options.escapeEverything) {
            return string.split('').map(char => escapeChar(char)).join('');
        }
        return string.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\0-\x7F]/g, escapeChar);
    };

    const wrapString = string => {
        if (!options.wrap) return string;
        const quote = options.quotes === 'double' ? '"' : options.quotes === 'backtick' ? '`' : "'";
        return quote + string + quote;
    };

    const stringify = value => {
        if (typeof value === 'number') {
            switch (options.numbers) {
                case 'binary': return '0b' + value.toString(2);
                case 'octal': return '0o' + value.toString(8);
                case 'hexadecimal': return '0x' + value.toString(16);
                default: return value.toString();
            }
        }

        if (typeof value === 'string') {
            return wrapString(escapeString(value));
        }

        if (Array.isArray(value)) {
            const elements = value.map(v => stringify(v));
            return options.compact ? `[${elements.join(',')}]` : `[\n${options.indent}${elements.join(',\n' + options.indent)}\n]`;
        }

        if (value && typeof value === 'object') {
            const entries = Object.entries(value).map(([k, v]) => {
                return `${options.indent}${wrapString(escapeString(k))}:${stringify(v)}`;
            });
            return options.compact ? `{${entries.join(',')}}` : `{\n${entries.join(',\n')}\n}`;
        }

        return JSON.stringify(value);
    };

    return stringify(value);
};

module.exports = jsesc;
```