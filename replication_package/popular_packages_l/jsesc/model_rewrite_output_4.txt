The provided Node.js code defines a function called `jsesc`, which takes a `value` and an optional `options` object as arguments. The function is designed to escape JavaScript strings, numbers, arrays, and objects based on the provided options, allowing for customization of the output format. The main functionalities include:

1. **Default Configuration**: It defines default options for escaping, like whether to use single or double quotes, how to handle numbers (binary, octal, decimal, hexadecimal), wrapping strings in quotes, and more.

2. **Escape Characters**: The `escapeChar` function converts characters to their Unicode escape sequences, supporting both traditional and ES6 formats.

3. **Escape Strings**: The `escapeString` function applies the `escapeChar` logic to strings, allowing full string escaping or selectively escaping non-ASCII characters.

4. **Wrap Strings**: The `wrapString` function wraps strings with the specified type of quotes, if wrapping is enabled.

5. **Stringify Values**: The `stringify` function handles different value types: numbers have configuration options for various base formats, strings are escaped and possibly wrapped, arrays and objects are recursively serialized, and other types rely on JSON.stringify.

6. **Export**: The function is exported as a module, allowing it to be reused in other parts of a Node.js application.

Here's a possible rewrite of this code:

```javascript
const jsesc = (value, options = {}) => {
    const defaultOptions = {
        quotes: 'single',
        numbers: 'decimal',
        wrap: false,
        es6: false,
        escapeEverything: false,
        minimal: false,
        isScriptContext: false,
        compact: true,
        indent: '\t',
        indentLevel: 0,
        json: false,
        lowercaseHex: false
    };

    const mergedOptions = { ...defaultOptions, ...options };

    const escapeCharacter = (char) => {
        const codePoint = char.codePointAt(0);
        let hexString = codePoint.toString(16);
        if (mergedOptions.lowercaseHex) {
            hexString = hexString.toLowerCase();
        }

        if (mergedOptions.es6 && codePoint > 0xFFFF) {
            return `\\u{${hexString}}`;
        }
        return `\\u${'0000'.slice(hexString.length)}${hexString}`;
    };

    const escapeText = (text) => {
        if (mergedOptions.escapeEverything) {
            return text.split('').map(escapeCharacter).join('');
        }
        return text.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\0-\x7F]/g, escapeCharacter);
    };

    const wrapText = (text) => {
        if (!mergedOptions.wrap) return text;
        const openingQuote = mergedOptions.quotes === 'double' ? '"' : mergedOptions.quotes === 'backtick' ? '`' : "'";
        return `${openingQuote}${text}${openingQuote}`;
    };

    const processValue = (value) => {
        if (typeof value === 'number') {
            return {
                'binary': `0b${value.toString(2)}`,
                'octal': `0o${value.toString(8)}`,
                'hexadecimal': `0x${value.toString(16)}`
            }[mergedOptions.numbers] || value.toString();
        }

        if (typeof value === 'string') {
            return wrapText(escapeText(value));
        }

        if (Array.isArray(value)) {
            const elements = value.map(processValue);
            return mergedOptions.compact ? `[${elements.join(',')}]` : `[\n${mergedOptions.indent}${elements.join(`,\n${mergedOptions.indent}`)}\n]`;
        }

        if (value && typeof value === 'object') {
            const formattedEntries = Object.entries(value).map(([key, val]) => {
                return `${mergedOptions.indent}${wrapText(escapeText(key))}:${processValue(val)}`;
            });
            return mergedOptions.compact ? `{${formattedEntries.join(',')}}` : `{\n${formattedEntries.join(`,\n`)}\n}`;
        }

        return JSON.stringify(value);
    };

    return processValue(value);
};

module.exports = jsesc;
```