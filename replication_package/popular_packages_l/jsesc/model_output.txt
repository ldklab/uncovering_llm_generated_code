The jsesc package provides a way of converting data into a string format that is safe for use in JavaScript by escaping non-ASCII characters and other special characters. Unlike `JSON.stringify()`, jsesc outputs JavaScript-valid strings by default and supports more complex data types like ES6 maps and sets. It offers various customization options to control how the data is escaped and formatted.

Key functionalities include:
1. Escaping non-ASCII and special characters in strings using the shortest valid escape sequences.
2. Supporting customization through options such as quote type (`single`, `double`, `backtick`), number base (`decimal`, `binary`, `octal`, `hexadecimal`), and various formatting and wrapping options.
3. Ability to handle different data types including strings, arrays, objects, maps, sets, and buffers.
4. Optional json mode for ensuring output is valid JSON format.
5. Additional options to influence script context safety and result formatting (like `isScriptContext`, `compact`, `indent`).

Here's an implementation of a basic version of the jsesc package:

```js
const jsesc = (value, options = {}) => {
    const defaultOptions = {
        quotes: 'single',
        numbers: 'decimal',
        wrap: false,
        es6: false,
        escapeEverything: false,
        minimal: false,
        isScriptContext: false,
        compact: true,
        indent: '\t',
        indentLevel: 0,
        json: false,
        lowercaseHex: false
    };

    options = { ...defaultOptions, ...options };

    const escapeChar = (char) => {
        const codePoint = char.codePointAt(0);
        let hexDigits = codePoint.toString(16);
        if (options.lowercaseHex) {
            hexDigits = hexDigits.toLowerCase();
        }

        if (options.es6 && codePoint > 0xFFFF) {
            return '\\u{' + hexDigits + '}';
        }
        return '\\u' + ('0000' + hexDigits).slice(-4);
    };

    const escapeString = (string) => {
        if (options.escapeEverything) {
            return string.split('').map(char => escapeChar(char)).join('');
        }
        return string.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\0-\x7F]/g, escapeChar);
    };

    const wrapString = (string) => {
        if (!options.wrap) return string;
        const quote = options.quotes === 'double' ? '"' : options.quotes === 'backtick' ? '`' : "'";
        return quote + string + quote;
    };

    const stringify = (value) => {
        if (typeof value === 'number') {
            switch (options.numbers) {
                case 'binary': return '0b' + value.toString(2);
                case 'octal': return '0o' + value.toString(8);
                case 'hexadecimal': return '0x' + value.toString(16);
                default: return value.toString();
            }
        }

        if (typeof value === 'string') {
            return wrapString(escapeString(value));
        }

        if (Array.isArray(value)) {
            const elements = value.map(v => stringify(v));
            return options.compact ? '[' + elements.join(',') + ']' : '[\n' + options.indent + elements.join(',\n' + options.indent) + '\n]';
        }

        if (value && typeof value === 'object') {
            const entries = Object.entries(value).map(([k, v]) => {
                return options.indent + wrapString(escapeString(k)) + ':' + stringify(v);
            });
            return options.compact ? '{' + entries.join(',') + '}' : '{\n' + entries.join(',\n') + '\n}';
        }

        return JSON.stringify(value);
    };

    return stringify(value);
};

module.exports = jsesc;
```

This code snippet aims to implement several core features described in the README, such as handling strings, numbers, arrays, and objects, as well as handling some of the options for customization. Note that this is a simplified implementation and may not fully mirror all aspects of the original jsesc library.