The Node.js code provided is a module that exports three functionalities: `npa`, `resolve`, and `toPurl`. The module is designed to parse and resolve package arguments into a structured format, suitable for handling npm packages, including support for different types of package sources such as git, file, and directory.

1. **`npa(arg, where)`**: This function takes a package argument (`arg`) and an optional directory path (`where`). It parses the argument using the `parse` function, defaulting to the current working directory if `where` is not provided.

2. **`resolve(name, spec, where)`**: This function constructs a package string combining `name` and `spec`, and uses the `parse` function to resolve it. This function also defaults to the current working directory for the `where` parameter.

3. **`toPurl(arg, reg)`**: Converts a package argument into a Package URL (purl) format. It parses the argument using the `parse` function and expects `name` and `version` details.

4. **`parse(arg, where)`**: A core function that analyzes the package argument to determine its type (e.g., git, file, directory, version, range, tag). It extracts details such as `name`, `scope`, and `version` from the package argument.

5. **`escapeName(name)`**: A utility function that escapes special characters in package names, using URL encoding to replace `/` with `%2f`.

Here's a rewritten version of the code:

```javascript
'use strict';

module.exports = {
  npa,
  resolve,
  toPurl
};

const url = require('url');
const process = require('process');

function npa(arg, where) {
  validateArg(arg);
  return parse(arg, where || process.cwd());
}

function resolve(name, spec, where) {
  validateResolveInputs(name, spec);
  const arg = `${name}@${spec}`;
  return parse(arg, where || process.cwd());
}

function toPurl(arg, reg = 'https://registry.npmjs.org') {
  const parsed = parse(arg);
  if (!parsed.name || !parsed.version) throw new Error('Unable to resolve purl');
  
  return `pkg:npm/${parsed.name}@${parsed.version}`;
}

function parse(arg, where) {
  const result = initializeResultObject(arg);
  const patterns = definePatterns();

  if (patterns.git.test(arg)) {
    setGitFetchSpec(result, patterns.git, arg);
  } else if (patterns.file.test(arg)) {
    setFileFetchSpec(result, patterns.file, arg, where);
  } else if (patterns.dir.test(arg)) {
    setDirectoryFetchSpec(result, arg, where);
  } else {
    parseArgumentWithAtSymbol(result, arg);
  }

  result.escapedName = escapeName(result.name);
  return result;
}

function escapeName(name) {
  return name ? name.replace('/', '%2f') : null;
}

function validateArg(arg) {
  if (!arg) throw new Error('Invalid package argument');
}

function validateResolveInputs(name, spec) {
  if (!name || !spec) throw new Error('Invalid name or spec');
}

function initializeResultObject(arg) {
  return {
    raw: arg,
    type: null,
    registry: true,
    name: null,
    scope: null,
    rawSpec: null,
    saveSpec: null,
    fetchSpec: null,
    gitRange: null,
    gitCommittish: null,
    hosted: null
  };
}

function definePatterns() {
  return {
    git: /^git(\+.*):\/\/(.*)/,
    file: /(file:)?(.+\.(tar\.gz|tgz|tar))$/,
    dir: /^\.\.?\//
  };
}

function setGitFetchSpec(result, gitPattern, arg) {
  result.type = 'git';
  result.fetchSpec = arg.match(gitPattern)[0];
}

function setFileFetchSpec(result, filePattern, arg, where) {
  result.type = 'file';
  result.fetchSpec = `${where}/${arg.match(filePattern)[2]}`;
}

function setDirectoryFetchSpec(result, arg, where) {
  result.type = 'directory';
  result.fetchSpec = `${where}/${arg}`;
}

function parseArgumentWithAtSymbol(result, arg) {
  if (arg.includes('@')) {
    let [name, version] = arg.split('@');
    if (name.startsWith('@')) {
      [result.scope, name] = name.split('/');
      result.scope = `@${result.scope}`;
    }
    assignVersionType(result, name, version);
  } else {
    setResultToTagType(result, arg);
  }
}

function assignVersionType(result, name, version) {
  result.type = version ? 'version' : 'range';
  result.name = name;
  setVersionSpecs(result, version || 'latest');
}

function setResultToTagType(result, arg) {
  result.type = 'tag';
  result.name = arg;
  setVersionSpecs(result, 'latest');
}

function setVersionSpecs(result, version) {
  result.rawSpec = result.saveSpec = result.fetchSpec = version;
}
```