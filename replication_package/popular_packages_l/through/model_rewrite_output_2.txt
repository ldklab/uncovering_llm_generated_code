The provided Node.js code defines a function `through` that creates a custom stream object using Node.js's `Stream` module. This custom stream acts as a transform stream with enhanced methods for handling data flow and state management. Here's the breakdown of its functionality:

1. **Custom Write and End Functions**: 
   - The `through` function accepts `write` and `end` callback functions. These functions define how data is processed when it's written to the stream and how the stream should behave when it's ending, respectively. Defaults are provided if these functions are not specified.
  
2. **Stream Creation and Configuration**:
   - A new instance of `Stream` is created, which is both readable and writable. Additional properties like `paused` and `autoDestroy` are set to manage the stream's state and lifecycle.

3. **Writing and Queueing Data**:
   - The `stream.write` method uses the passed or default `write` function to process data. It returns the inverse of the `paused` state to indicate if the stream can continue receiving data.
   - The `stream.queue` method emits 'data' events or an 'end' event when null data is provided.

4. **Ending Stream**:
   - The `stream.end` method allows data to be written as the stream ends, utilizing the `end` function to finalize the stream.

5. **Pause/Resume Functionality**:
   - `stream.pause` and `stream.resume` control the flow of data by toggling the `paused` state and emitting corresponding events.

6. **Auto-Destroy Mechanism**:
   - If enabled (by default), the stream automatically transitions to a closed state after emission of the 'end' event by turning off its readable and writable properties, and then emitting a 'close' event.

The rewritten code below provides a similar implementation using modern JavaScript syntax and organizes the `through` function clearly:

```javascript
const { Stream } = require('stream');

function through(write, end, opts = {}) {
  write = write || function (data) { this.queue(data); };
  end = end || function () { this.queue(null); };

  const stream = new Stream();
  stream.readable = true;
  stream.writable = true;
  stream.paused = false;
  
  stream.write = function (data) {
    write.call(this, data);
    return !stream.paused;
  };

  stream.queue = function (data) {
    if (data === null) {
      stream.emit('end');
    } else {
      stream.emit('data', data);
    }
  };

  stream.end = function (data) {
    if (arguments.length) this.write(data);
    end.call(this);
    return this;
  };

  stream.pause = function () {
    if (!this.paused) {
      this.paused = true;
      this.emit('pause');
    }
  };

  stream.resume = function () {
    if (this.paused) {
      this.paused = false;
      this.emit('resume');
    }
  };

  stream.autoDestroy = opts.autoDestroy !== false;
  
  if (stream.autoDestroy) {
    stream.on('end', () => {
      process.nextTick(() => {
        if (stream.readable && stream.writable) {
          stream.readable = false;
          stream.writable = false;
          stream.emit('close');
        }
      });
    });
  }

  return stream;
}

module.exports = through;
```