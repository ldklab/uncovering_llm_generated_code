The provided Node.js script replicates a simplified version of the `nodemon` utility. It watches specified files for changes and automatically restarts the specified Node.js script when such changes are detected. Here's a breakdown of the script's functionality:

1. **Parsing Arguments**: The script expects a file to execute, along with optional flags for specifying what files to watch (`--watch`), which file extensions trigger a restart (`--ext`), paths to ignore (`--ignore`), and a delay time (`--delay`) before restarting after a change is detected.

2. **Watching Files**: Using the `chokidar` library, the script observes the specified files or directories. The user can provide custom directories to watch or use the current directory by default. File changes trigger a check on the file extension to decide if a restart is needed.

3. **Restarting**: When a relevant file change is detected, the running Node.js script is restarted. The script handles this by killing the existing process and spawning a new node process with the provided script.

4. **Handling Process Exit**: If the running node script exits with a signal other than `SIGUSR2`, which the script sends to itself when reloading, the whole script exits to avoid unwanted behavior.

Here's the restructured code based on the above explanation:

```javascript
#!/usr/bin/env node

const { spawn } = require('child_process');
const chokidar = require('chokidar');
const path = require('path');

class Nodemon {
  constructor(script, options = {}) {
    this.script = script;
    this.restartDelay = options.delay || 1000;
    this.watchExtensions = options.ext || 'js,mjs,json';
    this.ignorePaths = options.ignore || [];
    this.process = null;
    this.initialize();
  }

  initialize() {
    this.startScript();
    this.setupWatcher();
  }

  startScript() {
    if (this.process) {
      this.process.kill('SIGUSR2');
      console.log('[nodemon] restarting due to changes...');
    } else {
      console.log('[nodemon] starting `' + this.script + '`');
    }

    this.process = spawn('node', [this.script], { stdio: 'inherit' });
    this.process.on('exit', (code, signal) => {
      if (signal !== 'SIGUSR2') process.exit(code);
    });
  }

  setupWatcher() {
    const watcher = chokidar.watch(this.options.watch || '.', { ignored: this.ignorePaths });
    watcher.on('change', filePath => {
      if (this.shouldRestart(filePath)) {
        clearTimeout(this.restartTimeout);
        this.restartTimeout = setTimeout(() => this.startScript(), this.restartDelay);
      }
    });
  }

  shouldRestart(filePath) {
    return this.watchExtensions.split(',').includes(path.extname(filePath).slice(1));
  }
}

function parseArguments() {
  const [, , ...args] = process.argv;
  if (!args.length) {
    console.error('[nodemon] No script provided.');
    process.exit(1);
  }

  let [script, ...rest] = args;
  const options = rest.reduce((acc, val, idx, arr) => {
    if (val.startsWith('--')) acc[val.slice(2)] = arr[idx + 1] || true;
    return acc;
  }, {});

  if (options.delay) options.delay *= 1000;
  return { script, ...options };
}

function main() {
  const { script, watch, ext, ignore, delay } = parseArguments();
  new Nodemon(script, { watch, ext, ignore, delay });
}

main();
```

This revised version maintains the original script's intent, while implementing a slight restructuring for clarity, especially in the argument parsing and main execution flow.