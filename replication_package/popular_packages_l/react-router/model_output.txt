The functionality described in the Node.js package README.md is for `react-router`, which is a core library used in both `react-router-dom` and `react-router-native`. It provides the essential functionalities needed to handle routing in React applications. These functionalities are then re-exported by `react-router-dom`, which is designed for web applications, and `react-router-native`, which is tailored for mobile applications using React Native.

The README emphasizes that developers using React Router should not import directly from the `react-router` package. Instead, they should rely on `react-router-dom` or `react-router-native` because those packages provide everything needed for routing purposes in a web or native environment respectively.

For developers looking to extend React Router's functionality, they should include `react-router` as a peer dependency. This implies that the host environment should provide `react-router`, ensuring compatibility with the existing setup rather than including a potentially conflicting version of the core routing library inside the extending package.

Below is an example implementation of a simple Node.js package simulating `react-router` behavior. This is a basic structure and does not include the full routing capabilities or advanced features present in the actual `react-router` package.

```javascript
// package.json
{
  "name": "react-router-simulated",
  "version": "1.0.0",
  "description": "A simulated core routing functionality for React applications.",
  "main": "index.js",
  "peerDependencies": {
    "react": "^17.0.0 || ^18.0.0"
  },
  "dependencies": {},
  "scripts": {},
  "author": "Your Name",
  "license": "MIT"
}

// index.js
class Router {
  constructor(routes) {
    this.routes = routes;
    this.currentPath = window.location.pathname;
  }

  init() {
    window.onpopstate = () => {
      this.currentPath = window.location.pathname;
      this.render();
    };
    this.render();
  }

  navigate(path) {
    window.history.pushState({}, path, window.location.origin + path);
    this.currentPath = path;
    this.render();
  }

  render() {
    const route = this.routes.find(route => route.path === this.currentPath);
    const view = route ? route.view : this.routes.find(route => route.path === '*').view;
    document.getElementById('app').innerHTML = view();
  }
}

// Simulated routes example
const routes = [
  {
    path: '/',
    view: () => '<h1>Home</h1>',
  },
  {
    path: '/about',
    view: () => '<h1>About</h1>',
  },
  {
    path: '*',
    view: () => '<h1>404 Not Found</h1>',
  },
];

// Initialize and start the router
const router = new Router(routes);
router.init();

// Example navigation function that can be used in a simulated app
function navigateTo(path) {
  router.navigate(path);
}

// Example of usage
document.getElementById('to-about').addEventListener('click', () => navigateTo('/about'));
document.getElementById('to-home').addEventListener('click', () => navigateTo('/'));
```

This simulation is a simple approach to web-based routing using plain JavaScript. It handles route changes via the browser's history API and updates content based on recognized paths, mimicking some basic features of `react-router`.