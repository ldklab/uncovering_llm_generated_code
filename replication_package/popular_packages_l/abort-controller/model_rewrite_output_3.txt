The Node.js code is implementing a simple version of an `AbortController` which is used to abort ongoing processes in JavaScript by dispatching an 'abort' event. Hereâ€™s what each part does:

### Components:
1. **AbortSignal Class**: 
   - Manages the state of whether an action is aborted (`aborted` property) and maintains a list of event listeners (`_listeners` array).
   - Provides a method `addEventListener` to register functions that should be called when an 'abort' event is dispatched.
   - Provides a `dispatchEvent` method to call all registered listeners if the event type is 'abort'.

2. **AbortController Class**:
   - Contains an instance of `AbortSignal`.
   - Has a method `abort` that sets the `aborted` state of the signal to `true` and triggers all abort event listeners by calling `dispatchEvent`.

3. **Example Usage**:
   - An instance of `AbortController` is created.
   - An 'abort' event listener is added to its signal.
   - The `abort` method is called to trigger the "aborted!" log message.
  
Below is the potentially rewritten Node.js code:

```javascript
// abort-controller.js

class AbortSignal {
  constructor() {
    this.aborted = false;
    this._listeners = [];
  }

  addEventListener(event, listener) {
    if (event === 'abort') {
      this._listeners.push(listener);
    }
  }

  dispatchEvent(event) {
    if (event.type === 'abort') {
      this._listeners.forEach(listener => listener());
    }
  }
}

class AbortController {
  constructor() {
    this.signal = new AbortSignal();
  }

  abort() {
    if (!this.signal.aborted) {
      this.signal.aborted = true;
      this.signal.dispatchEvent({ type: 'abort' });
    }
  }
}

module.exports = AbortController;

// Example use
const AbortController = require('./abort-controller');

const controller = new AbortController();
const signal = controller.signal;

signal.addEventListener("abort", () => {
  console.log("aborted!");
});

controller.abort(); 
```