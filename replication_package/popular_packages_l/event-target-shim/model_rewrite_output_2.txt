The Node.js code provided implements a simplified event system similar to the standard EventTarget in the Web APIs but with a custom EventShim class. Here's a breakdown of its functionality:

1. **EventShim Class**: 
    - Acts as a constructor for event-like objects.
    - Accepts an event type and options (where `cancelable` is a key to determine if the event can be canceled).
    - Contains a method `preventDefault` that sets a flag `defaultPrevented` when the event is cancelable, and logs a warning if the event is passive and thus not cancelable.

2. **EventTargetShim Class**:
   - Manages event listeners and their invocation.
   - Stores listeners per event type in an object `listeners`.
   - Includes methods to add (`addEventListener`), remove (`removeEventListener`), and dispatch (`dispatchEvent`) events.
   - Supports listener options, such as whether an event is captured or listens for one time (`once`), and handles abort signals to remove listeners if needed.

Below is the rewritten code including these functionalities:

```javascript
// event-target-shim.js

class EventShim {
  constructor(type, options = {}) {
    this.type = type;
    this.cancelable = Boolean(options.cancelable);
    this.defaultPrevented = false;
  }
  
  preventDefault() {
    if (this.cancelable) {
      this.defaultPrevented = true;
    } else {
      console.warn('Ignored as event is passive.');
    }
  }
}

class EventTargetShim {
  constructor() {
    this.listeners = {};
  }
  
  addEventListener(type, listener, options = {}) {
    if (!this.listeners[type]) {
      this.listeners[type] = [];
    }

    const listenerOptions = typeof options === 'boolean' ? { capture: options } : options;

    if (listenerOptions.signal) {
      listenerOptions.signal.addEventListener('abort', () => {
        this.removeEventListener(type, listener);
      });
    }

    this.listeners[type].push({ listener, options: listenerOptions });
  }
  
  removeEventListener(type, listener) {
    if (!this.listeners[type]) return;
    this.listeners[type] = this.listeners[type].filter(
      obj => obj.listener !== listener
    );
  }
  
  dispatchEvent(event) {
    const listeners = this.listeners[event.type] || [];
    for (const { listener, options } of listeners) {
      if (options.once) {
        this.removeEventListener(event.type, listener);
      }
      listener.call(this, event);
    }
  }
}

module.exports = {
  EventShim,
  EventTargetShim,
};
```