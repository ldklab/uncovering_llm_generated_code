The Node.js code provided is a module that replicates the functionality of the Unix `which` command. This command searches the system's PATH to find the executable files that match a given name. Here is a detailed explanation of its functionality:

1. **isExecutable Function:** 
   - Takes a file path and a list of possible executable extensions (`pathExt`).
   - Returns `true` if the file exists, is a file (not a directory), and ends with one of the specified extensions.

2. **findExecutableInPath Function:** 
   - Searches through directories specified by the `PATH` environment variable for an executable file.
   - Respects optional parameters for defining a custom `PATH` (`options.path`) and executable extensions (`options.pathExt`).
   - Returns all matching paths if `options.all` is true; otherwise, it returns the first match or null if none is found.

3. **which Function (async):**
   - Wraps `findExecutableInPath` in a Promise to enable asynchronous behavior.
   - Resolves with the found executable path(s) or null, depending on options.
   - Rejects with an error if the executable is not found and `options.nothrow` is not set.

4. **which.sync Function:**
   - Synchronous version of the `which` function.
   - Throws an error if the executable is not found unless `options.nothrow` is true.

5. **Command Line Interface:**
   - Allows using this module directly from the command line, mimicking the `which` command with options `-a` (show all matches) and `-s` (silent mode, suppress errors).

```javascript
const fs = require('fs');
const path = require('path');

const isExecutable = (filePath, pathExt) => {
  const exts = pathExt.split(';');
  return exts.some(ext => filePath.endsWith(ext)) && fs.existsSync(filePath) && fs.statSync(filePath).isFile();
};

const findExecutableInPath = (executable, options = {}) => {
  const paths = (options.path || process.env.PATH || '').split(path.delimiter);
  const pathExt = options.pathExt || process.env.PATHEXT || (process.platform === 'win32' ? '.EXE;.CMD;.BAT;.COM' : '');
  
  const matches = [];

  for (const dir of paths) {
    const fullPath = path.join(dir, executable);
    if (isExecutable(fullPath, pathExt)) {
      if (options.all) {
        matches.push(fullPath);
      } else {
        return fullPath;
      }
    }
  }

  return options.all ? matches : null;
};

const which = async (executable, options = {}) => {
  return new Promise((resolve, reject) => {
    const result = findExecutableInPath(executable, options);
    if (result || options.nothrow) {
      resolve(result);
    } else {
      reject(new Error(`not found: ${executable}`));
    }
  });
};

which.sync = (executable, options = {}) => {
  const result = findExecutableInPath(executable, options);
  if (!result && !options.nothrow) {
    throw new Error(`not found: ${executable}`);
  }
  return result;
};

module.exports = which;

// CLI Usage
if (require.main === module) {
  const args = process.argv.slice(2);
  const options = {
    all: args.includes('-a'),
    nothrow: args.includes('-s')
  };

  const programs = args.filter(arg => !arg.startsWith('-'));
  if (programs.length === 0) {
    console.error('usage: node-which [-as] program ...');
    process.exit(1);
  }

  programs.forEach(program => {
    try {
      const result = which.sync(program, options);
      if (Array.isArray(result)) {
        result.forEach(res => console.log(res));
      } else if (result) {
        console.log(result);
      }
    } catch (err) {
      if (!options.nothrow) {
        console.error(err.message);
        process.exit(1);
      }
    }
  });
}
```