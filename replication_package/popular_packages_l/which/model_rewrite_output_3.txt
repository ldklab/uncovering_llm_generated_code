The Node.js code provided is an implementation of a tool similar to the UNIX `which` command. It searches for an executable file in the directories listed in the system's `PATH` environment variable. Here's a breakdown of its functionalities:

1. **isExecutable Function**: Checks if a given file at `filePath` is an executable based on the file's extension and if the file exists and is a normal file.

2. **findExecutableInPath Function**: Searches through the directories specified in the `PATH` environment variable (or a custom `path` provided in the options) to find the specified executable. It looks for the executable with the correct extension (defined in `PATHEXT` on Windows or defaults). It returns the first match unless the `all` option is set, in which case it returns an array of all matches.

3. **which Function**: An asynchronous function that wraps `findExecutableInPath` in a Promise, resolving with the executable path or array of paths, or rejecting if no executable is found (unless `nothrow` is specified).

4. **which.sync Function**: A synchronous version of the `which` function that throws an error if the executable isn't found unless `nothrow` option is enabled.

5. **CLI Interface**: If the script is run from the command line, it processes arguments to determine which executables to search for and whether to use the `all` or `nothrow` options, printing results to the console or throwing errors if necessary.

```javascript
const fs = require('fs');
const path = require('path');

const isExecutable = (filePath, pathExt) => {
  const exts = pathExt.split(';');
  return exts.some(ext => filePath.endsWith(ext)) && fs.existsSync(filePath) && fs.statSync(filePath).isFile();
};

const findExecutableInPath = (executable, options = {}) => {
  const paths = (options.path || process.env.PATH || '').split(path.delimiter);
  const pathExt = options.pathExt || process.env.PATHEXT || (process.platform === 'win32' ? '.EXE;.CMD;.BAT;.COM' : '');
  
  const matches = [];

  for (const dir of paths) {
    const fullPath = path.join(dir, executable);
    if (isExecutable(fullPath, pathExt)) {
      if (options.all) {
        matches.push(fullPath);
      } else {
        return fullPath;
      }
    }
  }

  return options.all ? matches : null;
};

const which = async (executable, options = {}) => {
  return new Promise((resolve, reject) => {
    const result = findExecutableInPath(executable, options);
    if (result || options.nothrow) {
      resolve(result);
    } else {
      reject(new Error(`not found: ${executable}`));
    }
  });
};

which.sync = (executable, options = {}) => {
  const result = findExecutableInPath(executable, options);
  if (!result && !options.nothrow) {
    throw new Error(`not found: ${executable}`);
  }
  return result;
};

module.exports = which;

// CLI Usage
if (require.main === module) {
  const args = process.argv.slice(2);
  const options = {
    all: args.includes('-a'),
    nothrow: args.includes('-s')
  };

  const programs = args.filter(arg => !arg.startsWith('-'));
  if (programs.length === 0) {
    console.error('usage: node-which [-as] program ...');
    process.exit(1);
  }

  programs.forEach(program => {
    try {
      const result = which.sync(program, options);
      if (Array.isArray(result)) {
        result.forEach(res => console.log(res));
      } else if (result) {
        console.log(result);
      }
    } catch (err) {
      if (!options.nothrow) {
        console.error(err.message);
        process.exit(1);
      }
    }
  });
}
```