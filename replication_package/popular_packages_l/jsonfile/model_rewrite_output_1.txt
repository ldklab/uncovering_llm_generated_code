The provided Node.js code defines a module that facilitates reading and writing JSON files. It includes both synchronous and asynchronous versions of these functionalities, structured as follows:

1. **Asynchronous JSON Reading (`readFile`)**:
   - Reads a file asynchronously using `fs.readFile`.
   - Parses the file content as JSON.
   - Supports options to customize behavior, including `throws` to control error throwing and a `reviver` function for `JSON.parse`.

2. **Promise-based Asynchronous JSON Reading (`readFile.promises`)**:
   - Promisified version of `readFile`, returning a promise rather than using a callback.

3. **Synchronous JSON Reading (`readFileSync`)**:
   - Equivalent of `readFile` but operates synchronously via `fs.readFileSync`.
   - Similarly offers options for JSON parsing.

4. **Asynchronous JSON Writing (`writeFile`)**:
   - Serializes a JavaScript object into a JSON string.
   - Writes the string to a specified file path using `fs.writeFile`.
   - Supports options for JSON stringification, such as `replacer` and `spaces`, as well as appending a final EOL character.

5. **Promise-based Asynchronous JSON Writing (`writeFile.promises`)**:
   - Promisified version of `writeFile`.

6. **Synchronous JSON Writing (`writeFileSync`)**:
   - Synchronous counterpart using `fs.writeFileSync`.

7. **Module Exports**:
   - Exports all defined functions and their promise-based versions as properties.

Here's a possible rewrite of the code:

```javascript
// jsonfile.js

const fs = require('fs');
const path = require('path');

function readFile(filePath, options = {}, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  const { throws = true, reviver, ...fsOptions } = options;

  fs.readFile(filePath, fsOptions, (err, data) => {
    if (err) return callback(err);
    try {
      const parsedData = JSON.parse(data, reviver);
      callback(null, parsedData);
    } catch (parseErr) {
      return throws ? callback(parseErr) : callback(null, null);
    }
  });
}

function readFileSync(filePath, options = {}) {
  const { throws = true, reviver, ...fsOptions } = options;
  try {
    const data = fs.readFileSync(filePath, fsOptions);
    return JSON.parse(data, reviver);
  } catch (err) {
    if (throws) throw err;
    return null;
  }
}

function writeFile(filePath, obj, options = {}, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  const { replacer, spaces, EOL = '\n', finalEOL = true, ...fsOptions } = options;
  
  let jsonData = JSON.stringify(obj, replacer, spaces);
  if (finalEOL) jsonData += EOL;

  fs.writeFile(filePath, jsonData, fsOptions, callback);
}

function writeFileSync(filePath, obj, options = {}) {
  const { replacer, spaces, EOL = '\n', finalEOL = true, ...fsOptions } = options;
  
  let jsonData = JSON.stringify(obj, replacer, spaces);
  if (finalEOL) jsonData += EOL;

  fs.writeFileSync(filePath, jsonData, fsOptions);
}

readFile.promises = function (filePath, options) {
  return new Promise((resolve, reject) => {
    readFile(filePath, options, (err, obj) => {
      if (err) return reject(err);
      resolve(obj);
    });
  });
};

writeFile.promises = function (filePath, obj, options) {
  return new Promise((resolve, reject) => {
    writeFile(filePath, obj, options, (err) => {
      if (err) return reject(err);
      resolve();
    });
  });
};

module.exports = {
  readFile,
  readFileSync,
  writeFile,
  writeFileSync,
  readFilePromise: readFile.promises,
  writeFilePromise: writeFile.promises,
};
```