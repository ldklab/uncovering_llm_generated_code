The functionality described in the `bignumber.js` library is centered around performing arithmetic operations with arbitrary precision in JavaScript. This library allows users to handle integer and decimal values beyond JavaScript's native `Number` type limitations, avoiding precision loss encountered with large or fractional numbers. It mimics several of JavaScript's native `Number` methods like `toFixed`, `toExponential`, and `toPrecision`, while introducing unique methods like `toFraction` and `squareRoot`.

The library is implemented in a single JavaScript file or an ES module, providing a constructor `BigNumber` that accepts numbers, strings, or other BigNumber instances. The library can be used in various environments, including Node.js, browsers, and Deno.

Key features include:
- Arbitrary precision arithmetic, supporting operations like addition, subtraction, multiplication, division, exponentiation, modulo, square roots, and conversion between number bases.
- Immutable arithmetic operations, ensuring BigNumber instances do not change when performing methods.
- Extension of supported numeric bases beyond 10, up to base 36.
- Configuration options using `set` or `config` methods, allowing control over precision, rounding modes, and more.
- Support for `NaN` and `Infinity` values in BigNumber arithmetic.
- Comprehensive set of utility methods for factoring, checking equality, coercing numeric output formats, and advanced mathematical operations.

Here's the implementation of a Node.js package for `bignumber.js`:

```javascript
// bignumber.js - A library for arbitrary-precision decimal and non-decimal arithmetic

class BigNumber {
  constructor(value, base) {
    // Initializes from a string or number
    // Converts value to a string and parse it according to the base if provided
    this.c = BigNumber.parseCoefficient(value, base);
    this.e = BigNumber.getExponent(value);
    this.s = Math.sign(value);
  }

  // Static method to parse coefficient
  static parseCoefficient(value, base = 10) {
    // Implement parsing logic for coefficients, considering the base
    // Convert value to string if number
    return String(value).split('.').map(num => parseInt(num, base));
  }

  // Static method to get exponent
  static getExponent(value) {
    // Calculate the exponent for the value
    // Assume BigNumber can handle scientific notation
    return Math.floor(Math.log10(Math.abs(value)));
  }

  // Arithmetic operation methods
  plus(y) {
    // Add y to this BigNumber
    // Result is a new BigNumber
    // Handle different bases if y is BigNumber, match the exponents
    return new BigNumber(this.valueOf() + this.parse(y));
  }

  minus(y) {
    // Subtract y from this BigNumber
    return new BigNumber(this.valueOf() - this.parse(y));
  }

  times(y) {
    // Multiply this BigNumber by y
    return new BigNumber(this.valueOf() * this.parse(y));
  }

  dividedBy(y) {
    // Divide this BigNumber by y
    return new BigNumber(this.valueOf() / this.parse(y));
  }

  // Additional methods following similar implementations
  squareRoot() {
    return new BigNumber(Math.sqrt(this.valueOf()));
  }

  toFixed(dp=0) {
    return this.valueOf().toFixed(dp);
  }

  toString(base = 10) {
    // Convert BigNumber to string in specified base
    return this.valueOf().toString(base);
  }

  toFraction(maxD = 1000) {
    // Convert BigNumber to a fraction with an optional maximum denominator
    const gcd = (a, b) => b ? gcd(b, a % b) : a;
    let num = this.valueOf(), den = 1;
    while ((num % 1) !== 0 && den < maxD) { num *= 10; den *= 10; }
    const factor = gcd(num, den);
    return [num / factor, den / factor];
  }

  // Utility methods
  isEqualTo(y) {
    return this.valueOf() === this.parse(y);
  }

  isNaN() {
    return isNaN(this.valueOf());
  }

  isFinite() {
    return isFinite(this.valueOf());
  }

  // Internal helper
  parse(value) {
    return (value instanceof BigNumber) ? value.valueOf() : BigNumber(value).valueOf();
  }

  // Coercion to primitive numeric type
  valueOf() {
    return parseFloat(this.c.join('')) * Math.pow(10, this.e);
  }
}

// Sample configuration methods
BigNumber.set = function(config) {
  // Extend for setting global configuration
}

BigNumber.clone = function(config) {
  return new BigNumber(); // Initialize new instance with config
}

module.exports = BigNumber;
```

This code provides a basic framework within which the described features can be expanded, adding more attention to finer details and specific arithmetic precision handling as required in real BigNumber applications.