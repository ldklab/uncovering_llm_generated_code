The Node.js code provided defines a basic URL parsing, formatting, and resolution utility. Here's a breakdown of its functionality:

1. **parse(urlStr, parseQueryString = false, slashesDenoteHost = false):** This function uses a regular expression to extract components from a URL string, such as protocol, hostname, port, path, query, and hash. It has options to parse the query string into an object and to treat slashes at the beginning of the URL as indicative of a host. This function returns an object representing the parsed URL components.

2. **format(urlObj):** This function converts a URL object back into a URL string. It considers protocol, authentication, host, path, query, and hash to construct the URL. It constructs the URL by joining these components appropriately, respecting whether the protocol requires slashes.

3. **resolve(from, to):** This function resolves a relative URL (to) against a base URL (from). It first parses both URLs and then constructs the resolved URL by considering whether the target has its protocol. If not, it resolves the pathname and appends query and hash if available.

4. **resolvePath(path):** This helper function takes a URL path and resolves any '.' or '..' to return a normalized path, eliminating redundancies.

The module exports all three main functions: `parse`, `format`, and `resolve`.

Here is the rewritten code:

```javascript
const querystring = require('querystring');

function parse(urlStr, parseQueryString = false, slashesDenoteHost = false) {
    const urlPattern = /^(https?:|ftp:|file:|gopher:)?(\/\/)?((([^:@]*):?([^:@]*))?@)?([^:\/?#]+)?(:([0-9]+))?(\/[^?#]*)?(\?([^#]*))?(#(.*))?$/;
    const match = urlStr.match(urlPattern);

    if (!match) return {};

    const [
        href,
        protocol = '',
        slashes,
        ,
        authUser = '',
        authPass = '',
        host = '',
        ,
        port = '',
        pathname = '',
        search = '',
        queryStr = '',
        hash = ''
    ] = match;

    const auth = authUser || authPass ? `${authUser}:${authPass}` : null;
    const hostname = host.toLowerCase();
    const parsedQuery = parseQueryString ? querystring.parse(queryStr) : queryStr;

    const result = {
        href,
        protocol: protocol.toLowerCase(),
        slashes: !!slashes,
        host: hostname ? `${hostname}:${port}`.trimEnd(':') : null,
        auth,
        hostname,
        port,
        pathname,
        search,
        path: `${pathname}${search}`,
        query: parsedQuery,
        hash
    };

    if (slashesDenoteHost && result.slashes && !result.host) {
        const [fakedHost, ...pathParts] = pathname.split('/');
        result.host = fakedHost;
        result.pathname = `/${pathParts.join('/')}`;
    }

    return result;
}

function format(urlObj) {
    const protocol = urlObj.protocol ? urlObj.protocol + (urlObj.protocol.endsWith(':') ? '' : ':') : '';
    const auth = urlObj.auth ? `${urlObj.auth}@` : '';
    const host = urlObj.host || ((urlObj.hostname || '') + (urlObj.port ? ':' + urlObj.port : ''));
    const pathname = urlObj.pathname ? '/' + urlObj.pathname.replace(/^\//, '') : '';
    const search = urlObj.search ? ('?' + urlObj.search.replace(/^\?/, '')) : (urlObj.query ? ('?' + querystring.stringify(urlObj.query)) : '');
    const hash = urlObj.hash ? ('#' + urlObj.hash.replace(/^#/, '')) : '';
  
    if (['http', 'https', 'ftp', 'gopher', 'file'].includes(protocol)) {
        return `${protocol}//${auth}${host}${pathname}${search}${hash}`;
    }

    return `${protocol}${auth}${host}${pathname}${search}${hash}`;
}

function resolve(from, to) {
    const fromParsed = parse(from);
    const toParsed = parse(to);
  
    if (toParsed.protocol) {
        return to;
    }

    let base = fromParsed.href.split(/[?#]/)[0];
    if (toParsed.pathname.startsWith('/')) {
        base = `${fromParsed.protocol}//${fromParsed.host}`;
    } else {
        base = base.substring(0, base.lastIndexOf('/') + 1);
    }

    const resolvedPath = resolvePath(base + toParsed.pathname);
    return format({
        ...fromParsed,
        pathname: resolvedPath,
        query: toParsed.query,
        hash: toParsed.hash
    });
}

function resolvePath(path) {
    const segments = path.split('/');
    const resolved = [];
    for (const segment of segments) {
        if (segment === '.' || segment === '') continue;
        if (segment === '..') resolved.pop();
        else resolved.push(segment);
    }
    return '/' + resolved.join('/');
}

module.exports = {
    parse,
    format,
    resolve
};
```