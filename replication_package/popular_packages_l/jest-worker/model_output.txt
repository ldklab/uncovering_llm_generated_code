The `jest-worker` package provides functionality for executing heavy tasks in parallel using separate Node.js processes. The key features of this package include:

1. **Creating Workers**: You can create worker processes by specifying the path to a worker module. This module has methods that can be called asynchronously from the main process.

2. **Promise-based Interface**: Methods exposed from the worker modules can be called from the main process and return promises, allowing for asynchronous execution with `await`.

3. **Bound Workers**: You can bind tasks to specific worker instances using a `computeWorkerKey` function. If a task has been executed before, subsequent tasks with the same key will be directed to the same worker. This is particularly useful for caching or when tasks have state that should persist between calls.

4. **Worker Threads Option**: Besides the default `child_process` method for creating workers, there is an option to use `worker_threads` for potentially more efficient inter-process communication.

5. **Customization**: You can customize the number of workers, the methods exposed by the worker, as well as set various options like handling stdout/stderr, task queueing, and memory limits for workers.

6. **API**: The worker instance offers methods for controlling worker processes, such as `getStdout`, `getStderr`, `start`, and `end`.

Let's implement a basic version of this functionality:

```js
// parent.js
const { Worker, isMainThread, workerData, parentPort } = require('worker_threads');
const path = require('path');

class JestWorker {
  constructor(workerPath, options = {}) {
    this.workerPath = workerPath;
    this.workers = [];
    this.options = options;
    this.methodNames = options.exposedMethods || this.getExposedMethods();
    this.numWorkers = options.numWorkers || require('os').cpus().length - 1;
    this.setupWorkers();
  }

  // Initializes workers
  setupWorkers() {
    for (let i = 0; i < this.numWorkers; i++) {
      const worker = new Worker(this.workerPath, { workerData: { options: this.options } });
      this.workers.push(worker);
    }
  }

  // Obtain method names by reflection if not provided
  getExposedMethods() {
    const workerModule = require(this.workerPath);
    return Object.keys(workerModule).filter(name => typeof workerModule[name] === 'function');
  }

  // Executes a method on a worker
  exec(method, ...args) {
    return new Promise((resolve, reject) => {
      const worker = this.chooseWorker(method, args);
      worker.once('message', resolve);
      worker.once('error', reject);
      worker.postMessage({ method, args });
    });
  }

  // Choose a worker based on round-robin or bound keys
  chooseWorker(method, args) {
    if (this.options.computeWorkerKey) {
      const key = this.options.computeWorkerKey(method, ...args);
      // Use a simple hash to index worker by key
      const workerIndex = key ? (key.hashCode() % this.workers.length) : Math.floor(Math.random() * this.workers.length);
      return this.workers[workerIndex];
    }
    return this.workers[Math.floor(Math.random() * this.workers.length)];
  }

  // Terminates all workers
  end() {
    return Promise.all(this.workers.map(worker => worker.terminate()));
  }
}

// Extending String prototype to create a simple hash function
String.prototype.hashCode = function() {
  let hash = 0;
  for (let i = 0; i < this.length; i++) {
    const char = this.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash |= 0; // Convert to 32bit integer
  }
  return hash;
};

// Example in parent.js using JestWorker
async function main() {
  const workerPath = path.resolve(__dirname, 'worker.js');
  
  const myWorker = new JestWorker(workerPath, {
    exposedMethods: ['foo', 'bar'],
    computeWorkerKey: (method, filename) => filename // Example of a key function
  });

  console.log(await myWorker.exec('foo', 'Alice'));
  console.log(await myWorker.exec('bar', 'Bob'));

  await myWorker.end();
}

if (isMainThread) {
  main();
}

// worker.js
if (!isMainThread) {
  parentPort.on('message', async (task) => {
    const { method, args } = task;
    try {
      const result = workerMethods[method](...args);
      const output = (result instanceof Promise) ? await result : result;
      parentPort.postMessage(output);
    } catch (error) {
      parentPort.postMessage({ error: error.message });
    }
  });

  const workerMethods = {
    foo: (param) => `Hello from foo: ${param}`,
    bar: (param) => `Hello from bar: ${param}`
  };
}
```

The above implementation demonstrates basic JestWorker functionality using `worker_threads`. We dynamically create worker threads, send tasks with specific methods and arguments, execute them in the worker, and retrieve the results asynchronously. The string hashing function is utilized for worker binding based on computed keys.