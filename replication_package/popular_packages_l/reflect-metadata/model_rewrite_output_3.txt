The Node.js code provided implements metadata handling functionalities similar to the Reflect Metadata API using a custom `MetadataMap` class and `WeakMap`. The implementation focuses on attaching metadata to JavaScript objects and their properties, with the ability to store, retrieve, check, and delete metadata.

### Explanation of Functionality:
1. **MetadataMap Class**: A custom map class designed to store metadata as key-value pairs associated with a particular property of an object.
   - **set(property, metaKey, metaValue)**: Stores a metadata key-value pair under the specified property.
   - **get(property, metaKey)**: Retrieves the metadata value for a given property and key.
   - **has(property, metaKey)**: Checks if a particular key exists for a given property.
   - **keys(property)**: Returns all metadata keys associated with a given property.
   - **delete(property, metaKey)**: Removes the metadata entry for a given property and key.

2. **Metadata Storage**: Uses a `WeakMap` to associate an instance of `MetadataMap` with each target object for metadata storage.

3. **Reflect-like Metadata Operations**: Mimics the Reflect Metadata API methods.
   - **defineMetadata(metadataKey, metadataValue, target, propertyKey)**: Defines metadata on a target object or its property.
   - **hasMetadata(metadataKey, target, propertyKey)**: Recursively checks if metadata exists on a target or its prototype chain.
   - **hasOwnMetadata(metadataKey, target, propertyKey)**: Checks if metadata exists directly on a target.
   - **getMetadata(metadataKey, target, propertyKey)**: Recursively retrieves metadata from a target or its prototype chain.
   - **getOwnMetadata(metadataKey, target, propertyKey)**: Retrieves metadata directly from a target.
   - **getMetadataKeys(target, propertyKey)**: Retrieves metadata keys from a target and its prototype chain.
   - **getOwnMetadataKeys(target, propertyKey)**: Retrieves metadata keys directly from a target.
   - **deleteMetadata(metadataKey, target, propertyKey)**: Removes metadata from a target or its property.

4. **Polyfill for Reflect**: Ensures the custom Reflect object is globally available if the native Reflect object is absent.

### Rewritten Code:

```javascript
class MetadataMap {
  constructor() {
    this.map = new Map();
  }
  
  set(property, metaKey, metaValue) {
    if (!this.map.has(property)) {
      this.map.set(property, new Map());
    }
    this.map.get(property).set(metaKey, metaValue);
  }

  get(property, metaKey) {
    return this.map.has(property) ? this.map.get(property).get(metaKey) : undefined;
  }

  has(property, metaKey) {
    return this.map.has(property) && this.map.get(property).has(metaKey);
  }
  
  keys(property) {
    return this.map.has(property) ? Array.from(this.map.get(property).keys()) : [];
  }

  delete(property, metaKey) {
    if (this.map.has(property)) {
      return this.map.get(property).delete(metaKey);
    }
    return false;
  }
}

const metadataStore = new WeakMap();

function ensureMetadataMap(target) {
  if (!metadataStore.has(target)) {
    metadataStore.set(target, new MetadataMap());
  }
}

const Reflect = globalThis.Reflect || {}; 

Reflect.defineMetadata = function (metadataKey, metadataValue, target, propertyKey) {
  ensureMetadataMap(target);
  metadataStore.get(target).set(propertyKey || 'default', metadataKey, metadataValue);
};

Reflect.hasMetadata = function (metadataKey, target, propertyKey) {
  while (target !== null) {
    if (Reflect.hasOwnMetadata(metadataKey, target, propertyKey)) {
      return true;
    }
    target = Object.getPrototypeOf(target);
  }
  return false;
};

Reflect.hasOwnMetadata = function (metadataKey, target, propertyKey) {
  ensureMetadataMap(target);
  return metadataStore.get(target).has(propertyKey || 'default', metadataKey);
};

Reflect.getMetadata = function (metadataKey, target, propertyKey) {
  while (target !== null) {
    const result = Reflect.getOwnMetadata(metadataKey, target, propertyKey);
    if (result !== undefined) {
      return result;
    }
    target = Object.getPrototypeOf(target);
  }
  return undefined;
};

Reflect.getOwnMetadata = function (metadataKey, target, propertyKey) {
  ensureMetadataMap(target);
  return metadataStore.get(target).get(propertyKey || 'default', metadataKey);
};

Reflect.getMetadataKeys = function (target, propertyKey) {
  const keys = new Set();
  while (target !== null) {
    Reflect.getOwnMetadataKeys(target, propertyKey).forEach(key => keys.add(key));
    target = Object.getPrototypeOf(target);
  }
  return [...keys];
};

Reflect.getOwnMetadataKeys = function (target, propertyKey) {
  ensureMetadataMap(target);
  return metadataStore.get(target).keys(propertyKey || 'default');
};

Reflect.deleteMetadata = function (metadataKey, target, propertyKey) {
  ensureMetadataMap(target);
  return metadataStore.get(target).delete(propertyKey || 'default', metadataKey);
};

if (!globalThis.Reflect) {
  globalThis.Reflect = Reflect;
}

export default Reflect;
```