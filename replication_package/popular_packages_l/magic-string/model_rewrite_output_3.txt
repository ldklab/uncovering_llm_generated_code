The Node.js code defines a class `MagicString` which allows for manipulation of strings by updating, appending, or prepending content. It maintains an internal record of changes made to the string. 

The `MagicString` class supports:
- Updating a portion of the string using the `update` method, which replaces the content between specified start and end indices.
- Adding content to the end of the string using the `append` method.
- Adding content to the beginning of the string with the `prepend` method.
- Creating a source map with the `generateMap` method that optionally includes the original content.
- Retrieving its current modified version as a string with the `toString` method.
- Cloning itself with the `clone` method.

Additionally, there is a nested `MagicString.Bundle` class. This class supports:
- Managing a collection of `MagicString` instances.
- Indenting each added source string.
- Combining and retrieving the strings from all sources.
- Generating a source map similar to the standalone `MagicString` class.

Below is a proposed rewrite of the `MagicString` code:

```javascript
// MagicString.js

class MagicString {
  constructor(originalString, options = {}) {
    this.originalString = originalString;
    this.modifiedString = originalString;
    this.changes = [];
    this.options = options;
  }

  update(start, end, content) {
    this.modifiedString =
      this.modifiedString.slice(0, start) +
      content +
      this.modifiedString.slice(end);
    this.changes.push({ type: 'update', start, end, content });
    return this;
  }

  append(content) {
    this.modifiedString += content;
    this.changes.push({ type: 'append', content });
    return this;
  }

  prepend(content) {
    this.modifiedString = content + this.modifiedString;
    this.changes.push({ type: 'prepend', content });
    return this;
  }

  generateMap(options = {}) {
    const map = {
      version: 3,
      file: options.file || 'output.js',
      sources: [options.source || 'input.js'],
      names: [],
      mappings: 'AAAA'
    };

    if (options.includeContent) {
      map.sourcesContent = [this.originalString];
    }

    return {
      ...map,
      toString: () => JSON.stringify(map),
      toUrl: () => `data:application/json;charset=utf-8;base64,${Buffer.from(JSON.stringify(map)).toString('base64')}`
    };
  }

  toString() {
    return this.modifiedString;
  }

  clone() {
    return new MagicString(this.originalString, this.options);
  }
}

// MagicString.Bundle

MagicString.Bundle = class {
  constructor() {
    this.sources = [];
    this.indentString = '  ';
  }

  addSource(source) {
    this.sources.push(source);
    return this;
  }

  indent(indentStr) {
    if (indentStr) {
      this.indentString = indentStr;
    }
    this.sources = this.sources.map(
      source => new MagicString(source.modifiedString.replace(/^/gm, this.indentString))
    );
    return this;
  }

  toString() {
    return this.sources.map(source => source.toString()).join('\n');
  }

  generateMap(options = {}) {
    const map = {
      version: 3,
      file: options.file || 'bundle.js',
      sources: this.sources.map(source => source.options.filename || 'unknown'),
      mappings: '',
    };

    if (options.includeContent) {
      map.sourcesContent = this.sources.map(source => source.originalString);
    }

    return {
      ...map,
      toString: () => JSON.stringify(map),
      toUrl: () => `data:application/json;charset=utf-8;base64,${Buffer.from(JSON.stringify(map)).toString('base64')}`
    };
  }
};

export default MagicString;
```