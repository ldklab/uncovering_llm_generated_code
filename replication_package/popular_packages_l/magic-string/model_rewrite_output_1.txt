The provided Node.js code defines a utility class `MagicString` and its nested `Bundle` class. These classes are designed to help with creating and managing modifications on strings, particularly useful for source code transformations. Here's an overview of the functionality:

- `MagicString`:
  - **Constructor**: Initializes with an original string and optional settings, tracking any modifications made.
  - **update(start, end, content)**: Replaces part of the string from `start` to `end` with `content`, and logs the change.
  - **append(content)**: Adds `content` to the end of the string, logging this action.
  - **prepend(content)**: Adds `content` at the beginning of the string, logging this action.
  - **generateMap(options)**: Produces a source map object that can include original content and represents modified code positioning.
  - **toString()**: Returns the current state of the modified string.
  - **clone()**: Creates a duplicate of the current `MagicString` instance with the original string and options.

- `MagicString.Bundle`:
  - **Constructor**: Sets up a collection of `MagicString` objects for handling multiple sources and applies consistent indentation.
  - **addSource(source)**: Adds a `MagicString` object to the bundle.
  - **indent(indentStr)**: Applies or changes the indentation to each line of all sources.
  - **toString()**: Concatenates all modified strings from sources into a single output.
  - **generateMap(options)**: Creates a source map for the bundle, incorporating sources and optionally their contents.

Here's a possible rewritten version of the code:

```javascript
class MagicString {
  constructor(originalString, options = {}) {
    this.originalString = originalString;
    this.modifiedString = originalString;
    this.changes = [];
    this.options = options;
  }

  update(start, end, content) {
    this.modifiedString = this.modifiedString.slice(0, start) + content + this.modifiedString.slice(end);
    this.changes.push({ type: 'update', start, end, content });
    return this;
  }

  append(content) {
    this.modifiedString += content;
    this.changes.push({ type: 'append', content });
    return this;
  }

  prepend(content) {
    this.modifiedString = content + this.modifiedString;
    this.changes.push({ type: 'prepend', content });
    return this;
  }

  generateMap(options = {}) {
    const map = {
      version: 3,
      file: options.file || 'output.js',
      sources: [options.source || 'input.js'],
      names: [],
      mappings: 'AAAA'
    };

    if (options.includeContent) {
      map.sourcesContent = [this.originalString];
    }

    return {
      ...map,
      toString: () => JSON.stringify(map),
      toUrl: () => `data:application/json;charset=utf-8;base64,${btoa(JSON.stringify(map))}`
    };
  }

  toString() {
    return this.modifiedString;
  }

  clone() {
    return new MagicString(this.originalString, this.options);
  }
}

MagicString.Bundle = class {
  constructor() {
    this.sources = [];
    this.indentString = '  ';
  }

  addSource(source) {
    this.sources.push(source);
    return this;
  }

  indent(indentStr) {
    if (indentStr) {
      this.indentString = indentStr;
    }
    this.sources = this.sources.map(
      source => new MagicString(source.modifiedString.replace(/^/gm, this.indentString))
    );
    return this;
  }

  toString() {
    return this.sources.map(source => source.toString()).join('\n');
  }

  generateMap(options = {}) {
    const map = {
      version: 3,
      file: options.file || 'bundle.js',
      sources: this.sources.map(source => source.options.filename || 'unknown'),
      mappings: '',
    };

    if (options.includeContent) {
      map.sourcesContent = this.sources.map(source => source.originalString);
    }

    return {
      ...map,
      toString: () => JSON.stringify(map),
      toUrl: () => `data:application/json;charset=utf-8;base64,${btoa(JSON.stringify(map))}`
    };
  }
};

export default MagicString;
```