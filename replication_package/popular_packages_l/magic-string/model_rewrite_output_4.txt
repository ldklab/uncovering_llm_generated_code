The Node.js code provided defines a class `MagicString` used for manipulating strings with additional functionality for tracking changes and generating source maps. Additionally, there is a nested `Bundle` class for managing collections of `MagicString` objects.

### Functionality Explanation:

1. **MagicString Class:**
   - **Constructor:** Initializes the `MagicString` object with the original string, a modifiable string (`modifiedString`), a list to record changes, and optional parameters.
   - **update(start, end, content):** Replaces the section of the string between `start` and `end` with `content`. Records this change.
   - **append(content):** Concatenates `content` to the end of the string. Records this change.
   - **prepend(content):** Add `content` to the beginning of the string. Records this change.
   - **generateMap(options):** Generates a source map based on the modifications. Includes the original source content if specified.
   - **toString():** Returns the current state of the modified string.
   - **clone():** Creates a duplicate of the `MagicString` instance.

2. **MagicString.Bundle Class:**
   - **Constructor:** Initializes an empty list of sources and a default indentation string.
   - **addSource(source):** Adds a `MagicString` source to the bundle.
   - **indent(indentStr):** Indents each line of each source with the given string or a default two spaces.
   - **toString():** Concatenates all sources, separated by new lines, into a single string.
   - **generateMap(options):** Generates a combined source map for the bundle.

### Rewritten Code:

```javascript
// MagicString.js

class MagicString {
  constructor(originalString, options = {}) {
    this.originalString = originalString;
    this.modifiedString = originalString;
    this.changes = [];
    this.options = options;
  }

  update(start, end, content) {
    this.modifiedString =
      this.modifiedString.slice(0, start) +
      content +
      this.modifiedString.slice(end);
    this.changes.push({ type: 'update', start, end, content });
    return this;
  }

  append(content) {
    this.modifiedString += content;
    this.changes.push({ type: 'append', content });
    return this;
  }

  prepend(content) {
    this.modifiedString = content + this.modifiedString;
    this.changes.push({ type: 'prepend', content });
    return this;
  }

  generateMap(options = {}) {
    const map = {
      version: 3,
      file: options.file || 'output.js',
      sources: [options.source || 'input.js'],
      names: [],
      mappings: 'AAAA'
    };

    if (options.includeContent) {
      map.sourcesContent = [this.originalString];
    }

    return {
      ...map,
      toString: () => JSON.stringify(map),
      toUrl: () => `data:application/json;charset=utf-8;base64,${btoa(JSON.stringify(map))}`
    };
  }

  toString() {
    return this.modifiedString;
  }

  clone() {
    return new MagicString(this.originalString, this.options);
  }
}

// MagicString.Bundle

MagicString.Bundle = class {
  constructor() {
    this.sources = [];
    this.indentString = '  ';
  }

  addSource(source) {
    this.sources.push(source);
    return this;
  }

  indent(indentStr) {
    if (indentStr) {
      this.indentString = indentStr;
    }
    this.sources = this.sources.map(
      source => new MagicString(source.modifiedString.replace(/^/gm, this.indentString))
    );
    return this;
  }

  toString() {
    return this.sources.map(source => source.toString()).join('\n');
  }

  generateMap(options = {}) {
    const map = {
      version: 3,
      file: options.file || 'bundle.js',
      sources: this.sources.map(source => source.options.filename || 'unknown'),
      mappings: '',
    };

    if (options.includeContent) {
      map.sourcesContent = this.sources.map(source => source.originalString);
    }

    return {
      ...map,
      toString: () => JSON.stringify(map),
      toUrl: () => `data:application/json;charset=utf-8;base64,${btoa(JSON.stringify(map))}`
    };
  }
};

export default MagicString;
```