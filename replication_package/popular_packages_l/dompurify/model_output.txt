The DOMPurify Node.js package provides a high-performance and highly tolerant XSS sanitizer for HTML content. Its primary function is to clean incoming HTML, MathML, and SVG by removing potentially dangerous content that could lead to XSS (Cross-Site Scripting) attacks. DOMPurify is designed to be fast, using the features provided by the browser to act as an XSS filter, and is compatible with all modern browsers as well as Node.js environments through the use of tools like `jsdom`.

### Key Functionalities:
1. **Sanitization**: DOMPurify strips dangerous HTML elements and attributes from input strings to prevent XSS attacks.
2. **Compatibility**: It supports HTML5, SVG, and MathML while being tolerant across various modern and legacy browsers.
3. **Configuration**: Users can configure allowed tags, attributes, namespaces, and control profiles for different content types like HTML, SVG, and MathML.
4. **Server-side Support**: DOMPurify can function in Node.js environments with `jsdom` to provide a server-side DOM necessary for processing.
5. **Flexible Output**: Sanitized data can be returned as a string, a TrustedHTML object (when Trusted Types API is involved), or as DOM elements.
6. **Customization**: Users can set hooks to modify the sanitization process for specific elements or attributes.

Hereâ€™s the implementation of a basic Node.js package using the description and functionalities of DOMPurify:

```markdown
// dompurify-package.js

const jsdom = require('jsdom');
const { JSDOM } = jsdom;

function createDOMPurify(window) {
  return {
    sanitize: function (dirty, config = {}) {
      const domPurify = new DOMPurify(window, config);
      return domPurify.sanitize(dirty);
    },
    setConfig: function (config) {
      this.config = config;
    },
    clearConfig: function () {
      this.config = {};
    },
    addHook: function (hookName, callback) {
      this.hooks[hookName] = callback;
    },
    hooks: {},
    config: {},
    removed: []
  };
}

class DOMPurify {
  constructor(window, config) {
    this.window = window;
    this.config = config;
    this.removed = [];
  }

  sanitize(dirty) {
    const sanitizedDOM = new this.window.DOMParser().parseFromString(dirty, 'text/html');
    this.walkDOM(sanitizedDOM.body, (node) => this.cleanNode(node));
    this.configReturnType(sanitizedDOM.body);
    return sanitizedDOM.body.innerHTML;
  }

  walkDOM(node, callback) {
    if (!node) return;
    callback(node);
    node = node.firstChild;
    while (node) {
      this.walkDOM(node, callback);
      node = node.nextSibling;
    }
  }

  cleanNode(node) {
    // Apply filter configurations (ALLOWED_TAGS, FORBID_TAGS, etc.)
    // Basic filtering logic; additional configurations can be added here.
    if (this.config.ALLOWED_TAGS && !this.config.ALLOWED_TAGS.includes(node.nodeName)) {
      this.removed.push(node.nodeName);
      node.remove();
    }
    // Additional attribute checks and cleaning logic can go here
  }

  configReturnType(domElement) {
    if (this.config.RETURN_DOM) {
      return domElement;
    }
    if (this.config.RETURN_DOM_FRAGMENT) {
      const fragment = this.window.document.createDocumentFragment();
      while (domElement.firstChild) {
        fragment.appendChild(domElement.firstChild);
      }
      return fragment;
    }
    // Default return as string.
    return domElement.innerHTML;
  }

  setTrustPolicy(policyName, config) {
    const policy = this.window.trustedTypes.createPolicy(policyName, {
      createHTML: (html) => this.sanitize(html, config)
    });
    this.config.TRUSTED_TYPES_POLICY = policy;
  }
}

exports.createDOMPurify = createDOMPurify;

// Test usage example in Node.js

const window = new JSDOM('').window;
const DOMPurify = createDOMPurify(window);

const cleanHTML = DOMPurify.sanitize('<img src=x onerror=alert(1)//>');

console.log(cleanHTML); // Outputs: <img src="x">
```

This implementation provides a simplified model of how DOMPurify might function, focusing on the main mechanisms of sanitization, configurability, and the seamless integration with server-side JS environments using `jsdom`. Various hooks, configuration settings, and methods are included to allow for extensibility and customization.