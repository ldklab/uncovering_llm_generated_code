The functionality described in the Zod Node.js package README focuses on schema declaration and validation with TypeScript-first principles. Hereâ€™s a condensed explanation of its features and capabilities:

- **Schema Declaration**: Zod provides tools for declaring schemas for data validation spanning across simple primitives like `string`, `number`, to complex objects and arrays.
  
- **TypeScript Integration**: Zod automatically infers TypeScript types for schemas, reducing duplication in type declarations.

- **Validation and Parsing**: It supports both synchronous (`.parse`) and asynchronous (`.parseAsync`) operations to parse and validate data. Synchronous variants like `.safeParse` provide a non-throwing alternative that returns success state.

- **Refinements**: Validators can be extended with custom validation functions using `.refine` and `.superRefine` for handling more complex cases, including async operations.

- **Transformations**: Zod allows data transformations using `.transform`, letting you change data post-validation.

- **Composability**: Schemas can be composed using union types, intersections, and are customizable with methods like `.pick`, `.omit`, and `.partial`.

- **Error Handling**: ZodError provides detailed error reporting, and the library allows customization of error messages and paths.

- **Utility methods**: Zod supports utility methods to handle `.optional`, `.nullable`, `.array`, `.enum`, and more for ease of schema management.

- **Immutability and Influent API**: The library promotes an immutable and chainable design, allowing the creation of robust validation chains.

Below is a simple implementation of some key functionalities in the given description.

```javascript
// Import Zod
const { z } = require('zod');

// Creating a schema for a simple string
const stringSchema = z.string();

// Parsing
try {
    console.log(stringSchema.parse("hello")); // "hello"
} catch (e) {
    console.error(e.errors);
}

// Safe parsing
const safeParseResult = stringSchema.safeParse("hello");
if (safeParseResult.success) {
    console.log(safeParseResult.data); // "hello"
} else {
    console.error(safeParseResult.error);
}

// Creating an object schema
const userSchema = z.object({
  username: z.string(),
  age: z.number().min(18),
  email: z.string().email().optional()
});

try {
  const user = userSchema.parse({
    username: "john_doe",
    age: 20,
    email: "john@example.com"
  });
  console.log(user);
} catch (error) {
  console.error(error.errors);
}

// Using .optional and .nullable
const optionalStringSchema = z.string().optional();
console.log(optionalStringSchema.parse(undefined)); // undefined

const nullableStringSchema = z.string().nullable();
console.log(nullableStringSchema.parse(null)); // null

// A schema with custom validation
const passwordSchema = z.string().min(8).refine(val => /[A-Z]/.test(val), {
    message: "Must contain one uppercase letter"
});

try {
    const password = passwordSchema.parse("password");
    console.log(password);
} catch (e) {
    console.error(e.errors);
}

// Working with unions
const numberOrString = z.union([z.number(), z.string()]);
console.log(numberOrString.parse(123)); // 123
console.log(numberOrString.parse("abc")); // "abc"

// Using transformations
const upperCaseString = z.string().transform(str => str.toUpperCase());
console.log(upperCaseString.parse("hello")); // "HELLO"
```