The provided Node.js code implements the VLQ (Variable-Length Quantity) encoding and decoding algorithm, typically used for efficient storage of integers in source maps. Here's a detailed explanation of the code's functionality:

1. **VLQ Encoding and Decoding**:
   - `vlqEncode(value)`: Encodes a value using VLQ format. It converts an integer to a VLQ representation, utilizes base64 for characters, and compresses data suitable for transmission or storage.
   - `vlqDecode(chars, index)`: Decodes a VLQ encoded string starting from a specified index, returning the decoded integer and the next index position.

2. **Base64 Encoding and Decoding**:
   - `encodeBase64(value)`: Converts an integer to a corresponding base64 character using a predefined character set.
   - `decodeBase64(char)`: Retrieves the original integer from a base64 character using the same character set.

3. **Encoding and Decoding Source Maps**:
   - `encode(decoded)`: Encodes a multi-dimensional array representing a source map into a flat, VLQ and base64-encoded string format.
   - `decode(encoded)`: Converts the encoded string format back into a structure that represents source maps, decoding each segment in the process.

4. **Data Structure**:
   - The encoded format typically maps segments of source code to their original files, lines, and other metadata, all encoded and separated by delimiters for efficient parsing and transmission.

Here's a possible rewrite of the code:

```javascript
// VLQ and Base64 encoding/decoding for source maps

function vlqEncode(value) {
  let result = '';
  let vlq = (value < 0 ? (-value << 1) + 1 : value << 1) >>> 0;

  do {
    let digit = vlq & 31;
    vlq >>>= 5;
    if (vlq > 0) {
      digit |= 32;
    }
    result += encodeBase64(digit);
  } while (vlq > 0);

  return result;
}

function vlqDecode(encodedStr, index) {
  let result = 0, shift = 0;
  let continuation, value;
  
  do {
    value = decodeBase64(encodedStr.charAt(index++));
    continuation = value & 32;
    result += (value & 31) << shift;
    shift += 5;
  } while (continuation);
  
  return [(result & 1 ? ~(result >>> 1) : (result >>> 1)), index];
}

function encodeBase64(value) {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  return chars[value];
}

function decodeBase64(char) {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  return chars.indexOf(char);
}

export function encode(decoded) {
  return decoded.map(line => line.map(segment => segment.map((val, idx) => {
    return idx === 0 ? vlqEncode(val) : vlqEncode(val - (segment[idx - 1] || 0));
  }).join('')).join(',')).join(';');
}

export function decode(encoded) {
  return encoded.split(';').map(line => {
    const segments = line.split(',');
    let column = 0, sourceIndex = 0, sourceLine = 0, sourceColumn = 0, nameIndex = 0;
    
    return segments.map(segment => {
      const decoded = [];
      let index = 0;
      
      if (segment) {
        [column, index] = vlqDecode(segment, index);
        column += (decoded[0] || 0);
        decoded.push(column);

        if (index < segment.length) {
          [sourceIndex, index] = vlqDecode(segment, index);
          sourceIndex += (decoded[1] || 0);
          decoded.push(sourceIndex);

          if (index < segment.length) {
            [sourceLine, index] = vlqDecode(segment, index);
            sourceLine += (decoded[2] || 0);
            decoded.push(sourceLine);

            if (index < segment.length) {
              [sourceColumn, index] = vlqDecode(segment, index);
              sourceColumn += (decoded[3] || 0);
              decoded.push(sourceColumn);

              if (index < segment.length) {
                [nameIndex, index] = vlqDecode(segment, index);
                nameIndex += (decoded[4] || 0);
                decoded.push(nameIndex);
              }
            }
          }
        }
      }

      return decoded;
    });
  });
}
```