The provided Node.js code defines a `CachePolicy` class that represents caching policies for HTTP requests and responses. Here's a breakdown of its functionality:

1. **Constructor**: Initializes the class with `request`, `response`, and optional `options` (e.g., `shared`, `cacheHeuristic`, `immutableMinTimeToLive`, `ignoreCargoCult`) to configure caching behavior.

2. **storable() Method**: Checks if a response is storable based on its `cache-control` header and whether the cache is shared.

3. **satisfiesWithoutRevalidation(newRequest)**: Determines if a new request can be satisfied without revalidating the cached response. It checks the URL, HTTP method, and freshness of the cached item.

4. **isFresh() Method**: Evaluates if the cached response is still fresh by comparing its age to the max-age directive from the `cache-control` header.

5. **responseHeaders() Method**: Returns updated response headers with calculated age, excluding specific headers like 'te' and 'connection'.

6. **calculateAge() Method**: Computes the current age of the cached response, incrementing the age by 1.

7. **timeToLive() Method**: Computes remaining time-to-live for the cached response based on max-age and current age.

8. **toObject() and fromObject() Methods**: Allow serialization and deserialization of the `CachePolicy` object.

9. **revalidationHeaders(newRequest) Method**: Returns headers for use in a revalidation request, currently a shallow copy of the new request headers.

10. **revalidatedPolicy(revalidationRequest, revalidationResponse) Method**: Evaluates a revalidation response and updates the caching policy; returns if content was modified.

The class is also exported as a module for reuse.

Here's the rewritten Node.js code:

```javascript
class CachePolicy {
    constructor(request, response, options = {}) {
        this.request = request;
        this.response = response;
        this.shared = options.shared ?? true;
        this.cacheHeuristic = options.cacheHeuristic || 0.1;
        this.immutableMinTimeToLive = options.immutableMinTimeToLive || 24 * 3600 * 1000;
        this.ignoreCargoCult = options.ignoreCargoCult || false;
    }

    storable() {
        const cacheControl = this.response.headers['cache-control'];
        if (!cacheControl || cacheControl.includes('no-store') || (this.shared && cacheControl.includes('private'))) {
            return false;
        }
        return true;
    }

    satisfiesWithoutRevalidation(newRequest) {
        if (newRequest.url !== this.request.url || newRequest.method !== this.request.method) {
            return false;
        }
        return this.isFresh();
    }

    isFresh() {
        const age = Number(this.response.headers['age'] || 0);
        const maxAgeMatch = this.response.headers['cache-control']?.match(/max-age=(\d+)/);
        const maxAge = maxAgeMatch ? parseInt(maxAgeMatch[1], 10) : null;
        return maxAge !== null && age < maxAge;
    }

    responseHeaders() {
        const headers = { ...this.response.headers };
        delete headers['te'];
        delete headers['connection'];
        headers['age'] = this.calculateAge();
        return headers;
    }

    calculateAge() {
        return parseInt(this.response.headers['age'] || 0, 10) + 1;
    }

    timeToLive() {
        const maxAgeMatch = this.response.headers['cache-control']?.match(/max-age=(\d+)/);
        const maxAge = maxAgeMatch ? parseInt(maxAgeMatch[1], 10) : 0;
        return maxAge - this.calculateAge();
    }

    toObject() {
        return { 
            request: this.request, 
            response: this.response, 
            options: { 
                shared: this.shared, 
                cacheHeuristic: this.cacheHeuristic, 
                immutableMinTimeToLive: this.immutableMinTimeToLive, 
                ignoreCargoCult: this.ignoreCargoCult 
            } 
        };
    }

    static fromObject(obj) {
        return new CachePolicy(obj.request, obj.response, obj.options);
    }

    revalidationHeaders(newRequest) {
        return { ...newRequest.headers };
    }

    revalidatedPolicy(revalidationRequest, revalidationResponse) {
        const modified = revalidationResponse.status !== 304;
        const policy = new CachePolicy(revalidationRequest, revalidationResponse, { 
            shared: this.shared, 
            cacheHeuristic: this.cacheHeuristic, 
            immutableMinTimeToLive: this.immutableMinTimeToLive, 
            ignoreCargoCult: this.ignoreCargoCult 
        });
        return { policy, modified };
    }
}

module.exports = CachePolicy;
```