The provided Node.js code defines a `CachePolicy` class intended to handle HTTP caching behavior for incoming and outgoing HTTP requests and responses. The primary functionalities of the class include:

1. **Initialization and Options Handling**: The constructor initializes properties from HTTP requests and responses and supports options for shared cache, heuristics, and handling of cache directives.

2. **Storable Check**: Determines if the response can be stored in the cache, based on cache control directives like 'no-store' and 'private'.

3. **Request Validation**: Checks if a new request can be satisfied from the cache without revalidation, ensuring URL and methods match and content is still fresh.

4. **Freshness Check**: Evaluates if the cached response is still fresh based on age and max-age directives in the cache control header.

5. **Response Header Management**: Adjusts headers by calculating the current age and eliminating certain headers not suitable for caching logic.

6. **Cache Time-to-Live (TTL)**: Calculates how long a cached response can be considered valid based on max-age versus current age.

7. **Serialization and Deserialization**: Converts the policy to and from an object, facilitating persistence or transfer.

8. **Revalidation Headers and Policy Handling**: Manages request headers necessary for revalidation and creates a new cache policy based on the revalidation response to determine if content has been modified.

Below is a refactored version of the `CachePolicy` class, maintaining its initial structure and logic:

```javascript
class CachePolicy {
    constructor(request, response, options = {}) {
        this.request = request;
        this.response = response;
        this.shared = options.shared !== undefined ? options.shared : true;
        this.cacheHeuristic = options.cacheHeuristic || 0.1;
        this.immutableMinTimeToLive = options.immutableMinTimeToLive || 86400000; // 24 hours in milliseconds
        this.ignoreCargoCult = options.ignoreCargoCult || false;
    }

    storable() {
        const cacheControl = this.response.headers['cache-control'];
        return cacheControl && !cacheControl.includes('no-store') && (!this.shared || !cacheControl.includes('private'));
    }

    satisfiesWithoutRevalidation(newRequest) {
        return newRequest.url === this.request.url &&
               newRequest.method === this.request.method &&
               this.isFresh();
    }

    isFresh() {
        const age = parseInt(this.response.headers['age'] || '0', 10);
        const maxAgeMatch = this.response.headers['cache-control']?.match(/max-age=(\d+)/);
        const maxAge = maxAgeMatch ? parseInt(maxAgeMatch[1], 10) : 0;
        return maxAge > age;
    }

    responseHeaders() {
        const headers = { ...this.response.headers };
        delete headers['te'];
        delete headers['connection'];
        headers['age'] = this.calculateAge();
        return headers;
    }

    calculateAge() {
        return (parseInt(this.response.headers['age'] || '0', 10) + 1).toString();
    }

    timeToLive() {
        const maxAgeMatch = this.response.headers['cache-control']?.match(/max-age=(\d+)/);
        const maxAge = maxAgeMatch ? parseInt(maxAgeMatch[1], 10) : 0;
        return maxAge - this.calculateAge();
    }

    toObject() {
        return {
            request: this.request,
            response: this.response,
            options: {
                shared: this.shared,
                cacheHeuristic: this.cacheHeuristic,
                immutableMinTimeToLive: this.immutableMinTimeToLive,
                ignoreCargoCult: this.ignoreCargoCult
            }
        };
    }

    static fromObject(obj) {
        return new CachePolicy(obj.request, obj.response, obj.options);
    }

    revalidationHeaders(newRequest) {
        return { ...newRequest.headers };
    }

    revalidatedPolicy(revalidationRequest, revalidationResponse) {
        const modified = revalidationResponse.status !== 304;
        const policy = new CachePolicy(revalidationRequest, revalidationResponse, {
            shared: this.shared,
            cacheHeuristic: this.cacheHeuristic,
            immutableMinTimeToLive: this.immutableMinTimeToLive,
            ignoreCargoCult: this.ignoreCargoCult
        });
        return { policy, modified };
    }
}

module.exports = CachePolicy;
```