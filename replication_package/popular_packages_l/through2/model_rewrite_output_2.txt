The provided Node.js code is a simplified version of the popular `through2` library, which creates Transform streams in Node.js. The `through2` function allows you to easily create a stream that can process incoming data chunks by supplying a `transformFunction` and optionally a `flushFunction`.

Here's a breakdown of the functionality:

1. **Main Function (`through2`)**: It accepts either an options object with a transform and flush function or directly the transform function. It returns a new Transform stream that executes these functions when data is streamed through it.
   
2. **Default Transform Function**: If no transform function is provided, it passes chunks through unchanged.
   
3. **Flush Function**: Called when the stream ends, if provided.
   
4. **Object Mode Convenience (`through2.obj`)**: Shortcut for creating object mode Transform streams.
   
5. **Constructor Creation Function (`through2.ctor`)**: Allows creating custom Transform stream classes that can be instantiated with or without overriding options.

Below is a possible rewrite of the code according to the above explanation:

```javascript
const { Transform } = require('stream');

function through2(optionsOrTransformFn, transformFnOrFlushFn, flushFn) {
  let options = {};
  let transformFunction;
  let flushFunction;

  if (typeof optionsOrTransformFn === 'function') {
    flushFunction = transformFnOrFlushFn;
    transformFunction = optionsOrTransformFn;
  } else {
    options = optionsOrTransformFn || {};
    transformFunction = transformFnOrFlushFn;
    flushFunction = flushFn;
  }

  transformFunction = transformFunction ||
    function (chunk, enc, cb) { cb(null, chunk); };

  const transform = new Transform({
    ...options,
    transform(chunk, enc, callback) {
      transformFunction.call(this, chunk, enc, callback);
    },
    flush(callback) {
      if (flushFunction) {
        flushFunction.call(this, callback);
      } else {
        callback();
      }
    }
  });

  return transform;
}

through2.obj = function(transformFunction, flushFunction) {
  return through2({ objectMode: true }, transformFunction, flushFunction);
};

through2.ctor = function(optionsOrTransformFn, transformFnOrFlushFn, flushFn) {
  let options = {};
  let transformFunction;
  let flushFunction;

  if (typeof optionsOrTransformFn === 'function') {
    flushFunction = transformFnOrFlushFn;
    transformFunction = optionsOrTransformFn;
  } else {
    options = optionsOrTransformFn || {};
    transformFunction = transformFnOrFlushFn;
    flushFunction = flushFn;
  }

  transformFunction = transformFunction ||
    function (chunk, enc, cb) { cb(null, chunk); };

  return class ThroughTransform extends Transform {
    constructor(overrideOptions) {
      super(overrideOptions ? { ...options, ...overrideOptions } : options);
    }

    _transform(chunk, encoding, callback) {
      transformFunction.call(this, chunk, encoding, callback);
    }

    _flush(callback) {
      if (flushFunction) {
        flushFunction.call(this, callback);
      } else {
        callback();
      }
    }
  };
};

module.exports = through2;
```