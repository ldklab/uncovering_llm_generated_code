// index.js
const protobuf = require('protobufjs');

class GRPCProtoLoader {
    static async load(filePath, options = {}) {
        const root = new protobuf.Root();
        if (options.includeDirs) {
            root.resolvePath = (origin, target) => (
                protobuf.util.path.resolvePath(origin, target, options.includeDirs)
            );
        }
        return protobuf.load(filePath, root, options);
    }

    static loadSync(filePath, options = {}) {
        const root = new protobuf.Root();
        if (options.includeDirs) {
            root.resolvePath = (origin, target) => (
                protobuf.util.path.resolvePath(origin, target, options.includeDirs)
            );
        }
        return protobuf.loadSync(filePath, root, options);
    }
}

module.exports = GRPCProtoLoader;

// proto-loader-gen-types.js
const yargs = require('yargs');
const protobuf = require('protobufjs');
const fs = require('fs');
const path = require('path');

const generateTypeScript = (filePath, options) => {
    const root = new protobuf.Root();

    if (options.includeDirs) {
        root.resolvePath = (origin, target) => {
            const paths = [process.cwd(), ...options.includeDirs];
            for (const dir of paths) {
                const resolved = path.resolve(dir, target);
                if (fs.existsSync(resolved)) return resolved;
            }
            return null;
        };
    }

    const rootLoaded = protobuf.loadSync(filePath, root);
    const outputDir = options.outDir || 'proto';
    const outputPath = path.join(outputDir, path.basename(filePath, '.proto') + '.ts');

    if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir, { recursive: true });

    const typescriptContent = rootLoaded.nestedArray.map(child => {
        if (child instanceof protobuf.Type) {
            return protobuf.Type.toDescriptor(child).toString();
        }
        return '';
    }).join('\n');

    fs.writeFileSync(outputPath, `// Generated by proto-loader-gen-types\n\n${typescriptContent}`);
};

const argv = yargs
    .option('includeDirs', {
        alias: 'I',
        type: 'array',
        description: 'Directories to search for imported files',
    })
    .option('outDir', {
        alias: 'O',
        type: 'string',
        description: 'Output directory for generated TypeScript files',
        demandOption: true,
    })
    .help()
    .argv;

argv._.forEach(filePath => generateTypeScript(filePath, argv));
