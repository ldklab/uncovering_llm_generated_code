The provided Node.js code consists of two separate scripts: one for loading Protocol Buffers using the `protobufjs` library, either asynchronously or synchronously, and another for generating TypeScript declarations from `.proto` files.

1. **GRPCProtoLoader Class (`index.js`)**:
   - This class provides two static methods to load Protocol Buffers:
     - `load`: Asynchronously loads a `.proto` file using `protobufjs.load`.
     - `loadSync`: Synchronously loads a `.proto` file using `protobufjs.loadSync` and then converts the loaded root to a descriptor for use.
   - Both methods use an optional `options` parameter which can include additional directories (`includeDirs`) for resolving imported `.proto` files paths.

2. **TypeScript Generator Script (`proto-loader-gen-types.js`)**:
   - A Node.js command-line tool powered by `yargs` that generates TypeScript files from `.proto` files.
   - It allows specifying directories to search for `.proto` files using the `--includeDirs` (`-I`) option and sets an output directory with the `--outDir` (`-O`) option.
   - The script resolves paths for imported `.proto` files, loads them, and then generates TypeScript code representing the content of these files.
   - The generated TypeScript code is saved in a specified output directory, with file names matching the original `.proto` file names.

Here's a possible rewrite of the code:

```javascript
// index.js
const protobuf = require('protobufjs');

class GRPCProtoLoader {
    static async load(filePath, options = {}) {
        const root = new protobuf.Root();
        if (options.includeDirs) {
            root.resolvePath = (origin, target) => (
                protobuf.util.path.resolvePath(origin, target, options.includeDirs)
            );
        }
        return protobuf.load(filePath, root, options);
    }

    static loadSync(filePath, options = {}) {
        const root = new protobuf.Root();
        if (options.includeDirs) {
            root.resolvePath = (origin, target) => (
                protobuf.util.path.resolvePath(origin, target, options.includeDirs)
            );
        }
        return protobuf.loadSync(filePath, root, options);
    }
}

module.exports = GRPCProtoLoader;

// proto-loader-gen-types.js
const yargs = require('yargs');
const protobuf = require('protobufjs');
const fs = require('fs');
const path = require('path');

const generateTypeScript = (filePath, options) => {
    const root = new protobuf.Root();

    if (options.includeDirs) {
        root.resolvePath = (origin, target) => {
            const paths = [process.cwd(), ...options.includeDirs];
            for (const dir of paths) {
                const resolved = path.resolve(dir, target);
                if (fs.existsSync(resolved)) return resolved;
            }
            return null;
        };
    }

    const rootLoaded = protobuf.loadSync(filePath, root);
    const outputDir = options.outDir || 'proto';
    const outputPath = path.join(outputDir, path.basename(filePath, '.proto') + '.ts');

    if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir, { recursive: true });

    const typescriptContent = rootLoaded.nestedArray.map(child => {
        if (child instanceof protobuf.Type) {
            return protobuf.Type.toDescriptor(child).toString();
        }
        return '';
    }).join('\n');

    fs.writeFileSync(outputPath, `// Generated by proto-loader-gen-types\n\n${typescriptContent}`);
};

const argv = yargs
    .option('includeDirs', {
        alias: 'I',
        type: 'array',
        description: 'Directories to search for imported files',
    })
    .option('outDir', {
        alias: 'O',
        type: 'string',
        description: 'Output directory for generated TypeScript files',
        demandOption: true,
    })
    .help()
    .argv;

argv._.forEach(filePath => generateTypeScript(filePath, argv));
```