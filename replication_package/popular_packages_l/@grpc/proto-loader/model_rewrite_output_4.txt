The given Node.js code consists of two files: `index.js` and `proto-loader-gen-types.js`.

### Functionality

1. **index.js**:
   - This file defines a class `GRPCProtoLoader` which contains two methods: `load` and `loadSync`.
   - The `load` method is an asynchronous function that loads a Protocol Buffers (protobuf) file, using the optional include directories specified in the `options`.
   - The `loadSync` method does the same synchronously and returns a descriptor from the loaded protobuf.

2. **proto-loader-gen-types.js**:
   - This script is a command-line tool that generates TypeScript definitions from protobuf files.
   - It uses `yargs` to parse command line arguments, expecting `includeDirs` for the directories to include and `outDir` for the output directory where TypeScript files should be saved.
   - It defines a `generateTypeScript` function that resolves the paths of the protobuf files, loads them, and writes out TypeScript definitions.
   - The script reads the list of file paths passed as positional arguments and generates TypeScript files for each.

Here is the possible rewrite of both files combined in a single code block.

```javascript
// index.js and proto-loader-gen-types.js combined
const protobuf = require('protobufjs');
const fs = require('fs');
const path = require('path');
const yargs = require('yargs');

class GRPCProtoLoader {
    static async load(filePath, options = {}) {
        const root = new protobuf.Root();
        if (options.includeDirs) {
            options.includeDirs.forEach(dir => root.resolvePath = protobuf.util.path.resolvePath);
        }
        return protobuf.load(filePath, root, options);
    }

    static loadSync(filePath, options = {}) {
        const root = new protobuf.Root();
        if (options.includeDirs) {
            options.includeDirs.forEach(dir => root.resolvePath = protobuf.util.path.resolvePath);
        }
        const rootLoaded = protobuf.loadSync(filePath, root, options);
        return protobuf.toDescriptor(rootLoaded);
    }
}

function generateTypeScript(filePath, options) {
    const root = new protobuf.Root();
    
    if (options.includeDirs) {
        protobuf.util.path.resolvePath = (origin, target) => {
            const paths = [path.join(process.cwd(), origin), ...options.includeDirs];
            for (const p of paths) {
                const resolved = path.join(p, target);
                if (fs.existsSync(resolved)) return resolved;
            }
            return null;
        };
    }
    
    protobuf.loadSync(filePath, root);

    const outputDir = options.outDir || 'proto';
    const fileName = path.basename(filePath, '.proto') + '.ts';
    const outputPath = path.join(outputDir, fileName);

    const writeFileContent = (namespace) => {
        let typescriptCode = '// Generated TypeScript for ' + fileName + '\n';
        namespace.nestedArray.forEach(child => {
            if (child instanceof protobuf.Type) {
                typescriptCode += protobuf.Type.toDescriptor(child).toString();
            }
        });

        if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir, { recursive: true });
        fs.writeFileSync(outputPath, typescriptCode);
    };

    writeFileContent(root);
}

const argv = yargs
    .option('includeDirs', {
        alias: 'I',
        type: 'array',
    })
    .option('outDir', {
        alias: 'O',
        type: 'string',
        demandOption: true,
    })
    .argv;

argv._.forEach(filePath => generateTypeScript(filePath, argv));

module.exports = GRPCProtoLoader;
```