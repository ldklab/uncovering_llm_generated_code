The provided Node.js code defines a set of functions to traverse and manipulate abstract syntax trees (AST) generated by the `acorn` JavaScript parser. These functions are used to construct tree-walkers that process AST nodes in different ways. Here's a breakdown of each function:

1. **Simple Walker** (`simple`): Visits each node of a specific type and applies the provided visitor function.

2. **Ancestor Walker** (`ancestor`): Visits each node, while keeping track of the ancestor nodes leading to it. The visitor function gets called with the node and its ancestors.

3. **Recursive Walker** (`recursive`): Works similarly to the `simple` walker but can use a custom set of functions to handle different node types, falling back to default handlers when necessary.

4. **Custom Walker Maker** (`make`): Allows creation of a new walker object by merging a set of custom functions for node types with a base walker.

5. **Full Walker** (`full`): Traverses the entire tree and applies a callback for each node, using the base walker functionalities.

6. **Full Ancestor Walker** (`fullAncestor`): Similar to `full`, but the callback receives the node along with its ancestor chain.

7. **Find Node At** (`findNodeAt`): Searches for a node within a given start and end position, based on a test condition.

8. **Find Node Around** (`findNodeAround`): Searches for a node around a specific position that matches the test condition.

9. **Find Node After** (`findNodeAfter`): Locates the first node after a certain position that fits the test condition.

The `defaultWalker` object provides default methods for visiting AST node types, with a basic implementation for `Program` and `Literal` types.

Here's the refactored code:

```javascript
const acorn = require('acorn');

function simple(node, visitors, base = defaultWalker, state = null) {
  const visitNode = (node, state, override) => {
    const type = override || node.type;
    if (visitors[type]) visitors[type](node, state, visitNode);
    else base[type](node, state, visitNode);
  };
  visitNode(node, state);
}

function ancestor(node, visitors, base = defaultWalker, state = []) {
  const visitNode = (node, state, override) => {
    const type = override || node.type;
    const newAncestors = state.concat(node);
    if (visitors[type]) visitors[type](node, newAncestors);
    base[type](node, newAncestors, visitNode);
  };
  visitNode(node, state);
}

function recursive(node, state, functions, base = defaultWalker) {
  const visitNode = (node, state, override) => {
    const type = override || node.type;
    if (functions[type]) functions[type](node, state, visitNode);
    else base[type](node, state, visitNode);
  };
  visitNode(node, state);
}

function make(functions, base = defaultWalker) {
  return { ...base, ...functions };
}

function full(node, callback, base = defaultWalker, state = null) {
  const visitNode = (node, state) => {
    callback(node, state, node.type);
    base[node.type](node, state, visitNode);
  };
  visitNode(node, state);
}

function fullAncestor(node, callback, base = defaultWalker, state = []) {
  const visitNode = (node, state) => {
    const newAncestors = state.concat(node);
    callback(node, newAncestors);
    base[node.type](node, newAncestors, visitNode);
  };
  visitNode(node, state);
}

function findNodeAt(node, start, end, test, base = defaultWalker, state = null) {
  let result;
  const visitNode = (node, state, override) => {
    const type = override || node.type;
    if ((start == null || node.start <= start) &&
        (end == null || node.end >= end) &&
        (typeof test === "string" ? type === test : test(type, node))) {
      result = node;
    }
    base[type](node, state, visitNode);
  };
  visitNode(node, state);
  return result;
}

function findNodeAround(node, pos, test, base = defaultWalker, state = null) {
  let result;
  const visitNode = (node, state, override) => {
    const type = override || node.type;
    if (node.start <= pos && node.end >= pos &&
        (typeof test === "string" ? type === test : test(type, node))) {
      result = node;
    }
    base[type](node, state, visitNode);
  };
  visitNode(node, state);
  return result;
}

function findNodeAfter(node, pos, test, base = defaultWalker, state = null) {
  let result;
  const visitNode = (node, state, override) => {
    const type = override || node.type;
    if (node.end >= pos &&
        (typeof test === "string" ? type === test : test(type, node))) {
      if (!result || node.start < result.start) result = node;
    }
    base[type](node, state, visitNode);
  };
  visitNode(node, state);
  return result;
}

const defaultWalker = {
  Program(node, state, visitNode) {
    node.body.forEach(statement => visitNode(statement, state, "Statement"));
  },
  Literal(node, state, visitNode) {},
  // Extend with more node types as needed
};

module.exports = {
  simple, ancestor, recursive, make, full, fullAncestor,
  findNodeAt, findNodeAround, findNodeAfter
};
```