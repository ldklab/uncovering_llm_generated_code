The Node.js package `acorn-walk` is an abstract syntax tree (AST) walker for the ESTree format. Here's a breakdown of its functionalities as described in the README.md you provided:

### Overview
- **AST Walker**: A tool for traversing an AST, which represents the structure of JavaScript code. 
- **ESTree Format**: A standard format for representing JavaScript code in an AST.

### Main Functionalities

1. **`simple` function**:
   - Performs a basic walkthrough of an AST.
   - **Parameters**:
     - `node`: The root AST node.
     - `visitors`: An object containing functions keyed by node types.
     - `base` (optional): Specifies a default walker, can be omitted.
     - `state` (optional): An initial state for the walk.
   - Usage: Collect specific information from nodes (like literals).

2. **`ancestor` function**:
   - Similar to `simple`, but tracks ancestor nodes during the walk.
   - **Parameters** and usage are similar to `simple`.

3. **`recursive` function**:
   - Provides more control to the walker function. Each walker function manually continues the traversal on child nodes.
   - **Parameters**:
     - `node`: The initial AST node.
     - `state`: The initial state.
     - `functions`: An object mapping node types to functions for traversal.
     - `base` (optional): Default walkers for unhandled node types.

4. **`make` function**:
   - Constructs a walker object using provided functions and a fallback base.

5. **`full` and `fullAncestor` functions**:
   - Traverses every node, calling a callback on each.
   - `fullAncestor` additionally supplies ancestor nodes.

6. **`findNodeAt`, `findNodeAround`, `findNodeAfter` functions**:
   - Search for a specific node within an AST based on position and optionally type or a test function.
   - `findNodeAt`: Locates a node at specific offsets.
   - `findNodeAround`: Finds any node encompassing a position.
   - `findNodeAfter`: Locates nodes after a position.

### Implementation of the `acorn-walk` Package in Node.js

Here's the code implementing the described functionalities:

```javascript
const acorn = require('acorn');

function simple(node, visitors, base = defaultWalker, state = null) {
  function c(node, st, override) {
    let type = override || node.type, found = visitors[type];
    if (found) found(node, st, c);
    else base[type](node, st, c);
  }
  c(node, state);
}

function ancestor(node, visitors, base = defaultWalker, state = []) {
  function c(node, st, override) {
    let type = override || node.type, found = visitors[type];
    let newAncestors = st.concat(node);
    if (found) found(node, newAncestors);
    base[type](node, newAncestors, c);
  }
  c(node, state);
}

function recursive(node, state, functions, base = defaultWalker) {
  function c(node, st, override) {
    let type = override || node.type, found = functions[type];
    if (found) found(node, st, c);
    else base[type](node, st, c);
  }
  c(node, state);
}

function make(functions, base = defaultWalker) {
  let walker = Object.create(base);
  for (let type in functions) walker[type] = functions[type];
  return walker;
}

function full(node, callback, base = defaultWalker, state = null) {
  function c(node, st) {
    callback(node, st, node.type);
    base[node.type](node, st, c);
  }
  c(node, state);
}

function fullAncestor(node, callback, base = defaultWalker, state = []) {
  function c(node, st) {
    let newAncestors = st.concat(node);
    callback(node, newAncestors);
    base[node.type](node, newAncestors, c);
  }
  c(node, state);
}

function findNodeAt(node, start, end, test, base = defaultWalker, state = null) {
  let result;
  function c(node, st, override) {
    let type = override || node.type;
    if ((start == null || node.start != null && node.start <= start) &&
        (end == null || node.end != null && node.end >= end))
      if (typeof test == "string" ? type === test : test(type, node)) result = node;
    base[type](node, st, c);
  }
  c(node, state);
  return result;
}

function findNodeAround(node, pos, test, base = defaultWalker, state = null) {
  let result;
  function c(node, st, override) {
    let type = override || node.type;
    if (node.start != null && node.start <= pos && node.end != null && node.end >= pos)
      if (typeof test == "string" ? type === test : test(type, node)) result = node;
    base[type](node, st, c);
  }
  c(node, state);
  return result;
}

function findNodeAfter(node, pos, test, base = defaultWalker, state = null) {
  let result;
  function c(node, st, override) {
    let type = override || node.type;
    if (node.end != null && node.end >= pos)
      if (typeof test == "string" ? type === test : test(type, node)) { 
        if (!result || node.start < result.start) result = node;
      }
    base[type](node, st, c);
  }
  c(node, state);
  return result;
}

const defaultWalker = {
  Program(node, st, c) {
    for (let i = 0; i < node.body.length; i++) c(node.body[i], st, "Statement");
  },
  // Default implementations for other nodes as placeholders
  Literal(node, st, c) {},
  // Add any other node types you need in your implementation
};

module.exports = {
  simple, ancestor, recursive, make, full, fullAncestor,
  findNodeAt, findNodeAround, findNodeAfter
};
```

The implementation provides the tools to analyze and transform JavaScript code according to the functionalities described in the README. Each function involves traversing the AST, executing specific operations defined in visitor functions or other forms of callbacks based on the node type and traversal strategy.