The provided Node.js code defines a utility function `runAsync` and its variant `runAsyncCb` that enable functions to work with Promises, offering a seamless asynchronous execution model, even if the native `Promise` object is unavailable and needs polyfilling. Here's a breakdown of the core functionality:

1. **Promise Polyfill**: The code starts by checking if `Promise` is defined in the global scope, and if it's not, it brings in a polyfill using the `es6-promise` library to ensure Promise support.

2. **`runAsync` Function**:
   - The function takes a function `func` and an optional `customAsync` property name.
   - It returns a new function that, when called, executes `func` with the provided arguments within the context `self`.
   - A `callback` function is designed that translates traditional callback-style responses into Promise resolutions or rejections.
   - `callback.promise` is where a new Promise object with `resolve` and `reject` methods is stored and controlled.
   - It attempts to determine if `func` returns a Promise and adjusts behavior accordingly.

3. **`runAsyncCb` Function**:
   - This utility wraps `runAsync` to handle traditional node-style callbacks.
   - It checks if the last argument is a callback function and adjusts the arguments accordingly.
   - It executes `func`, passing the results to the provided callback function using Promise resolutions.

4. **Export**:
   - The `runAsync` function is exported and augmented with a `cb` property pointing to `runAsyncCb`.

Here's a simplified and structured rewrite of the code:

```javascript
// run-async.js

// Ensure Promise support
if (typeof Promise === 'undefined') {
  var Promise = require('es6-promise').Promise;
}

function runAsync(func, customAsync) {
  return function(...args) {
    const self = this;
    let err = false;

    const callback = (err, result) => {
      if (err) {
        return callback.promise.reject(err);
      }
      return callback.promise.resolve(result);
    };

    callback.promise = new Promise((resolve, reject) => {
      callback.promise = { resolve, reject };
    });

    // Define async property
    Object.defineProperty(self, 'async', {
      value: () => callback,
      enumerable: false
    });

    if (customAsync) {
      Object.defineProperty(self, customAsync, {
        value: () => callback,
        enumerable: false
      });
    }

    try {
      const result = func.apply(self, args);
      if (result && typeof result.then === 'function') {
        result.then(callback.promise.resolve, callback.promise.reject);
      } else if (!customAsync && !err && func.length < args.length + 1) {
        callback.promise.resolve(result);
      }
    } catch (error) {
      callback.promise.reject(error);
    }

    return callback.promise;
  };
}

function runAsyncCb(func) {
  return function(...args) {
    const self = this;
    const callback = typeof args[args.length - 1] === 'function' ? args.pop() : () => {};

    runAsync(func).apply(self, args)
      .then(result => callback(null, result))
      .catch(err => callback(err));
  };
}

runAsync.cb = runAsyncCb;

module.exports = runAsync;
```