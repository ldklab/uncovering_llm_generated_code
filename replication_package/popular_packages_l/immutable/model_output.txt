The functionality described in the README.md is for a Node.js package called Immutable.js. This package provides a set of immutable and persistent data structures for JavaScript to facilitate simpler application development by avoiding mutable state. Key features and functionalities include:

1. **Unchanging Structures**: Once created, immutable data structures cannot be changed, ensuring consistent data handling without defensive copying.
  
2. **Persistent Data Structures**: Operations on persistent data structures return a new structure rather than modifying the existing one, thereby mimicking mutation without changing the original data.
  
3. **Efficient Structure Sharing**: Utilizes structural sharing via hash and vector tries for performance optimization, minimizing data copying.

4. **Immutable Collections**: Provides a variety of immutable collections like `List`, `Map`, `Set`, among others, with methods that simulate mutations.

5. **Lazy Sequences**: Lazy evaluation in sequences (`Seq`) for efficient chaining of operations like `map` and `filter`.

6. **Nested Structures**: Supports deep data structures, with utilities like `getIn` and `setIn` for nested operations.

7. **Equality Based on Value**: Collections are compared based on value rather than reference.

8. **Batch Mutations**: Use `withMutations` to apply a series of changes efficiently.

9. **Seamless Integration**: Compatible with JavaScript's native collections and can convert to/from raw JavaScript objects.

10. **TypeScript Support**: Includes type definitions for TypeScript use.

Below is a simple implementation of some of the basic immutable operations described above such as creating an immutable `Map` and `List`, performing mutations that return new instances, and demonstrating value-based equality.

```javascript
// Node.js package for basic Immutable.js functionality (subset)

class ImmutableMap {
  constructor(initialObject) {
    this._data = initialObject || {};
  }

  get(key) {
    return this._data[key];
  }

  set(key, value) {
    if (this._data[key] === value) return this; // Return original if no change
    const newData = { ...this._data, [key]: value };
    return new ImmutableMap(newData);
  }

  equals(otherMap) {
    const thisKeys = Object.keys(this._data);
    const otherKeys = Object.keys(otherMap._data);
    if (thisKeys.length !== otherKeys.length) return false;
    return thisKeys.every(key => this._data[key] === otherMap._data[key]);
  }
}

class ImmutableList {
  constructor(initialArray) {
    this._data = initialArray || [];
  }

  get(index) {
    return this._data[index];
  }

  push(...values) {
    return new ImmutableList([...this._data, ...values]);
  }

  unshift(...values) {
    return new ImmutableList([...values, ...this._data]);
  }

  concat(...lists) {
    return new ImmutableList(this._data.concat(...lists.map(list => list._data)));
  }
}

// Example usage:
const map1 = new ImmutableMap({ a: 1, b: 2, c: 3 });
const map2 = map1.set('b', 50);
console.log(map1.get('b')); // 2
console.log(map2.get('b')); // 50

const list1 = new ImmutableList([1, 2, 3]);
const list2 = list1.push(4, 5, 6);
console.log(list2.get(3)); // 4

module.exports = {
  ImmutableMap,
  ImmutableList,
};
```

This code provides a basic version of the immutable Map and List structures described in the README, demonstrating how to apply non-destructive updates and comparisons by value. The examples show how a new Map is returned when attempting to set a different value, embracing immutability principles.