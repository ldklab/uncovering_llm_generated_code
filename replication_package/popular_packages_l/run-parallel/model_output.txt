The functionality described in the `run-parallel` Node.js package README.md is a utility that allows you to execute multiple asynchronous functions in parallel. Here’s how it works:

1. **Parallel Execution**: The core feature is to run an array (or object) of functions in parallel. Each function must be asynchronous and follow the Node.js callback pattern, which receives a callback as its argument. Once a function completes its operation, it must invoke `callback(err, result)`, where `err` represents an error if one occurred, or `null` otherwise, and `result` is the result of the function's operation.

2. **Error Handling**: If any function in the array (or object) passes an error to its callback, the main callback is immediately called with that error, halting the execution of the remaining tasks. 

3. **Results Collection**: When all functions have completed successfully, the final callback is invoked with the results. If using an array of tasks, results are returned in an array. If using an object, results are returned in an object, where each key in the object corresponds to a task's result.

4. **Usage Flexibility**: The module can handle both arrays and objects of tasks, providing flexibility in how results can be organized and accessed.

5. **Integration**: Designed to work seamlessly in both Node.js environments and the browser, making it versatile for various applications.

Here’s a possible implementation of the described functionality:

```javascript
function parallel(tasks, callback) {
  if (typeof tasks !== 'object' || tasks === null) {
    throw new Error('First argument to parallel must be an object or array');
  }
  
  callback = callback || function () {};

  const isArray = Array.isArray(tasks);
  const results = isArray ? [] : {};
  const keys = Object.keys(tasks);
  let remaining = keys.length;

  if (remaining === 0) {
    return callback(null, results);
  }

  function taskCallback(indexOrKey, err, result) {
    if (err) {
      callback(err);
      callback = function () {}; // Nullifying callback to prevent multiple calls
      return;
    }
    
    results[indexOrKey] = result;
    remaining -= 1;

    if (remaining === 0) {
      callback(null, results);
    }
  }

  keys.forEach((key, index) => {
    const task = tasks[key];
    try {
      task((err, result) => taskCallback(isArray ? index : key, err, result));
    } catch (err) {
      taskCallback(isArray ? index : key, err);
    }
  });
}

module.exports = parallel;

// Example usage:
parallel([
  function (callback) {
    setTimeout(() => callback(null, 'one'), 200);
  },
  function (callback) {
    setTimeout(() => callback(null, 'two'), 100);
  }
], function (err, results) {
  if (err) {
    return console.error(err);
  }
  console.log(results); // ['one', 'two']
});

parallel({
  task1: function (callback) {
    setTimeout(() => callback(null, 'one'), 200);
  },
  task2: function (callback) {
    setTimeout(() => callback(null, 'two'), 100);
  }
}, function (err, results) {
  if (err) {
    return console.error(err);
  }
  console.log(results); // { task1: 'one', task2: 'two' }
});
```