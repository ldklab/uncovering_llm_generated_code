The provided Node.js code defines an atomic file writing module with both asynchronous and synchronous functions, designed to ensure that data is written to a file in a reliable and consistent way. The module exports two functions: `writeFileAtomic` for asynchronous operations and `writeFileAtomicSync` for synchronous operations. Here's the breakdown of the functionality:

1. **Dependencies**: The module uses the `fs` module for file operations, `path` for handling file paths, and `crypto` for generating unique identifiers for temporary files.

2. **Utility Functions**:
   - **`murmurhex()`**: This function generates a unique hash using the MD5 algorithm. It combines the arguments (filename, process ID, and current timestamp) to create a distinctive temporary filename.
   
3. **Asynchronous Function - `writeFileAtomic()`**:
   - Accepts parameters: `filename` (target file path), `data` (data to write), `options` (optional configurations), and an optional `callback`.
   - Creates a temporary file by appending a unique hash to the filename.
   - Writes data to the temporary file.
   - Optionally synchronizes the file (based on `fsync` option).
   - Optionally changes ownership (based on `chown` option).
   - Renames the temporary file to the target filename to achieve atomic write.
   - Uses try-catch for error handling, deleting the temporary file if an error occurs.

4. **Synchronous Function - `writeFileAtomicSync()`**:
   - Similar to the asynchronous counterpart, but operations are performed synchronously.
   - Uses `fs.writeFileSync`, `fs.fdatasyncSync` (or `fs.fsyncSync`), `fs.chownSync`, and `fs.renameSync` for file operations.
   - Uses try-catch for error handling like in the asynchronous function.

Here is the rewritten code:

```javascript
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { promisify } = require('util');

const writeFile = promisify(fs.writeFile);
const rename = promisify(fs.rename);
const chown = promisify(fs.chown);
const unlink = promisify(fs.unlink);
const fdatasync = promisify(fs.fdatasync || fs.fsync);

function generateUniqueHash(filename, pid, timestamp) {
  const hash = crypto.createHash('md5');
  hash.update([filename, pid, timestamp].join(','));
  return hash.digest('hex');
}

async function writeFileAtomic(filename, data, options = {}, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  const opts = {
    encoding: 'utf8',
    fsync: true,
    ...options
  };

  if (typeof options === 'string') {
    opts.encoding = options;
  }

  const tmpFilename = `${filename}.${generateUniqueHash(filename, process.pid, new Date().getTime())}`;
  
  try {
    await writeFile(tmpFilename, data, { encoding: opts.encoding, mode: opts.mode });

    if (opts.fsync) {
      const fd = fs.openSync(tmpFilename, 'r');
      await fdatasync(fd);
      fs.closeSync(fd);
    }

    if (opts.chown && (opts.chown.uid !== undefined && opts.chown.gid !== undefined)) {
      await chown(tmpFilename, opts.chown.uid, opts.chown.gid);
    }

    await rename(tmpFilename, filename);
    if (callback) callback(null);
  } catch (err) {
    await unlink(tmpFilename).catch(() => {});
    if (callback) return callback(err);
    throw err;
  }
}

function writeFileAtomicSync(filename, data, options = {}) {
  const opts = {
    encoding: 'utf8',
    fsync: true,
    ...options
  };

  if (typeof options === 'string') {
    opts.encoding = options;
  }

  const tmpFilename = `${filename}.${generateUniqueHash(filename, process.pid, new Date().getTime())}`;

  try {
    fs.writeFileSync(tmpFilename, data, { encoding: opts.encoding, mode: opts.mode });

    if (opts.fsync) {
      const fd = fs.openSync(tmpFilename, 'r');
      fs.fdatasyncSync ? fs.fdatasyncSync(fd) : fs.fsyncSync(fd);
      fs.closeSync(fd);
    }

    if (opts.chown && (opts.chown.uid !== undefined && opts.chown.gid !== undefined)) {
      fs.chownSync(tmpFilename, opts.chown.uid, opts.chown.gid);
    }

    fs.renameSync(tmpFilename, filename);
  } catch (err) {
    fs.unlinkSync(tmpFilename);
    throw err;
  }
}

module.exports = writeFileAtomic;
module.exports.sync = writeFileAtomicSync;
```