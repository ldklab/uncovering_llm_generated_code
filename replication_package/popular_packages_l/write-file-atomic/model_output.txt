The `write-file-atomic` Node.js package provides a utility that extends the functionality of Node's `fs.writeFile` to make it atomic. An atomic write operation ensures that the file content is either fully written or not written at all, avoiding potential partial writes. Additionally, it allows setting file ownership (uid/gid) and handles concurrent write operations in a serialized manner.

### Key Features:
- **Atomic Operations**: Writes data to a file atomically by first creating a temporary file and, on success, renaming it to the target filename.
- **Ownership Setting**: Allows setting file ownership using `uid` and `gid`.
- **Serialization**: Queues concurrent writes to the same file to ensure they're executed serially.
- **Temporary File Naming**: Uses a unique name for the temporary file based on a hash.
- **Error Handling**: Attempts to clean up temporary files if an error occurs during the write process.
- **Options for Customization**: Supports options such as encoding, synchronizing to disk with fsync, setting file mode, and callbacks for tmpfile creation.

### Functions:
- **writeFileAtomic(filename, data, [options], [callback])**: Asynchronously write data to a file atomically.
  - **filename**: The target file name.
  - **data**: The data to be written, either as a string or a buffer.
  - **options**: An optional object to specify encoding, file mode, ownership (chown), fsync behavior, and callback for tmpfile creation.
    - **chown**: Object with `uid` and `gid` for setting file ownership.
    - **encoding**: Encoding for the data, defaults to 'utf8'.
    - **fsync**: Boolean, if false skips fsync call.
    - **mode**: File mode, defaults to the existing file mode.
    - **tmpfileCreated**: A function called when tmpfile is created.
  - **callback**: Optional, called on completion with an error as its argument.

- **writeFileAtomicSync(filename, data, [options])**: Synchronous version of writeFileAtomic.

Here's the implementation of the `write-file-atomic` package:

```javascript
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { promisify } = require('util');

const writeFile = promisify(fs.writeFile);
const rename = promisify(fs.rename);
const stat = promisify(fs.stat);
const chmod = promisify(fs.chmod);
const chown = promisify(fs.chown);
const unlink = promisify(fs.unlink);
const fdatasync = promisify(fs.fdatasync || fs.fsync);

function murmurhex() {
  const hash = crypto.createHash('md5');
  const args = Array.prototype.slice.call(arguments);
  hash.update(args.map(String).join(','));
  return hash.digest('hex');
}

async function writeFileAtomic(filename, data, options = {}, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  const opts = {
    encoding: 'utf8',
    fsync: true,
    ...options
  };

  if (typeof options === 'string') {
    opts.encoding = options;
  }

  const tmpFilename = `${filename}.${murmurhex(filename, process.pid, new Date().getTime())}`;
  
  try {
    await writeFile(tmpFilename, data, { encoding: opts.encoding, mode: opts.mode });

    if (typeof opts.tmpfileCreated === 'function') {
      opts.tmpfileCreated(tmpFilename);
    }

    if (opts.fsync) {
      const fd = fs.openSync(tmpFilename, 'r');
      await fdatasync(fd);
      fs.close(fd, (err) => {
        if (err) throw err;
      });
    }

    if (opts.chown && (opts.chown.uid !== undefined && opts.chown.gid !== undefined)) {
      await chown(tmpFilename, opts.chown.uid, opts.chown.gid);
    }

    await rename(tmpFilename, filename);
  } catch (err) {
    await unlink(tmpFilename).catch(() => {}); 
    if (callback) return callback(err);
    throw err;
  }

  if (callback) callback(null);
}

function writeFileAtomicSync(filename, data, options = {}) {
  const opts = {
    encoding: 'utf8',
    fsync: true,
    ...options
  };

  if (typeof options === 'string') {
    opts.encoding = options;
  }

  const tmpFilename = `${filename}.${murmurhex(filename, process.pid, new Date().getTime())}`;

  try {
    fs.writeFileSync(tmpFilename, data, { encoding: opts.encoding, mode: opts.mode });

    if (opts.fsync) {
      const fd = fs.openSync(tmpFilename, 'r');
      fs.fdatasyncSync ? fs.fdatasyncSync(fd) : fs.fsyncSync(fd);
      fs.closeSync(fd);
    }

    if (opts.chown && (opts.chown.uid !== undefined && opts.chown.gid !== undefined)) {
      fs.chownSync(tmpFilename, opts.chown.uid, opts.chown.gid);
    }

    fs.renameSync(tmpFilename, filename);
  } catch (err) {
    fs.unlinkSync(tmpFilename);
    throw err;
  }
}

module.exports = writeFileAtomic;
module.exports.sync = writeFileAtomicSync;
```
