The d3-scale package provides a comprehensive set of tools for mapping data values to visual display dimensions, which is fundamental in data visualization. These "scales" are primarily used to convert domain values (data) to corresponding range values (visual representation such as position, color, size, etc.). The package supports both continuous and discrete data mappings using various scale types tailored for specific use cases:

### Continuous Scales:
1. **Linear Scale**: Maps continuous input to continuous output with a linear relationship. It supports inversion and interpolation for precise interactions.
2. **Power Scale**: Similar to linear, but applies an exponential transformation to the input value.
3. **Logarithmic Scale**: Uses a logarithmic transformation, requires positive or strictly negative domains.
4. **Identity, Radial, Time Scales**: These handle specific transformations, such as maintaining identity through an axis or handling temporal data.

### Sequential and Diverging Scales:
- **Sequential Scales**: Primarily used for continuous input producing output from a fixed range.
- **Diverging Scales**: Used when data can have both negative and positive deviations from a central point.

### Quantize, Quantile, and Threshold Scales:
- **Quantize**: Divides the continuous domain into segments and maps them to discrete values.
- **Quantile**: Maps data quantiles to discrete output based on supplied samples.
- **Threshold**: Maps continuous input ranges divided at custom thresholds to discrete output values.

### Ordinal Scales:
- **Ordinal**: Maps discrete input domains (like categories) to discrete range values (e.g. colors).
- **Band and Point Scales**: Used to place elements on an axis, such as bars in a bar chart, by dividing the range into uniform segments.

### API Features:
- **Domain and Range**: Functions to set input domain and output range.
- **Inversion (for some scales)**: Retrieve the input value for an output value, useful for reverse-mapping.
- **Ticks and Formats**: Generate human-readable scale tick marks.

The package relies on several features like clamping, unknown value handling, rounding, and interpolation customization to provide robust and flexible data-to-visual mapping.

Below is a basic implementation that demonstrates linear scaling without the entire d3 library.

```javascript
class LinearScale {
  constructor(domain = [0, 1], range = [0, 1]) {
    this.domain = domain;
    this.range = range;
    this.clampFlag = false;
  }

  // Setting or getting domain
  setDomain(domain) {
    this.domain = domain;
    return this;
  }

  getDomain() {
    return this.domain;
  }

  // Setting or getting range
  setRange(range) {
    this.range = range;
    return this;
  }

  getRange() {
    return this.range;
  }

  // Clamping setting
  clamp(flag = true) {
    this.clampFlag = flag;
    return this;
  }

  // Scale function
  scale(value) {
    const [d0, d1] = this.domain;
    const [r0, r1] = this.range;
    const t = (value - d0) / (d1 - d0); // Normalize the domain value
    let result = r0 + t * (r1 - r0); // Scale it to the range

    if (this.clampFlag) {
      result = Math.max(r0, Math.min(r1, result));
    }

    return result;
  }

  // Invert function
  invert(value) {
    const [d0, d1] = this.domain;
    const [r0, r1] = this.range;
    const t = (value - r0) / (r1 - r0); // Normalize the range value
    let result = d0 + t * (d1 - d0); // Scale it to the domain
    return result;
  }

  // Generate tick values
  ticks(count = 10) {
    const [d0, d1] = this.domain;
    const step = (d1 - d0) / count;
    return Array.from({ length: count + 1 }, (_, i) => d0 + i * step);
  }

  // Format tick values
  tickFormat(count = 10, formatter = (d) => d.toFixed(2)) {
    return (d) => formatter(d);
  }
}

// Example usage:
const xScale = new LinearScale([10, 130], [0, 960]);
console.log(xScale.scale(20)); // Output: 80
console.log(xScale.invert(80)); // Output: 20
console.log(xScale.ticks()); // Generate ticks
```

This simplistic implementation provides the core of what a linear scale would offer, allowing for scaling, mapping, and inversion of values between a defined domain and range. This package can be expanded to include more scale types and options as described in the README.