The provided Node.js code defines a `LinearScale` class that helps transform numerical values from one range (domain) to another range (range). The class includes methods to set and get the domain and range, apply clamping to restrict scaled values within the range, scale values from the domain to the range and inversely, generate evenly spaced tick values within the domain, and format tick values with a custom formatter. The `scale` method normalizes a value from the domain and maps it linearly to the range, optionally applying clamping.

Here's the rewritten code:

```javascript
class LinearScale {
  constructor(domain = [0, 1], range = [0, 1]) {
    this.domain = domain;
    this.range = range;
    this.clampFlag = false;
  }

  setDomain(domain) {
    this.domain = domain;
    return this;
  }

  getDomain() {
    return this.domain;
  }

  setRange(range) {
    this.range = range;
    return this;
  }

  getRange() {
    return this.range;
  }

  clamp(flag = true) {
    this.clampFlag = flag;
    return this;
  }

  scale(value) {
    const [d0, d1] = this.domain;
    const [r0, r1] = this.range;
    const t = (value - d0) / (d1 - d0);
    let result = r0 + t * (r1 - r0);

    if (this.clampFlag) {
      result = Math.max(r0, Math.min(r1, result));
    }

    return result;
  }

  invert(value) {
    const [d0, d1] = this.domain;
    const [r0, r1] = this.range;
    const t = (value - r0) / (r1 - r0);
    return d0 + t * (d1 - d0);
  }

  ticks(count = 10) {
    const [d0, d1] = this.domain;
    const step = (d1 - d0) / count;
    return Array.from({ length: count + 1 }, (_, i) => d0 + i * step);
  }

  tickFormat(count = 10, formatter = (d) => d.toFixed(2)) {
    return (d) => formatter(d);
  }
}

// Example usage:
const xScale = new LinearScale([10, 130], [0, 960]);
console.log(xScale.scale(20)); // Output: 80
console.log(xScale.invert(80)); // Output: 20
console.log(xScale.ticks()); // Generate ticks
```