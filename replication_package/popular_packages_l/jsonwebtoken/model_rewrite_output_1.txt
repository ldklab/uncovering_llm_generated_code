The provided Node.js code defines a module for creating, signing, and verifying JSON Web Tokens (JWTs). Key features of this module include:

1. **Algorithm Support:** It lists cryptographic algorithms used for signing by mapping JWT algorithms to OpenSSL algorithms.
2. **Custom Error Classes:**
   - `JsonWebTokenError`: Base class for JWT-related errors.
   - `TokenExpiredError`: Error for expired tokens.
   - `NotBeforeError`: Error for tokens not yet valid (based on "nbf" claim).
3. **Signing JWTs (`sign` function):** 
   - Generates a JWT signature using the specified algorithm, private key, and payload.
   - Provides both synchronous and asynchronous signing options.
4. **Verifying JWTs (`verify` function):**
   - Checks token validity: well-formed, correct signature, and valid claims (e.g., expiration, "nbf").
   - Provides callback-based, asynchronous verification.
5. **Decoding JWTs (`decode` function):**
   - Parses a token to extract and optionally return both header and payload without validation.
6. **Exports:** The module exports signing, verification, decoding functions, and custom error classes for use in other parts of an application.

Here's a rewrite of the code based on this explanation:

```javascript
const crypto = require('crypto');
const jws = require('jws');

const algorithms = {
  HS256: 'sha256',
  HS384: 'sha384',
  HS512: 'sha512',
  RS256: 'RSA-SHA256',
  RS384: 'RSA-SHA384',
  RS512: 'RSA-SHA512',
  ES256: 'ecdsa-with-SHA256',
  ES384: 'ecdsa-with-SHA384',
  ES512: 'ecdsa-with-SHA512'
};

class JsonWebTokenError extends Error {
  constructor(message, error) {
    super(message);
    this.name = 'JsonWebTokenError';
    this.inner = error;
  }
}

class TokenExpiredError extends JsonWebTokenError {
  constructor(message, expiredAt) {
    super(message);
    this.name = 'TokenExpiredError';
    this.expiredAt = expiredAt;
  }
}

class NotBeforeError extends JsonWebTokenError {
  constructor(message, date) {
    super(message);
    this.name = 'NotBeforeError';
    this.date = date;
  }
}

function sign(payload, secretOrPrivateKey, options = {}, callback) {
  const header = { alg: options.algorithm || 'HS256', typ: 'JWT' };

  if (!secretOrPrivateKey) throw new JsonWebTokenError('secretOrPrivateKey must have a value');

  const signatureFunction = () => jws.sign({
    header,
    payload: JSON.stringify(payload),
    secret: secretOrPrivateKey,
    encoding: 'utf8',
  });

  if (!callback) return signatureFunction();

  process.nextTick(() => {
    try {
      const signature = signatureFunction();
      callback(null, signature);
    } catch (err) {
      callback(err);
    }
  });
}

function verify(token, secretOrPublicKey, options = {}, callback) {
  if (!token || !secretOrPublicKey) {
    const error = new JsonWebTokenError(token ? 'Secret or public key must be provided.' : 'jwt must be provided');
    return callback ? callback(error) : undefined;
  }

  const decodedToken = decode(token, { complete: true });

  if (!decodedToken) return callback ? callback(new JsonWebTokenError('invalid token')) : undefined;

  const { header, payload, signature } = decodedToken;
  const isVerified = crypto.createVerify(algorithms[header.alg])
    .update(`${header}.${payload}`, 'utf8')
    .verify(secretOrPublicKey, signature, 'base64');

  if (!isVerified) return callback ? callback(new JsonWebTokenError('invalid signature')) : undefined;

  const currentTime = Math.floor(Date.now() / 1000);
  if (payload.exp && currentTime >= payload.exp) 
    return callback ? callback(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000))) : undefined;

  if (payload.nbf && currentTime < payload.nbf) 
    return callback ? callback(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000))) : undefined;

  if (callback) callback(null, payload);
  return payload;
}

function decode(token, options = {}) {
  try {
    const decoded = jws.decode(token);
    if (!decoded) throw new JsonWebTokenError('invalid token');

    const payload = JSON.parse(Buffer.from(decoded.payload, 'base64').toString('utf8'));

    if (options.complete) {
      return { header: decoded.header, payload, signature: decoded.signature };
    }

    return payload;
  } catch (err) {
    throw new JsonWebTokenError('invalid token', err);
  }
}

module.exports = {
  sign,
  verify,
  decode,
  JsonWebTokenError,
  TokenExpiredError,
  NotBeforeError,
};
```