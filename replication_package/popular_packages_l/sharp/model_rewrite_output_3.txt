The provided Node.js code is an image processing utility using the `sharp` library. This code demonstrates various functionalities of the `sharp` package, which allows high-speed image manipulation. Here's a breakdown of the functionalities shown in the code:

1. **Resize Image using Callback**: The `resizeImageCallback` function takes an image buffer as input, resizes the image to 320x240 pixels, and outputs it as a WebP file. The process is done asynchronously, and a callback function is used to handle the result or any error.

2. **Resize Image using Promise**: The `resizeImagePromise` function resizes an image from a file path by rotating it, setting its width to 200 pixels, and saving it as a JPEG. Promises are used to handle the asynchronous operation.

3. **Create an Image using Async/Await**: The `createSemiTransparentImage` function creates a new image of size 48x48 pixels with a semi-transparent red background using async/await. This demonstrates chaining asynchronous operations using modern JavaScript syntax.

4. **Process Image Stream**: The `processImageStream` function demonstrates stream processing by reading from a readable stream, applying a rounded corner effect, and writing to a writable stream. This is done using SVG for the rounded corners and `sharp` for image manipulation.

Here is the rewritten code based on the above explanation:

```json
{
  "name": "sharp-image-processor",
  "version": "1.0.0",
  "description": "A high-speed Node.js image processing package using libvips",
  "main": "index.js",
  "dependencies": {
    "sharp": "^0.31.3"
  },
  "devDependencies": {},
  "scripts": {
    "start": "node index.js"
  },
  "author": "Your Name",
  "license": "Apache-2.0"
}
```

```javascript
const sharp = require('sharp');

// Function to resize using callback
function resizeImageCallback(inputBuffer) {
  sharp(inputBuffer)
    .resize(320, 240)
    .toFile('output.webp', (err, info) => {
      if (err) {
        console.error('Error during resizing:', err);
      } else {
        console.log('Image successfully resized:', info);
      }
    });
}

// Function to resize using Promises
function resizeImagePromise(filePath) {
  return sharp(filePath)
    .rotate()
    .resize(200)
    .jpeg({ mozjpeg: true })
    .toBuffer()
    .then(data => {
      console.log('Promise-based resize complete');
    })
    .catch(err => {
      console.error('Error in Promise-based resize:', err);
    });
}

// Async/Await function to create an image
async function createSemiTransparentImage() {
  try {
    const buffer = await sharp({
      create: {
        width: 48,
        height: 48,
        channels: 4,
        background: { r: 255, g: 0, b: 0, alpha: 0.5 }
      }
    })
      .png()
      .toBuffer();
    console.log('Async/await image created:', buffer);
  } catch (err) {
    console.error('Error creating image:', err);
  }
}

// Stream-based processing function
function processImageStream(readableStream, writableStream) {
  const roundedCorners = Buffer.from(
    '<svg><rect x="0" y="0" width="200" height="200" rx="50" ry="50"/></svg>'
  );

  const roundedCornerResizer = sharp()
    .resize(200, 200)
    .composite([{ input: roundedCorners, blend: 'dest-in' }])
    .png();

  readableStream
    .pipe(roundedCornerResizer)
    .pipe(writableStream);
}

// Example usage
resizeImageCallback(Buffer.from('inputBufferData'));
resizeImagePromise('input.jpg');
createSemiTransparentImage();
```