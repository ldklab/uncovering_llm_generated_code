The `fastq` package is a fast, in-memory work queue for Node.js. It is designed to efficiently manage and process tasks based on a specified concurrency level, allowing for both callback and promise-based APIs for task processing. Here's a breakdown of its functionality:

### Features:
1. **Task Queue**: Allows adding tasks to a queue and processes them using a worker function.
2. **Concurrency**: Supports executing a specified number of tasks in parallel.
3. **Callback and Promise APIs**: Provides two APIs for task completion handling â€” callback-based and promise-based.
4. **Context Binding**: Offers the ability to set a context (`this` value) for the worker function.
5. **Queue Management**: Includes advanced queue management functions:
   - Add tasks to the queue (`push` and `unshift`).
   - Pause and resume task processing (`pause` and `resume`).
   - Inspect queue status (`idle`, `length`, and `getQueue`).
   - Remove tasks from the queue (`kill` and `killAndDrain`).
   - Manage task errors and completion (`error`, `drain`, `empty`, `saturated`).

### API Methods:
- **Creation**: `fastqueue([that], worker, concurrency)` and `fastqueue.promise([that], worker, concurrency)`.
- **Task Management**: `push(task, done)`, `unshift(task, done)` for adding tasks.
- **Queue Control**: `pause()`, `resume()`, `kill()`, `killAndDrain()`.
- **Queue Inspection**: `idle()`, `length()`, `getQueue()`.
- **Callbacks**: `error()`, `drain`, `empty`, `saturated`.
- **Promise-based Methods**: `queue.push(task) => Promise`, `queue.unshift(task) => Promise`, `queue.drained() => Promise`.

Here's the code implementing the `fastq` package:

```javascript
'use strict';

class FastQueue {
  constructor(that, worker, concurrency, usePromises = false) {
    this.that = that;
    this.worker = worker;
    this.concurrency = concurrency;
    this.queue = [];
    this.workers = 0;
    this.paused = false;
    this.drain = () => {};
    this.empty = () => {};
    this.saturated = () => {};
    this.errorHandler = null;
    this.usePromises = usePromises;
  }

  push(task, done) {
    return new Promise((resolve, reject) => {
      const callback = (err, result) => {
        if (this.errorHandler) this.errorHandler(err, task);
        if (done) return done(err, result);
        if (err) return reject(err);
        resolve(result);
      };

      this.queue.push({ task, callback });
      process.nextTick(() => this._process());
    });
  }

  unshift(task, done) {
    return new Promise((resolve, reject) => {
      const callback = (err, result) => {
        if (this.errorHandler) this.errorHandler(err, task);
        if (done) return done(err, result);
        if (err) return reject(err);
        resolve(result);
      };

      this.queue.unshift({ task, callback });
      process.nextTick(() => this._process());
    });
  }

  pause() {
    this.paused = true;
  }

  resume() {
    this.paused = false;
    this._process();
  }

  idle() {
    return this.workers === 0 && this.queue.length === 0;
  }

  length() {
    return this.queue.length;
  }

  getQueue() {
    return this.queue.slice();
  }

  kill() {
    this.queue.length = 0;
    this.drain = () => {};
  }

  killAndDrain() {
    this.kill();
    this.drain();
  }

  error(handler) {
    this.errorHandler = handler;
  }

  _process() {
    if (this.paused || this.workers >= this.concurrency) return;
    const taskObj = this.queue.shift();
    if (!taskObj) return;
    if (this.queue.length === 0) this.empty();

    this.workers += 1;
    if (this.workers === this.concurrency) this.saturated();

    const { task, callback } = taskObj;
    const workerFn = this.worker.bind(this.that);

    if (this.usePromises) {
      workerFn(task)
        .then(result => {
          callback(null, result);
          this._complete();
        })
        .catch(err => {
          callback(err);
          this._complete();
        });
    } else {
      workerFn(task, (err, result) => {
        callback(err, result);
        this._complete();
      });
    }
  }

  _complete() {
    this.workers -= 1;
    if (this.idle()) this.drain();
    this._process();
  }
}

function fastqueue(that, worker, concurrency) {
  return new FastQueue(that, worker, concurrency, false);
}

fastqueue.promise = function(that, worker, concurrency) {
  return new FastQueue(that, worker, concurrency, true);
};

module.exports = fastqueue;
```
