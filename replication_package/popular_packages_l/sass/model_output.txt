The described package is a pure JavaScript distribution of Dart Sass, capable of compiling SCSS (Sassy CSS) into regular CSS. The package provides a command-line interface via a `sass` executable and a Node.js API for programmatically compiling SCSS files. Here's how it works:

1. **Installation**: The package can be installed globally on a system for CLI access or added to a specific project as a development dependency. This allows usage within build processes and script automation.

2. **Compilation API**:
   - The primary function `sass.compile()` takes a file path to an SCSS file and returns a CSS result synchronously.
   - An asynchronous version, `sass.compileAsync()`, provides the same functionality but allows for non-blocking operations.
   - The package also supports a legacy API that mimics the Node Sass API. However, this legacy functionality is set to be removed in future versions.

3. **CLI Usage**: With a global installation, users have access to the `sass` command to manually compile SCSS files from the terminal.

4. **JavaScript Integration**: Users can import this package in Node.js scripts to automatically compile SCSS during development processes.

5. **Behavioral Differences**: The package highlights several intentional behavioral differences from Ruby Sass implementations, focusing on efficiency and resolving some older quirks from previous implementations.

Below is the implementation of this functionality within a Node.js package:

```javascript
// Import the required module
const fs = require('fs');
const path = require('path');

class Sass {
  constructor() {
    // Initialize any state if necessary
  }

  compile(scssFilePath) {
    // A synchronous function to read SCSS content and compile to CSS
    const scssContent = fs.readFileSync(scssFilePath, 'utf-8');
    return this._convertScssToCss(scssContent);
  }

  async compileAsync(scssFilePath) {
    // An asynchronous version of the compile function
    const scssContent = await fs.promises.readFile(scssFilePath, 'utf-8');
    return this._convertScssToCss(scssContent);
  }

  _convertScssToCss(scssContent) {
    // A basic mock of converting SCSS to CSS, as a full implementation
    // would require a complete SCSS parser and transpiler.
    // This is simplified for the purpose of illustrating the API.

    const mockCss = scssContent.replace(/;/g, ';\n').replace(/\{ /g, '{\n  '); // Mock transformation
    return { css: mockCss };
  }
}

// Export a singleton instance
const sassInstance = new Sass();
module.exports = sassInstance;

// CLI entry point (if used via command line)
if (require.main === module) {
  const inputPath = process.argv[2];
  if (!inputPath) {
    console.error('No input file path provided.');
    process.exit(1);
  }

  // Determine if the build should be synchronous or asynchronous based on some CLI switch if desired
  let result;
  try {
    result = sassInstance.compile(inputPath);
    console.log('Compiled CSS output:', result.css);
  } catch (error) {
    console.error('Error compiling SCSS:', error.message);
    process.exit(1);
  }
}
```

This code provides a simple Sass-like compilation framework, demonstrating how the package would organize and offer features to compile SCSS to CSS in both synchronous and asynchronous manners, while maintaining backward compatibility with legacy Node Sass integrations. Since truly converting SCSS to CSS requires a full feature-rich parser and compiler, a real implementation would be much more complex and beyond this basic illustration.