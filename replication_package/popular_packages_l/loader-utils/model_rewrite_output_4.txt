The Node.js code provided defines a utility module (`loader-utils.js`) designed to assist with resource management in a web development context, specifically for loaders which are part of a build process like Webpack. It includes several key functionalities:

1. **isUrlRequest**: Determines if a URL is requestable by checking if it does not begin with common non-request protocols such as `data:`, `chrome:`, or `http:`/`https:`.

2. **urlToRequest**: Converts a URL into a request path suitable for loading by handling module requests (prefixed with `~`), root-relative URLs, and relative URLs by defaulting to prefixing with `./`.

3. **interpolateName**: Constructs a file name to be used in the build process, supporting placeholder replacement with values like filename, path, hash, etc., based on options provided or inferred from the loader context. It allows dynamic name formatting using a pattern where placeholders are enclosed in square brackets (e.g., `[name]`, `[ext]`).

4. **getHashDigest**: Generates a hash digest for a given content buffer. Provides options for specifying the hash types, formats, and allows truncation to a specified length. It also ensures compatibility with safe characters when using base64.

Here's a possible rewrite of the code:

```javascript
// utils.js

const path = require('path');
const crypto = require('crypto');

const utils = {
  isUrlRequest(url) {
    return !/^data:|^chrome:|^https?:/.test(url);
  },

  urlToRequest(url, root = '') {
    if (url.startsWith('~')) return url.slice(1);
    if (root && url.startsWith('/')) {
      return root === '~' ? url.slice(1) : path.posix.join(root, url.slice(1));
    }
    return !/^\.\.?\/|^\//.test(url) ? `./${url}` : url;
  },

  interpolateName(loaderContext, name, options = {}) {
    const { resourcePath = '', resourceQuery = '' } = loaderContext;
    const context = options.context || process.cwd();
    const content = options.content || '';
    let regExp = options.regExp ? new RegExp(options.regExp) : null;

    const { ext, base: baseName, dir } = path.parse(resourcePath);
    const folderName = path.basename(dir);

    const contentHash = this.getHashDigest(Buffer.from(content), 'xxhash64', 'hex');

    const replacements = {
      '[ext]': ext.slice(1),
      '[name]': baseName,
      '[path]': path.relative(context, dir),
      '[folder]': folderName,
      '[query]': resourceQuery,
      '[contenthash]': contentHash,
      '[hash]': contentHash,
    };

    if (regExp) {
      const matches = resourcePath.match(regExp);
      if (matches) {
        matches.forEach((match, idx) => {
          replacements[`[${idx}]`] = match;
        });
      }
    }

    return name.replace(/\[(\w+)(?::(\w+))?(?::(\w+))?(?::(\d+))?\]/gi, (match, token, hashType, digestType, maxLength) => {
      if (replacements[match] !== undefined) return replacements[match];
      if (token === 'hash' || token === 'contenthash') {
        return this.getHashDigest(content, hashType || 'xxhash64', digestType || 'hex', Number(maxLength));
      }
      return match;
    });
  },

  getHashDigest(buffer, hashType = 'xxhash64', digestType = 'hex', maxLength) {
    const hash = crypto.createHash(hashType).update(buffer).digest(digestType);
    let digest = maxLength ? hash.slice(0, maxLength) : hash;
    if (digestType === 'base64safe') {
      digest = digest.replace(/[/+]/g, '_').replace(/=/g, '');
    }
    return digest;
  },
};

module.exports = utils;
```