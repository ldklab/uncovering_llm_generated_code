The UAParser.js library is designed to parse user-agent strings to extract details about the client's browser, operating system (OS), device type, CPU architecture, and rendering engine. It can be utilized in both browser environments (where `window.navigator.userAgent` can be automatically used) and Node.js environments (where the user-agent string must be manually supplied, typically found in `request.headers["user-agent"]`).

Here's how the library operates:
- **Constructor**: When `UAParser` is invoked with the `new` keyword, it creates an instance that doesn't automatically parse any data. One must call methods to extract information from a user-agent string provided as a parameter.
- **Direct Function Call**: When called without `new`, `UAParser` acts as a function and directly returns the parsing results of an optional user-agent string input.
- **Methods**: The library provides several methods such as `getResult()`, `getBrowser()`, `getDevice()`, `getEngine()`, `getOS()`, `getCPU()`, `getUA()`, and `setUA(userAgent)` to access discrete sections of the parsed data or adjust the user-agent string in use.

The parsed result is an object containing details like:
- **ua**: The user-agent string.
- **browser**: Details the name and version of the browser.
- **cpu**: Architecture information.
- **device**: The type and model of the device.
- **engine**: Details the browser's engine.
- **os**: Name and version of the operating system.

### Node.js Package Code Implementation

```javascript
// ua-parser.js
class UAParser {
    constructor(userAgent = '', extensions = []) {
        this.uaString = userAgent || (typeof window !== "undefined" ? window.navigator.userAgent : '');
        this.extensions = extensions;
        this.result = {
            ua: this.uaString,
            browser: {},
            cpu: {},
            device: {},
            engine: {},
            os: {}
        };
        if (!userAgent && typeof window === 'undefined') {
            throw new Error('User-Agent string is required in Node.js');
        }
        if (userAgent) this.parseUA();
    }

    parseUA() {
        // Example parsing logic (to be replaced by real parsing regex and logic)
        this.result.browser.name = this.uaString.includes("Chrome") ? 'Chrome' : 'Unknown';
        this.result.os.name = this.uaString.includes("Windows") ? 'Windows' : 'Unknown';
    }

    getResult() {
        return this.result;
    }

    getBrowser() {
        return this.result.browser;
    }

    getCPU() {
        return this.result.cpu;
    }

    getDevice() {
        return this.result.device;
    }

    getEngine() {
        return this.result.engine;
    }

    getOS() {
        return this.result.os;
    }

    getUA() {
        return this.uaString;
    }

    setUA(userAgent) {
        this.uaString = userAgent;
        this.result.ua = userAgent;
        this.parseUA();
        return this;
    }
}

// If not using new keyword
function uaParserFacade(userAgent = '', extensions = []) {
    const parser = new UAParser(userAgent, extensions);
    return parser.getResult();
}

module.exports = uaParserFacade;
module.exports.UAParser = UAParser;

// Example Server (Node.js)
const http = require('http');
const UAParser = require('./ua-parser').UAParser;

http.createServer((req, res) => {
    const parser = new UAParser(req.headers['user-agent']);
    res.end(JSON.stringify(parser.getResult(), null, '  '));
}).listen(1337, '127.0.0.1');

console.log('Server running at http://127.0.0.1:1337/');

```

This mock setup offers the skeleton for UA parsing, illustrating instantiation, UA string setting, and result retrieval. For real-world applications, add regular expressions to accurately deal with varied UA strings.