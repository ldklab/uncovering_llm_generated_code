The `html-entities` library provides functions to encode and decode HTML special characters and entities. Its main functionalities include:

1. **Encoding Text to HTML Entities**: The `encode` function can replace HTML special characters and/or other character ranges with their corresponding HTML entity representations, depending on the options provided. The `mode` option specifies what type of characters to encode, while the `level` option determines which set of named references (HTML5, HTML4, or XML) to use. The `numeric` option can specify the numeric format (decimal or hexadecimal) when encoding entities.

2. **Decoding HTML Entities to Text**: The `decode` function converts HTML entities back to their corresponding characters. The `level` option influences which set of named references will be decoded. The `scope` option specifies how to treat entities without a semicolon.

3. **Decoding Single HTML Entities**: The `decodeEntity` function decodes a single HTML entity to its corresponding character. It also supports the `level` option to select the set of named references.

Overall, the library provides a fast and versatile way to handle HTML entity encoding and decoding with support for different HTML and XML standards.

Here's the code for the package:

```markdown
// Required Dependencies
const htmlCharacterMap = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&apos;',
  // Extend map for non-ASCII and other characters with named references as required
};
// Reverse map for decoding
const reverseHtmlCharacterMap = Object.entries(htmlCharacterMap).reduce(
  (acc, [key, value]) => ({ ...acc, [value]: key }),
  {}
);

// Helper function to encode text based on mode and level options
function encode(text, options = {}) {
  const { mode = 'specialChars', level = 'all', numeric = 'decimal' } = options;
  let entityMap = {};

  // Determine which characters to encode
  switch (mode) {
    case 'specialChars':
      entityMap = htmlCharacterMap;
      break;
    // Additional cases for other modes
  }
  return text.replace(
    /[<>&"']/g, // Regex should match characters from entityMap
    (char) => entityMap[char] || char
  );
}

// Helper function to decode text based on level and scope options
function decode(text, options = {}) {
  const { level = 'all', scope = 'body' } = options;
  let entityMap = reverseHtmlCharacterMap;

  // Determine replacements based on scope
  let regex = /&[^;\s]*;?/g; // Simple regex for entities
  return text.replace(regex, (entity) => entityMap[entity] || entity);
}

// Single entity decoder
function decodeEntity(entity, options = {}) {
  const { level = 'all' } = options;
  return reverseHtmlCharacterMap[entity] || entity;
}

export { encode, decode, decodeEntity };
```
