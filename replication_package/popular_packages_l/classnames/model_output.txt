The `classnames` utility is a simple JavaScript library used to conditionally join classNames together in a flexible and concise way. The primary function of this utility is to simplify the process of building dynamic classNames for HTML elements, especially useful in React components.

### Functionality:

1. **Argument Handling**: 
   - It can take any number of arguments, which could be strings or objects.
   - Strings directly represent class names to be added.
   - Objects represent conditionals where keys are class names and values are conditions. If the value is truthy, the key (class name) is included.

2. **Output**:
   - Returns a single string with space-separated class names based on the truthiness of the arguments.
   - Falsy values are ignored, meaning a class name that results in falsy conditions is excluded from the resultant string.

3. **Arrays**:
   - Arrays of class names will be recursively flattened.
   - Each element within the array follows the same rules (depending on whether it's a string or an object).

4. **Dynamic Class Names**:
   - Supports dynamic class names using computed property names, beneficial when dealing with styles that depend on variable states or conditions.

5. **Variants**:
   - **Dedupe Version**: Ensures that duplicate class names are removed from the result and that falsy classes specified later overwrite previous ones.
   - **Bind Version**: For use with CSS modules, mapping class names to an object to output the corresponding CSS-modules-translated class names.
  
6. **React Usage**:
   - The utility is especially useful in React.js applications to manage dynamic `className` props in a readable manner as opposed to direct string manipulation.

Here is a code implementation that mimics the described functionality of `classnames`:

```javascript
// classnames.js - implementation file
function classNames(...args) {
  const classes = [];

  args.forEach(arg => {
    if (!arg) return;

    const argType = typeof arg;

    if (argType === 'string' || argType === 'number') {
      classes.push(arg);
    } else if (Array.isArray(arg)) {
      classes.push(classNames(...arg));
    } else if (argType === 'object') {
      for (const key in arg) {
        if (Object.hasOwnProperty.call(arg, key) && arg[key]) {
          classes.push(key);
        }
      }
    }
  });

  return classes.join(' ');
}

classNames.bind = function(bindStyles) {
  return function(...args) {
    return classNames(...args.map(arg => {
      if (typeof arg === 'string' || typeof arg === 'number') {
        return bindStyles[arg];
      } else if (Array.isArray(arg)) {
        return arg.map(a => classNames.bind(bindStyles)(a));
      } else if (typeof arg === 'object') {
        const obj = {};
        for (const key in arg) {
          if (Object.hasOwnProperty.call(arg, key)) {
            obj[bindStyles[key] || key] = arg[key];
          }
        }
        return obj;
      }
      return arg;
    }));
  };
};

module.exports = classNames;

// tests/demo usage
const styles = {
  foo: 'abc',
  bar: 'def',
  baz: 'xyz',
};

// Example usage
console.log(classNames('foo', { bar: true, duck: false }, 'baz', { quux: true })); 
// Output: 'foo bar baz quux'

const cx = classNames.bind(styles);

console.log(cx('foo', ['bar'], { baz: true })); 
// Output: 'abc def xyz'
```