The functionality described in the `Keyv` Node.js package README is that of a general-purpose key-value storage library, offering a uniform API to manage data across multiple storage backends. Here are the key features and functionalities:

1. **Key-Value Store**: `Keyv` provides a consistent API to store and retrieve key-value pairs. By default, it uses in-memory storage but can be extended to various databases through storage adapters.

2. **Storage Adapters**: It supports multiple backends like Redis, MongoDB, SQLite, and more, via storage adapters. Each adapter can be accessed via a connection URI or can use an alternative backend that follows the `Map` API.

3. **TTL Support**: `Keyv` allows setting a TTL (Time-to-Live) for key-value pairs, making it suitable for cache implementations.

4. **Type Safety**: You can specify types at the instance or method level, enabling type-safe operations.

5. **Namespaces**: It supports namespaces to segregate data and avoid key collisions, allowing easier management and clearance of data subsets.

6. **Event Handling**: It extends `EventEmitter` to provide event hooks for errors and specific actions like clearing data or disconnecting.

7. **Hooks**: Users can define pre/post hooks for operations like `get`, `set`, and `delete`, enabling custom actions such as logging or manipulating data.

8. **Custom Serializers**: Custom serialization functions can be defined, offering flexibility in how data is stored and retrieved.

9. **Compression**: It can be integrated with compression tools to minimize storage space through third-party compression adapters.

10. **Iteration**: Provides an iterator to go through all key-value pairs in a namespace.

Here's a simplified implementation of a basic `Keyv` package:

```javascript
const { EventEmitter } = require('events');

class Keyv extends EventEmitter {
    constructor({ uri, store = new Map(), ttl, namespace = 'keyv', serialize = JSON.stringify, deserialize = JSON.parse } = {}) {
        super();
        this.store = store;
        this.ttl = ttl;
        this.namespace = namespace;
        this.serialize = serialize;
        this.deserialize = deserialize;
        this.useUri(uri);
    }

    useUri(uri) {
        if (uri) {
            const storeAdapter = require(`@keyv/${uri.split(':')[0]}`);
            this.store = new storeAdapter(uri);
        }
    }

    async set(key, value, ttl) {
        const namespacedKey = `${this.namespace}:${key}`;
        const storedValue = { value: this.serialize(value), expires: ttl ? Date.now() + ttl : null };
        await this.store.set(namespacedKey, storedValue);
        return true;
    }

    async get(key, { raw = false } = {}) {
        const namespacedKey = `${this.namespace}:${key}`;
        const storedValue = await this.store.get(namespacedKey);
        if (!storedValue) return undefined;
        if (!raw && storedValue.expires && Date.now() > storedValue.expires) {
            await this.delete(key);
            return undefined;
        }
        return raw ? storedValue : this.deserialize(storedValue.value);
    }

    async delete(key) {
        const namespacedKey = `${this.namespace}:${key}`;
        return this.store.delete(namespacedKey);
    }

    async clear() {
        for (const key of this.store.keys()) {
            if (key.startsWith(`${this.namespace}:`)) {
                await this.delete(key.split(':')[1]);
            }
        }
    }

    async *[Symbol.asyncIterator]() {
        for (const [key, value] of this.store.entries()) {
            if (key.startsWith(`${this.namespace}:`)) {
                yield [key.split(':')[1], this.deserialize(value.value)];
            }
        }
    }
}

module.exports = Keyv;

// Usage Example
const keyv = new Keyv({ uri: 'redis://localhost:6379' });
keyv.on('error', err => console.error('Connection Error', err));

// Example setting, getting, and deleting a key-value pair
(async () => {
    await keyv.set('foo', 'bar', 1000);
    console.log(await keyv.get('foo')); // 'bar'
    await keyv.delete('foo');
    console.log(await keyv.get('foo')); // undefined
})();
```

This code provides a basic skeleton where you can set, get, and delete key-value pairs, integrating any backing store adapter that follows the `Map` interface. It demonstrates the namespace capability and TTL as well. Additional storage adapters, compression features, and hooks as described in the original documentation can be built on this foundation.