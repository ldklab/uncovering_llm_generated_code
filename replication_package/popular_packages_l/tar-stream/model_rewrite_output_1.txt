The provided Node.js code creates a simple tar-like stream processing system. It is comprised of two primary functions: `pack` and `extract`.

1. **pack**: This function simulates the behavior of a packing system, similar to how files are added to a tarball. It returns a `PassThrough` stream object with two additional methods:
   - `entry`: This method creates a new `Entry` stream (a subclass of `PassThrough`) with a given header and optional data. The data, if provided, is immediately written and ended on the entry stream, which is then piped into the main pack stream (`output`). The header is an object containing information about the entry, such as its name and size.
   - `finalize`: This method ends the pack stream, indicating that no more entries will be added.

2. **extract**: The `extract` function simulates the process of extracting entries from the packed stream. It returns a `Writable` stream with:
   - A `_write` method that handles each passed entry by storing it in an `entries` array and then resuming and waiting for each entry to finish before calling the callback.
   - It listens for the `pipe` event to manually handle entries from a source stream by writing them to itself and ending upon completion.

In the example usage:
- A pack stream `p` is created, and a single entry with the name 'hello.txt' and data 'Hello world' is packed and then piped to a writable file stream ('example.tar') to simulate writing to a tar file.
- An extract stream `e` is created, and another pack stream `source` is used to simulate the packing of an entry. This source is then piped into the extract stream `e`, where the headers of the extracted entries are printed on completion.

Here is the rewritten code:

```javascript
// tar-stream.js
const { PassThrough, Writable } = require('stream');

// Simulated header and entry for packing example
class Entry extends PassThrough {
  constructor(header, callback) {
    super();
    this.header = header;
    process.nextTick(callback);
  }
}

// Creating a packing stream
const createPackStream = () => {
  const output = new PassThrough();

  output.entry = (header, data, callback) => {
    const entryStream = new Entry(header, callback);
    if (data) entryStream.end(data);
    entryStream.pipe(output, { end: false });
    return entryStream;
  };

  output.finalize = () => output.end();

  return output;
};

// Simulating extraction
const createExtractStream = () => {
  const extractStream = new Writable({ objectMode: true });
  extractStream.entries = [];

  extractStream._write = (entry, encoding, callback) => {
    extractStream.entries.push(entry);
    entry.resume();
    entry.on('end', callback);
  };

  extractStream.on('pipe', (src) => {
    src.unpipe(extractStream);
    for (const entry of src.entries) {
      extractStream.write(entry);
    }
    extractStream.end();
  });

  return extractStream;
};

module.exports = { pack: createPackStream, extract: createExtractStream };

// Example usage
const fs = require('fs');

// Packing example
const packStream = createPackStream();
packStream.entry({ name: 'hello.txt', size: 11 }, 'Hello world', (err) => {
  if (err) throw err;
  packStream.finalize();
});

packStream.pipe(fs.createWriteStream('example.tar'));

// Extracting example - placeholder for actual entry streams
const extractStream = createExtractStream();
const sourceStream = createPackStream();
sourceStream.entry({ name: 'test.txt' }, 'Test content').end();
sourceStream.finalize();

sourceStream.pipe(extractStream);
extractStream.on('finish', () => {
  console.log('Extracted entries:', extractStream.entries.map(entry => entry.header.name));
});
```