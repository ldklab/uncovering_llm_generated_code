The provided Node.js code creates a simple simulation of a tar-like packing and extraction system using streams. Here's a breakdown of the functionality:

1. **Entry Class**: 
   - This class extends `PassThrough`, a type of stream that simply passes data through.
   - When instantiated, it takes in a `header` object and a `callback` function. The `callback` is invoked using `process.nextTick`.

2. **Pack Functionality**: 
   - The `pack` function returns a `PassThrough` stream that acts as an output tar archive stream.
   - The `entry` method on this stream allows adding a new entry with a specified `header` and optional `data`. It creates a new `Entry` stream, writes the data to it, pipes it to the main output stream, and finally invokes the `callback`.
   - The `finalize` method ends the output stream.

3. **Extract Functionality**: 
   - The `extract` function returns a `Writable` stream that simulates extracting entries from a tar archive.
   - This writable stream maintains a list of `entries` and processes them with its `_write` method, which adds them to the list and calls a `callback` upon completion.
   - It listens for a `pipe` event, where it manually manages the piping, writing all entries from the source to itself, and then ends the stream.

4. **Example Usage**:
   - **Packing**: An example of creating a packed tar file with one entry `hello.txt` containing "Hello world". It's written to `example.tar`.
   - **Extracting**: The example demonstrates set up for extracting entries from a source, printing the names of entries once extraction is done. This part is simulated as it doesn't read from an actual tar file.

Here's a rewrite of the code:

```javascript
const { PassThrough, Writable } = require('stream');

class Entry extends PassThrough {
  constructor(header, callback) {
    super();
    this.header = header;
    process.nextTick(callback);
  }
}

const createPackStream = () => {
  const output = new PassThrough();

  output.entry = (header, data, callback) => {
    const entry = new Entry(header, callback);
    if (data) {
      entry.end(data);
    }
    entry.pipe(output, { end: false });
    return entry;
  };

  output.finalize = () => {
    output.end();
  };

  return output;
};

const createExtractStream = () => {
  const extractStream = new Writable({ objectMode: true });

  extractStream.entries = [];

  extractStream._write = (entry, encoding, callback) => {
    extractStream.entries.push(entry);
    entry.resume();
    entry.on('end', callback);
  };

  extractStream.on('pipe', (source) => {
    source.unpipe(extractStream);
    for (const entry of source.entries) {
      extractStream.write(entry);
    }
    extractStream.end();
  });

  return extractStream;
};

module.exports = { pack: createPackStream, extract: createExtractStream };

const fs = require('fs');

const packStream = createPackStream();
packStream.entry({ name: 'hello.txt', size: 11 }, 'Hello world', (err) => {
  if (err) throw err;
  packStream.finalize();
});

packStream.pipe(fs.createWriteStream('example.tar'));

const extractStream = createExtractStream();
const sourcePackStream = createPackStream();
sourcePackStream.entry({ name: 'test.txt' }, 'Test content').end();
sourcePackStream.finalize();

sourcePackStream.pipe(extractStream);
extractStream.on('finish', () => {
  console.log('Extracted entries:', extractStream.entries.map(entry => entry.header.name));
});
```