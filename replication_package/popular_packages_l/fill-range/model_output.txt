The `fill-range` package provides functionality to generate a sequence of numbers or letters in a specified range. It allows for specification of an optional step, enabling the generation of a sequence with specific increments. Additionally, it offers options to create a regex-compatible range string and customize each value in the generated sequence.

Key Features:
1. **Range Generation**: Generate an array of numbers or letters from a specified start (`from`) to an end (`to`), including options for sequential steps.
2. **Steps (Increments)**: Define a specific step to control the sequence incrementation.
3. **Alphabetical Support**: Capable of generating both numerical and alphabetical sequences.
4. **Negative Ranges**: Supports negative values in numerical sequences.
5. **String and Number Handling**: Inputs and outputs can be either strings or numbers, with options to stringify results.
6. **Regex-compatible Range**: Convert the range into a regex-compatible string for pattern matching.
7. **Customization**: Offers a transform function to modify each element of the output.

Examples demonstrate filling numeric and alphabetic ranges with and without steps, using invalid range handling, and applying string transformations.

Here is the code implementing the stated functionality:

```javascript
function fillRange(from, to, step = 1, options = {}) {
  const isNumber = value => !isNaN(value);
  const isAlphabet = value => /^[a-zA-Z]$/.test(value);

  const createSequence = (start, end, step, transform) => {
    const result = [];
    for (let i = start; i <= end; i += step) {
      result.push(transform ? transform(i) : i);
    }
    return result;
  };

  const toRegex = arr => arr.join('|');

  const transformValue = options.transform || (v => v);

  if (isNumber(from) && isNumber(to)) {
    from = Number(from);
    to = Number(to);
    if (options.toRegex) {
      return `[${from}-${to}]`;
    }
    const values = createSequence(from, to, step, transformValue);
    return options.stringify ? values.map(String) : values;
  }

  if (isAlphabet(from) && isAlphabet(to)) {
    from = from.charCodeAt(0);
    to = to.charCodeAt(0);
    const values = createSequence(from, to, step, charCode => transformValue(String.fromCharCode(charCode)));
    if (options.toRegex) {
      return `[${String.fromCharCode(from)}-${String.fromCharCode(to)}]`;
    }
    return values;
  }

  if (options.strictRanges) {
    throw new RangeError('Invalid range');
  }

  return null;
}

module.exports = fillRange;

// Usage Examples
const fill = require('./fillRange');

console.log(fill('1', '10')); //=> ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']
console.log(fill('a', 'e')); //=> ['a', 'b', 'c', 'd', 'e']
console.log(fill('1', '10', 2)); //=> ['1', '3', '5', '7', '9']
console.log(fill('a', 'z', 3, { toRegex: true })); //=> 'a|d|g|j|m|p|s|v|y'
```