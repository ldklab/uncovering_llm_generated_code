The functionality of this Node.js code is to provide a custom `forEach` function that can iterate over arrays, strings, and objects while applying a given iterator function to each element, character, or property. Here's how the code works:

- **Array Iteration:** When the provided `list` is an array, each element of the array is passed to the iterator function. The optional `thisArg` parameter can be used to set the `this` context for the iterator function.
  
- **String Iteration:** When the `list` is a string, the function iterates over each character, passing them to the iterator function while maintaining the index. The `thisArg` can similarly apply as the `this` context.
  
- **Object Iteration:** When dealing with objects, it iterates over each property of the object and provides the key and value to the iterator function. The `thisArg` can again be used to set the context for these calls.

- **Validation:** The function first checks if the iterator provided is a callable (a function); if it isn't, it throws a `TypeError`.

The code exports this `forEach` function module so that it can be utilized in different parts of a Node.js application for consistent iteration across various data types.

Here is the rewritten version of the given code:

```javascript
'use strict';

const isCallable = require('is-callable');

const toStringTag = Object.prototype.toString;
const hasOwnProperty = Object.prototype.hasOwnProperty;

const iterateArray = (arr, callback, context) => {
    for (let i = 0, len = arr.length; i < len; i++) {
        if (hasOwnProperty.call(arr, i)) {
            if (context == null) {
                callback(arr[i], i, arr);
            } else {
                callback.call(context, arr[i], i, arr);
            }
        }
    }
};

const iterateString = (str, callback, context) => {
    for (let i = 0, len = str.length; i < len; i++) {
        if (context == null) {
            callback(str.charAt(i), i, str);
        } else {
            callback.call(context, str.charAt(i), i, str);
        }
    }
};

const iterateObject = (obj, callback, context) => {
    for (const key in obj) {
        if (hasOwnProperty.call(obj, key)) {
            if (context == null) {
                callback(obj[key], key, obj);
            } else {
                callback.call(context, obj[key], key, obj);
            }
        }
    }
};

const customForEach = (collection, callback, context) => {
    if (!isCallable(callback)) {
        throw new TypeError('callback must be a function');
    }

    if (arguments.length >= 3) {
        context = context;
    }

    if (toStringTag.call(collection) === '[object Array]') {
        iterateArray(collection, callback, context);
    } else if (typeof collection === 'string') {
        iterateString(collection, callback, context);
    } else {
        iterateObject(collection, callback, context);
    }
};

module.exports = customForEach;
```