The given Node.js code is part of the node-gyp package, which is used to compile native add-ons for Node.js. This script defines a constructor function `Gyp` (using Node.js event emitter), and manages different build commands related to module building and header file management. The script uses several packages such as `nopt` for parsing command-line options, `npmlog` for logging, and `child_process` to spawn subprocesses.

Here's what each part does:

1. **Imports and Initial Setup**: The code imports required modules and sets up command and alias mappings.

2. **Gyp Functionality**:
   - Constructs a `Gyp` object with a list of commands such as build, clean, configure, etc.
   - Initializes event emitter properties via `util.inherits`.
   - Exposes package.json details through the `package` property.

3. **Configuration and Parsing**:
   - Defines configuration options (`configDefs`) and shorthand mappings (`shorthands`) for nopt parsing.
   - Implements `parseArgv` to parse command-line arguments, handle command aliases, and manage commands queue.
   - Configures logging levels and environment variable inheritance from npm.

4. **Process Management**:
   - Provides a method `spawn` to execute shell commands within subprocesses.
   
5. **Utility Methods**:
   - Offers a `usage` method that returns usage instructions for node-gyp.
   - Gets the current `version` from the package.json.

Here is a possible rewrite of the code:

```javascript
'use strict';

const path = require('path');
const nopt = require('nopt');
const log = require('npmlog');
const { spawn } = require('child_process');
const { EventEmitter } = require('events');
const { inherits } = require('util');
const commands = ['build', 'clean', 'configure', 'rebuild', 'install', 'list', 'remove'];
const aliases = { ls: 'list', rm: 'remove' };

log.heading = 'gyp';

function gyp() {
  return new Gyp();
}

function Gyp() {
  EventEmitter.call(this);
  this.devDir = '';
  this.commands = {};
  
  commands.forEach(command => {
    this.commands[command] = (argv, callback) => {
      log.verbose('command', command, argv);
      return require(`./${command}`)(this, argv, callback);
    };
  });
}
inherits(Gyp, EventEmitter);

Gyp.prototype.package = require('../package.json');

Gyp.prototype.configDefs = {
  help: Boolean, arch: String, cafile: String, debug: Boolean, directory: String,
  make: String, msvs_version: String, ensure: Boolean, solution: String, proxy: String,
  noproxy: String, devdir: String, nodedir: String, loglevel: String, python: String,
  'dist-url': String, tarball: String, jobs: String, thin: String
};

Gyp.prototype.shorthands = {
  release: '--no-debug', C: '--directory', debug: '--debug', j: '--jobs',
  silly: '--loglevel=silly', verbose: '--loglevel=verbose', silent: '--loglevel=silent'
};

Gyp.prototype.aliases = aliases;

Gyp.prototype.parseArgv = function(argv) {
  this.opts = nopt(this.configDefs, this.shorthands, argv);
  this.argv = this.opts.argv.remain.slice();

  this.todo = [];
  argv = this.argv.map(arg => this.aliases[arg] || arg, this);

  argv.slice().forEach(arg => {
    if (arg in this.commands) {
      let args = argv.splice(0, argv.indexOf(arg));
      argv.shift();
      if (this.todo.length > 0) {
        this.todo[this.todo.length - 1].args = args;
      }
      this.todo.push({ name: arg, args: [] });
    }
  }, this);

  if (this.todo.length > 0) {
    this.todo[this.todo.length - 1].args = argv.splice(0);
  }

  Object.keys(process.env).forEach(name => {
    let val = process.env[name];
    if (name.startsWith('npm_config_')) {
      if (name === 'npm_config_loglevel') {
        log.level = val;
      } else {
        name = name.substring(10);
        if (name) {
          this.opts[name] = val;
        }
      }
    }
  }, this);

  if (this.opts.loglevel) {
    log.level = this.opts.loglevel;
  }
  log.resume();
};

Gyp.prototype.spawn = function(command, args, opts = {}) {
  if (!opts.silent && !opts.stdio) {
    opts.stdio = ['inherit', 'inherit', 'inherit'];
  }
  const cp = spawn(command, args, opts);
  log.info('spawn', command);
  log.info('spawn args', args);
  return cp;
};

Gyp.prototype.usage = function() {
  const str = [
    '', '  Usage: node-gyp <command> [options]', '',
    '  where <command> is one of:',
    ...commands.map(c => `    - ${c} - ${require(`./${c}`).usage}`),
    '', `node-gyp@${this.version}  ${path.resolve(__dirname, '..')}`,
    `node@${process.versions.node}`
  ].join('\n');
  return str;
};

Object.defineProperty(Gyp.prototype, 'version', {
  get: function() { return this.package.version; },
  enumerable: true
});

module.exports = gyp;
```