The provided code defines a utility function called `extend` that is used to merge properties from one or more source objects into a target object. It supports both shallow and deep copying. The code is structured as follows:

1. **Helper functions:**
   - `isArray`: Checks if a value is an array using `Array.isArray` if available; falls back to checking the object type string.
   - `isPlainObject`: Checks if a value is a plain object (literal object or created using `new Object()`).
   - `setProperty`: Sets a property on an object, handling the special case of the `__proto__` property to ensure it is correctly defined if `Object.defineProperty` is available.
   - `getProperty`: Retrieves a property's value, taking special care with the `__proto__` property to ensure correct behavior.

2. **Main function `extend`:**
   - Can perform both shallow and deep merges, controlled by an optional boolean first argument.
   - Iterates over all properties of the source objects, copying them to the target object.
   - For deep merges, recursively copies objects and arrays to avoid modifying the original objects.
   - Uses the helper functions to handle special cases like the `__proto__` property.

```javascript
'use strict';

const hasOwn = Object.prototype.hasOwnProperty;
const toStr = Object.prototype.toString;
const defineProperty = Object.defineProperty;
const gOPD = Object.getOwnPropertyDescriptor;

const isArray = (arr) => Array.isArray ? Array.isArray(arr) : toStr.call(arr) === '[object Array]';

const isPlainObject = (obj) => {
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	const hasOwnConstructor = hasOwn.call(obj, 'constructor');
	const hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	let key;
	for (key in obj) { /* empty */ }

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

const setProperty = (target, options) => {
	if (defineProperty && options.name === '__proto__') {
		defineProperty(target, options.name, {
			enumerable: true,
			configurable: true,
			value: options.newValue,
			writable: true
		});
	} else {
		target[options.name] = options.newValue;
	}
};

const getProperty = (obj, name) => {
	if (name === '__proto__') {
		if (!hasOwn.call(obj, name)) {
			return void 0;
		} else if (gOPD) {
			return gOPD(obj, name).value;
		}
	}

	return obj[name];
};

module.exports = function extend() {
	let options, name, src, copy, copyIsArray, clone;
	let target = arguments[0] || {};
	let i = 1;
	const length = arguments.length;
	let deep = false;

	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		i = 2;
	}

	if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		if (options != null) {
			for (name in options) {
				src = getProperty(target, name);
				copy = getProperty(options, name);

				if (target !== copy) {
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

					} else if (typeof copy !== 'undefined') {
						setProperty(target, { name: name, newValue: copy });
					}
				}
			}
		}
	}

	return target;
};
```