The provided Node.js code exports various classes and functions related to date and time manipulation using the Luxon library. Here's an overview of the functionality:

1. **LuxonError Classes**: Various subclasses of `LuxonError` such as `InvalidDateTimeError`, `InvalidIntervalError`, etc., define custom error types specific to Luxon errors.

2. **Constants**: Provides various format options like `DATE_SHORT`, `TIME_SIMPLE`, `DATETIME_FULL`, etc., used for output formatting.

3. **Utility Functions**: Various utility functions are defined, such as:
   - `isUndefined`, `isNumber`, `isString`, etc., to perform type checks.
   - `hasIntl`, `hasFormatToParts`, etc., for checking environment capabilities.
   - `floorMod`, `padStart`, etc., for mathematical and string operations.

4. **Zone Classes**: Classes like `Zone`, `LocalZone`, `IANAZone`, `FixedOffsetZone`, and `InvalidZone` manage different time zones.

5. **Settings**: Centralized configuration for Luxon, including default locale, timezone, etc.

6. **Locale**: Manages internationalization, including locale settings, formatting options, and more.

7. **Duration**: Represents and manipulates durations of time.

8. **Interval**: Represents a time interval between two `DateTime` instances.

9. **Info**: Provides static methods to retrieve general time and date-related data.

10. **DateTime**: Central class for Luxon that represents date and time with methods for creation, manipulation, and formatting.

Below is the translated and structured Node.js code block:

```javascript
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

// Define private LuxonError classes
class LuxonError extends Error {}
class InvalidDateTimeError extends LuxonError { constructor(reason) { super(`Invalid DateTime: ${reason.toMessage()}`); } }
class InvalidIntervalError extends LuxonError { constructor(reason) { super(`Invalid Interval: ${reason.toMessage()}`); } }
class InvalidDurationError extends LuxonError { constructor(reason) { super(`Invalid Duration: ${reason.toMessage()}`); } }
class ConflictingSpecificationError extends LuxonError {}
class InvalidUnitError extends LuxonError { constructor(unit) { super(`Invalid unit ${unit}`); } }
class InvalidArgumentError extends LuxonError {}
class ZoneIsAbstractError extends LuxonError { constructor() { super("Zone is an abstract class"); } }

// Define formatting constants
const n = "numeric", s = "short", l = "long";
const DATE_SHORT = { year: n, month: n, day: n };
const DATE_MED = { year: n, month: s, day: n };
const DATE_MED_WITH_WEEKDAY = { year: n, month: s, day: n, weekday: s };
const DATE_FULL = { year: n, month: l, day: n };
const DATE_HUGE = { year: n, month: l, day: n, weekday: l };
const TIME_SIMPLE = { hour: n, minute: n };
const TIME_WITH_SECONDS = { hour: n, minute: n, second: n };
const TIME_WITH_SHORT_OFFSET = { hour: n, minute: n, second: n, timeZoneName: s };
const TIME_WITH_LONG_OFFSET = { hour: n, minute: n, second: n, timeZoneName: l };
const TIME_24_SIMPLE = { hour: n, minute: n, hour12: false };
const TIME_24_WITH_SECONDS = { hour: n, minute: n, second: n, hour12: false };
const TIME_24_WITH_SHORT_OFFSET = { hour: n, minute: n, second: n, hour12: false, timeZoneName: s };
const TIME_24_WITH_LONG_OFFSET = { hour: n, minute: n, second: n, hour12: false, timeZoneName: l };
const DATETIME_SHORT = { year: n, month: n, day: n, hour: n, minute: n };
const DATETIME_SHORT_WITH_SECONDS = { year: n, month: n, day: n, hour: n, minute: n, second: n };
const DATETIME_MED = { year: n, month: s, day: n, hour: n, minute: n };
const DATETIME_MED_WITH_SECONDS = { year: n, month: s, day: n, hour: n, minute: n, second: n };
const DATETIME_MED_WITH_WEEKDAY = { year: n, month: s, day: n, weekday: s, hour: n, minute: n };
const DATETIME_FULL = { year: n, month: l, day: n, hour: n, minute: n, timeZoneName: s };
const DATETIME_FULL_WITH_SECONDS = { year: n, month: l, day: n, hour: n, minute: n, second: n, timeZoneName: s };
const DATETIME_HUGE = { year: n, month: l, day: n, weekday: l, hour: n, minute: n, timeZoneName: l };
const DATETIME_HUGE_WITH_SECONDS = { year: n, month: l, day: n, weekday: l, hour: n, minute: n, second: n, timeZoneName: l };

// Utility functions for type checks, capabilities, and operations
function isUndefined(o) { return typeof o === "undefined"; }
function isNumber(o) { return typeof o === "number"; }
function isInteger(o) { return typeof o === "number" && o % 1 === 0; }
function isString(o) { return typeof o === "string"; }
function isDate(o) { return Object.prototype.toString.call(o) === "[object Date]"; }
function hasIntl() { try { return typeof Intl !== "undefined" && Intl.DateTimeFormat; } catch (e) { return false; } }
function hasFormatToParts() { return !isUndefined(Intl.DateTimeFormat.prototype.formatToParts); }
function hasRelative() { try { return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat; } catch (e) { return false; } }
function maybeArray(thing) { return Array.isArray(thing) ? thing : [thing]; }
function bestBy(arr, by, compare) { if (arr.length === 0) return undefined; return arr.reduce((best, next) => { const pair = [by(next), next]; if (!best) { return pair; } else if (compare(best[0], pair[0]) === best[0]) { return best; } else { return pair; } }, null)[1]; }
function pick(obj, keys) { return keys.reduce((a, k) => { a[k] = obj[k]; return a; }, {}); }
function hasOwnProperty(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
function integerBetween(thing, bottom, top) { return isInteger(thing) && thing >= bottom && thing <= top; }
function floorMod(x, n) { return x - n * Math.floor(x / n); }
function padStart(input, n = 2) { if (input.toString().length < n) { return ("0".repeat(n) + input).slice(-n); } else { return input.toString(); } }
function parseInteger(string) { if (isUndefined(string) || string === null || string === "") { return undefined; } else { return parseInt(string, 10); } }
function parseMillis(fraction) { if (isUndefined(fraction) || fraction === null || fraction === "") { return undefined; } else { const f = parseFloat("0." + fraction) * 1000; return Math.floor(f); } }
function roundTo(number, digits, towardZero = false) { const factor = Math.pow(10, digits), rounder = towardZero ? Math.trunc : Math.round; return rounder(number * factor) / factor; }
function isLeapYear(year) { return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0); }
function daysInYear(year) { return isLeapYear(year) ? 366 : 365; }
function daysInMonth(year, month) { const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12; if (modMonth === 2) { return isLeapYear(modYear) ? 29 : 28; } else { return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1]; } }
function objToLocalTS(obj) { let d = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond); if (obj.year < 100 && obj.year >= 0) { d = new Date(d); d.setUTCFullYear(d.getUTCFullYear() - 1900); } return +d; }
function weeksInWeekYear(weekYear) { const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7; return p1 === 4 || p2 === 3 ? 53 : 52; }
function untruncateYear(year) { if (year > 99) { return year; } else return year > 60 ? 1900 + year : 2000 + year; }
function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) { const date = new Date(ts), intlOpts = { hour12: false, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit" }; if (timeZone) { intlOpts.timeZone = timeZone; } const modified = Object.assign({ timeZoneName: offsetFormat }, intlOpts), intl = hasIntl(); if (intl && hasFormatToParts()) { const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find(m => m.type.toLowerCase() === "timezonename"); return parsed ? parsed.value : null; } else if (intl) { const without = new Intl.DateTimeFormat(locale, intlOpts).format(date), included = new Intl.DateTimeFormat(locale, modified).format(date), diffed = included.substring(without.length), trimmed = diffed.replace(/^[, \u200e]+/, ""); return trimmed; } else { return null; } }
function signedOffset(offHourStr, offMinuteStr) { let offHour = parseInt(offHourStr, 10); if (Number.isNaN(offHour)) { offHour = 0; } const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin; return offHour * 60 + offMinSigned; }
function asNumber(value) { const numericValue = Number(value); if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue)) throw new InvalidArgumentError(`Invalid unit value ${value}`); return numericValue; }
function normalizeObject(obj, normalizer, nonUnitKeys) { const normalized = {}; for (const u in obj) { if (hasOwnProperty(obj, u)) { if (nonUnitKeys.indexOf(u) >= 0) continue; const v = obj[u]; if (v === undefined || v === null) continue; normalized[normalizer(u)] = asNumber(v); } } return normalized; }
function formatOffset(offset, format) { const hours = Math.trunc(Math.abs(offset / 60)), minutes = Math.trunc(Math.abs(offset % 60)), sign = offset >= 0 ? "+" : "-"; switch (format) { case "short": return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`; case "narrow": return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`; case "techie": return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`; default: throw new RangeError(`Value format ${format} is out of range for property format`); } }
function timeObject(obj) { return pick(obj, ["hour", "minute", "second", "millisecond"]); }
const ianaRegex = /[A-Za-z_+-]{1,256}(:?\/[A-Za-z_+-]{1,256}(\/[A-Za-z_+-]{1,256})?)?/;
function stringify(obj) { return JSON.stringify(obj, Object.keys(obj).sort()); }
const monthsLong = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
const monthsShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
const monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length) { switch (length) { case "narrow": return monthsNarrow; case "short": return monthsShort; case "long": return monthsLong; case "numeric": return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"]; case "2-digit": return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"]; default: return null; } }
const weekdaysLong = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
const weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
const weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length) { switch (length) { case "narrow": return weekdaysNarrow; case "short": return weekdaysShort; case "long": return weekdaysLong; case "numeric": return ["1", "2", "3", "4", "5", "6", "7"]; default: return null; } }
const meridiems = ["AM", "PM"];
const erasLong = ["Before Christ", "Anno Domini"];
const erasShort = ["BC", "AD"];
const erasNarrow = ["B", "A"];
function eras(length) { switch (length) { case "narrow": return erasNarrow; case "short": return erasShort; case "long": return erasLong; default: return null; } }
function meridiemForDateTime(dt) { return meridiems[dt.hour < 12 ? 0 : 1]; }
function weekdayForDateTime(dt, length) { return weekdays(length)[dt.weekday - 1]; }
function monthForDateTime(dt, length) { return months(length)[dt.month - 1]; }
function eraForDateTime(dt, length) { return eras(length)[dt.year < 0 ? 0 : 1]; }
function formatRelativeTime(unit, count, numeric = "always", narrow = false) { const units = { years: ["year", "yr."], quarters: ["quarter", "qtr."], months: ["month", "mo."], weeks: ["week", "wk."], days: ["day", "day", "days"], hours: ["hour", "hr."], minutes: ["minute", "min."], seconds: ["second", "sec."] }; const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1; if (numeric === "auto" && lastable) { const isDay = unit === "days"; switch (count) { case 1: return isDay ? "tomorrow" : `next ${units[unit][0]}`; case -1: return isDay ? "yesterday" : `last ${units[unit][0]}`; case 0: return isDay ? "today" : `this ${units[unit][0]}`; } } const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit; return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`; }
function formatString(knownFormat) { const filtered = pick(knownFormat, ["weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "hour12"]), key = stringify(filtered), dateTimeHuge = "EEEE, LLLL d, yyyy, h:mm a"; switch (key) { case stringify(DATE_SHORT): return "M/d/yyyy"; case stringify(DATE_MED): return "LLL d, yyyy"; case stringify(DATE_MED_WITH_WEEKDAY): return "EEE, LLL d, yyyy"; case stringify(DATE_FULL): return "LLLL d, yyyy"; case stringify(DATE_HUGE): return "EEEE, LLLL d, yyyy"; case stringify(TIME_SIMPLE): return "h:mm a"; case stringify(TIME_WITH_SECONDS): return "h:mm:ss a"; case stringify(TIME_WITH_SHORT_OFFSET): return "h:mm a"; case stringify(TIME_WITH_LONG_OFFSET): return "h:mm a"; case stringify(TIME_24_SIMPLE): return "HH:mm"; case stringify(TIME_24_WITH_SECONDS): return "HH:mm:ss"; case stringify(TIME_24_WITH_SHORT_OFFSET): return "HH:mm"; case stringify(TIME_24_WITH_LONG_OFFSET): return "HH:mm"; case stringify(DATETIME_SHORT): return "M/d/yyyy, h:mm a"; case stringify(DATETIME_MED): return "LLL d, yyyy, h:mm a"; case stringify(DATETIME_FULL): return "LLLL d, yyyy, h:mm a"; case stringify(DATETIME_HUGE): return dateTimeHuge; case stringify(DATETIME_SHORT_WITH_SECONDS): return "M/d/yyyy, h:mm:ss a"; case stringify(DATETIME_MED_WITH_SECONDS): return "LLL d, yyyy, h:mm:ss a"; case stringify(DATETIME_MED_WITH_WEEKDAY): return "EEE, d LLL yyyy, h:mm a"; case stringify(DATETIME_FULL_WITH_SECONDS): return "LLLL d, yyyy, h:mm:ss a"; case stringify(DATETIME_HUGE_WITH_SECONDS): return "EEEE, LLLL d, yyyy, h:mm:ss a"; default: return dateTimeHuge; } }
function stringifyTokens(splits, tokenToString) { let s = ""; for (const token of splits) { if (token.literal) { s += token.val; } else { s += tokenToString(token.val); } } return s; }
const macroTokenToFormatOpts = { D: DATE_SHORT, DD: DATE_MED, DDD: DATE_FULL, DDDD: DATE_HUGE, t: TIME_SIMPLE, tt: TIME_WITH_SECONDS, ttt: TIME_WITH_SHORT_OFFSET, tttt: TIME_WITH_LONG_OFFSET, T: TIME_24_SIMPLE, TT: TIME_24_WITH_SECONDS, TTT: TIME_24_WITH_SHORT_OFFSET, TTTT: TIME_24_WITH_LONG_OFFSET, f: DATETIME_SHORT, ff: DATETIME_MED, fff: DATETIME_FULL, ffff: DATETIME_HUGE, F: DATETIME_SHORT_WITH_SECONDS, FF: DATETIME_MED_WITH_SECONDS, FFF: DATETIME_FULL_WITH_SECONDS, FFFF: DATETIME_HUGE_WITH_SECONDS };
class Formatter { static create(locale, opts = {}) { return new Formatter(locale, opts); } static parseFormat(fmt) { let current = null, currentFull = "", bracketed = false; const splits = []; for (let i = 0; i < fmt.length; i++) { const c = fmt.charAt(i); if (c === "'") { if (currentFull.length > 0) { splits.push({ literal: bracketed, val: currentFull }); } current = null; currentFull = ""; bracketed = !bracketed; } else if (bracketed) { currentFull += c; } else if (c === current) { currentFull += c; } else { if (currentFull.length > 0) { splits.push({ literal: false, val: currentFull }); } currentFull = c; current = c; } } if (currentFull.length > 0) { splits.push({ literal: bracketed, val: currentFull }); } return splits; } static macroTokenToFormatOpts(token) { return macroTokenToFormatOpts[token]; } constructor(locale, formatOpts) { this.opts = formatOpts; this.loc = locale; this.systemLoc = null; } formatWithSystemDefault(dt, opts) { if (this.systemLoc === null) { this.systemLoc = this.loc.redefaultToSystem(); } const df = this.systemLoc.dtFormatter(dt, Object.assign({}, this.opts, opts)); return df.format(); } formatDateTime(dt, opts = {}) { const df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts)); return df.format(); } formatDateTimeParts(dt, opts = {}) { const df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts)); return df.formatToParts(); } resolvedOptions(dt, opts = {}) { const df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts)); return df.resolvedOptions(); } num(n, p = 0) { if (this.opts.forceSimple) { return padStart(n, p); } const opts = Object.assign({}, this.opts); if (p > 0) { opts.padTo = p; } return this.loc.numberFormatter(opts).format(n); } formatDateTimeFromString(dt, fmt) { const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory" && hasFormatToParts(), string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset = opts => { if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) { return "Z"; } return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : ""; }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({ hour: "numeric", hour12: true }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(datytte(dt, length) : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" }, "weekday"), maybeMacro = token => { const formatOpts = Formatter.macroTokenToFormatOpts(token); if (formatOpts) { return this.formatWithSystemDefault(dt, formatOpts); } else { return token; } }, era = length => knownEnglish ? eraForDateTime(dt, length) : string({ era: length }, "era"), tokenToString = token => { switch (token) { case "S": return this.num(dt.millisecond); case "u": case "SSS": return this.num(dt.millisecond, 3); case "s": return this.num(dt.second); case "ss": return this.num(dt.second, 2); case "m": return this.num(dt.minute); case "mm": return this.num(dt.minute, 2); case "h": return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12); case "hh": return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2); case "H": return this.num(dt.hour); case "HH": return this.num(dt.hour, 2); case "Z": return formatOffset({ format: "narrow", allowZ: this.opts.allowZ }); case "ZZ": return formatOffset({ format: "short", allowZ: this.opts.allowZ }); case "ZZZ": return formatOffset({ format: "techie", allowZ: this.opts.allowZ }); case "ZZZZ": return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale }); case "ZZZZZ": return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale }); case "z": return dt.zoneName; case "a": return meridiem(); case "d": return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day); case "dd": return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2); case "c": return this.num(dt.weekday); case "ccc": return weekday("short", true); case "cccc": return weekday("long", true); case "ccccc": return weekday("narrow", true); case "E": return this.num(dt.weekday); case "EEE": return weekday("short", false); case "EEEE": return weekday("long", false); case "EEEEE": return weekday("narrow", false); case "L": return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month); case "LL": return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2); case "LLL": return month("short", true); case "LLLL": return month("long", true); case "LLLLL": return month("narrow", true); case "M": return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month); case "MM": return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2); case "MMM": return month("short", false); case "MMMM": return month("long", false); case "MMMMM": return month("narrow", false); case "y": return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year); case "yy": return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2); case "yyyy": return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4); case "yyyyyy": return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6); case "G": return era("short"); case "GG": return era("long"); case "GGGGG": return era("narrow"); case "kk": return this.num(dt.weekYear.toString().slice(-2), 2); case "kkkk": return this.num(dt.weekYear, 4); case "W": return this.num(dt.weekNumber); case "WW": return this.num(dt.weekNumber, 2); case "o": return this.num(dt.ordinal); case "ooo": return this.num(dt.ordinal, 3); case "q": return this.num(dt.quarter); case "qq": return this.num(dt.quarter, 2); case "X": return this.num(Math.floor(dt.ts / 1000)); case "x": return this.num(dt.ts); default: return maybeMacro(token); } }; return stringifyTokens(Formatter.parseFormat(fmt), tokenToString); } formatDurationFromString(dur, fmt) { const tokenToField = token => { switch (token[0]) { case "S": return "millisecond"; case "s": return "second"; case "m": return "minute"; case "h": return "hour"; case "d": return "day"; case "M": return "month"; case "y": return "year"; default: return null; } }, tokenToString = lildur => token => { const mapped = tokenToField(token); if (mapped) { return this.num(lildur.get(mapped), token.length); } else { return token; } }, tokens = Formatter.parseFormat(fmt), realTokens = tokens.reduce((found, { literal, val }) => literal ? found : found.concat(val), []), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter(t => t)); return stringifyTokens(tokens, tokenToString(collapsed)); } }

class Invalid { constructor(reason, explanation) { this.reason = reason; this.explanation = explanation; } toMessage() { if (this.explanation) { return `${this.reason}: ${this.explanation}`; } else { return this.reason; } } }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

class Zone { get type() { throw new ZoneIsAbstractError(); } get name() { throw new ZoneIsAbstractError(); } get universal() { throw new ZoneIsAbstractError(); } offsetName(ts, opts) { throw new ZoneIsAbstractError(); } formatOffset(ts, format) { throw new ZoneIsAbstractError(); } offset(ts) { throw new ZoneIsAbstractError(); } equals(otherZone) { throw new ZoneIsAbstractError(); } get isValid() { throw new ZoneIsAbstractError(); } }

let singleton = null; class LocalZone extends Zone { static get instance() { if (singleton === null) { singleton = new LocalZone(); } return singleton; } get type() { return "local"; } get name() { if (hasIntl()) { return new Intl.DateTimeFormat().resolvedOptions().timeZone; } else return "local"; } get universal() { return false; } offsetName(ts, { format, locale }) { return parseZoneInfo(ts, format, locale); } formatOffset(ts, format) { return formatOffset(this.offset(ts), format); } offset(ts) { return -new Date(ts).getTimezoneOffset(); } equals(otherZone) { return otherZone.type === "local"; } get isValid() { return true; } }

const matchingRegex = RegExp(`^${ianaRegex.source}$`);
let dtfCache = {};

function makeDTF(zone) { if (!dtfCache[zone]) { dtfCache[zone] = new Intl.DateTimeFormat("en-US", { hour12: false, timeZone: zone, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit" }); } return dtfCache[zone]; }

const typeToPos = { year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5 };

function hackyOffset(dtf, date) { const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fHour, fMinute, fSecond] = parsed; return [fYear, fMonth, fDay, fHour, fMinute, fSecond]; }

function partsOffset(dtf, date) { const formatted = dtf.formatToParts(date), filled = []; for (let i = 0; i < formatted.length; i++) { const { type, value } = formatted[i], pos = typeToPos[type]; if (!isUndefined(pos)) { filled[pos] = parseInt(value, 10); } } return filled; }

let ianaZoneCache = {}; class IANAZone extends Zone { static create(name) { if (!ianaZoneCache[name]) { ianaZoneCache[name] = new IANAZone(name); } return ianaZoneCache[name]; } static resetCache() { ianaZoneCache = {}; dtfCache = {}; } static isValidSpecifier(s) { return !!(s && s.match(matchingRegex)); } static isValidZone(zone) { try { new Intl.DateTimeFormat("en-US", { timeZone: zone }).format(); return true; } catch (e) { return false; } } static parseGMTOffset(specifier) { if (specifier) { const match = specifier.match(/^Etc\/GMT([+-]\d{1,2})$/i); if (match) { return -60 * parseInt(match[1]); } } return null; } constructor(name) { super(); this.zoneName = name; this.valid = IANAZone.isValidZone(name); } get type() { return "iana"; } get name() { return this.zoneName; } get universal() { return false; } offsetName(ts, { format, locale }) { return parseZoneInfo(ts, format, locale, this.name); } formatOffset(ts, format) { return formatOffset(this.offset(ts), format); } offset(ts) { const date = new Date(ts), dtf = makeDTF(this.name), [year, month, day, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date), adjustedHour = hour === 24 ? 0 : hour; const asUTC = objToLocalTS({ year, month, day, hour: adjustedHour, minute, second, millisecond: 0 }); let asTS = +date; const over = asTS % 1000; asTS -= over >= 0 ? over : 1000 + over; return (asUTC - asTS) / (60 * 1000); } equals(otherZone) { return otherZone.type === "iana" && otherZone.name === this.name; } get isValid() { return this.valid; } }

let singleton$1 = null; class FixedOffsetZone extends Zone { static get utcInstance() { if (singleton$1 === null) { singleton$1 = new FixedOffsetZone(0); } return singleton$1; } static instance(offset) { return offset === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset); } static parseSpecifier(s) { if (s) { const r = s.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i); if (r) { return new FixedOffsetZone(signedOffset(r[1], r[2])); } } return null; } constructor(offset) { super(); this.fixed = offset; } get type() { return "fixed"; } get name() { return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`; } offsetName() { return this.name; } formatOffset(ts, format) { return formatOffset(this.fixed, format); } get universal() { return true; } offset() { return this.fixed; } equals(otherZone) { return otherZone.type === "fixed" && otherZone.fixed === this.fixed; } get isValid() { return true; } }

class InvalidZone extends Zone { constructor(zoneName) { super(); this.zoneName = zoneName; } get type() { return "invalid"; } get name() { return this.zoneName; } get universal() { return false; } offsetName() { return null; } formatOffset() { return ""; } offset() { return NaN; } equals() { return false; } get isValid() { return false; } }

function normalizeZone(input, defaultZone) { let offset; if (isUndefined(input) || input === null) { return defaultZone; } else if (input instanceof Zone) { return input; } else if (isString(input)) { const lowered = input.toLowerCase(); if (lowered === "local") return defaultZone; else if (lowered === "utc" || lowered === "gmt") return FixedOffsetZone.utcInstance; else if ((offset = IANAZone.parseGMTOffset(input)) != null) { return FixedOffsetZone.instance(offset); } else if (IANAZone.isValidSpecifier(lowered)) return IANAZone.create(input); else return FixedOffsetZone.parseSpecifier(lowered) || new InvalidZone(input); } else if (isNumber(input)) { return FixedOffsetZone.instance(input); } else if (typeof input === "object" && input.offset && typeof input.offset === "number") { return input; } else { return new InvalidZone(input); } }

let now = () => Date.now(), defaultZone = null, defaultLocale = null, defaultNumberingSystem = null, defaultOutputCalendar = null, throwOnInvalid = false; class Settings { static get now() { return now; } static set now(n) { now = n; } static get defaultZoneName() { return Settings.defaultZone.name; } static set defaultZoneName(z) { if (!z) { defaultZone = null; } else { defaultZone = normalizeZone(z); } } static get defaultZone() { return defaultZone || LocalZone.instance; } static get defaultLocale() { return defaultLocale; } static set defaultLocale(locale) { defaultLocale = locale; } static get defaultNumberingSystem() { return defaultNumberingSystem; } static set defaultNumberingSystem(numberingSystem) { defaultNumberingSystem = numberingSystem; } static get defaultOutputCalendar() { return defaultOutputCalendar; } static set defaultOutputCalendar(outputCalendar) { defaultOutputCalendar = outputCalendar; } static get throwOnInvalid() { return throwOnInvalid; } static set throwOnInvalid(t) { throwOnInvalid = t; } static resetCaches() { Locale.resetCache(); IANAZone.resetCache(); } }

let intlDTCache = {};
function getCachedDTF(locString, opts = {}) { const key = JSON.stringify([locString, opts]); let dtf = intlDTCache[key]; if (!dtf) { dtf = new Intl.DateTimeFormat(locString, opts); intlDTCache[key] = dtf; } return dtf; }

let intlNumCache = {};
function getCachedINF(locString, opts = {}) { const key = JSON.stringify([locString, opts]); let inf = intlNumCache[key]; if (!inf) { inf = new Intl.NumberFormat(locString, opts); intlNumCache[key] = inf; } return inf; }

let intlRelCache = {};
function getCachedRTF(locString, opts = {}) { const cacheKeyOpts = _objectWithoutPropertiesLoose(opts, ["base"]); const key = JSON.stringify([locString, cacheKeyOpts]); let inf = intlRelCache[key]; if (!inf) { inf = new Intl.RelativeTimeFormat(locString, opts); intlRelCache[key] = inf; } return inf; }

let sysLocaleCache = null;
function systemLocale() { if (sysLocaleCache) { return sysLocaleCache; } else if (hasIntl()) { const computedSys = new Intl.DateTimeFormat().resolvedOptions().locale; sysLocaleCache = !computedSys || computedSys === "und" ? "en-US" : computedSys; return sysLocaleCache; } else { sysLocaleCache = "en-US"; return sysLocaleCache; } }

function parseLocaleString(localeStr) { const uIndex = localeStr.indexOf("-u-"); if (uIndex === -1) { return [localeStr]; } else { let options; const smaller = localeStr.substring(0, uIndex); try { options = getCachedDTF(localeStr).resolvedOptions(); } catch (e) { options = getCachedDTF(smaller).resolvedOptions(); } const { numberingSystem, calendar } = options; return [smaller, numberingSystem, calendar]; } }

function intlConfigString(localeStr, numberingSystem, outputCalendar) { if (hasIntl()) { if (outputCalendar || numberingSystem) { localeStr += "-u"; if (outputCalendar) { localeStr += `-ca-${outputCalendar}`; } if (numberingSystem) { localeStr += `-nu-${numberingSystem}`; } return localeStr; } else { return localeStr; } } else { return []; } }

function mapMonths(f) { const ms = []; for (let i = 1; i <= 12; i++) { const dt = DateTime.utc(2016, i, 1); ms.push(f(dt)); } return ms; }

function mapWeekdays(f) { const ms = []; for (let i = 1; i <= 7; i++) { const dt = DateTime.utc(2016, 11, 13 + i); ms.push(f(dt)); } return ms; }

function listStuff(loc, length, defaultOK, englishFn, intlFn) { const mode = loc.listingMode(defaultOK); if (mode === "error") { return null; } else if (mode === "en") { return englishFn(length); } else { return intlFn(length); } }

function supportsFastNumbers(loc) { if (loc.numberingSystem && loc.numberingSystem !== "latn") { return false; } else { return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || hasIntl() && new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn"; } }

class PolyNumberFormatter { constructor(intl, forceSimple, opts) { this.padTo = opts.padTo || 0; this.floor = opts.floor || false; if (!forceSimple && hasIntl()) { const intlOpts = { useGrouping: false }; if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo; this.inf = getCachedINF(intl, intlOpts); } } format(i) { if (this.inf) { const fixed = this.floor ? Math.floor(i) : i; return this.inf.format(fixed); } else { const fixed = this.floor ? Math.floor(i) : roundTo(i, 3); return padStart(fixed, this.padTo); } } }

class PolyDateFormatter { constructor(dt, intl, opts) { this.opts = opts; this.hasIntl = hasIntl(); let z; if (dt.zone.universal && this.hasIntl) { z = "UTC"; if (opts.timeZoneName) { this.dt = dt; } else { this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1000); } } else if (dt.zone.type === "local") { this.dt = dt; } else { this.dt = dt; z = dt.zone.name; } if (this.hasIntl) { const intlOpts = Object.assign({}, this.opts); if (z) { intlOpts.timeZone = z; } this.dtf = getCachedDTF(intl, intlOpts); } } format() { if (this.hasIntl) { return this.dtf.format(this.dt.toJSDate()); } else { const tokenFormat = formatString(this.opts), loc = Locale.create("en-US"); return Formatter.create(loc).formatDateTimeFromString(this.dt, tokenFormat); } } formatToParts() { if (this.hasIntl && hasFormatToParts()) { return this.dtf.formatToParts(this.dt.toJSDate()); } else { return []; } } resolvedOptions() { if (this.hasIntl) { return this.dtf.resolvedOptions(); } else { return { locale: "en-US", numberingSystem: "latn", outputCalendar: "gregory" }; } } }

class PolyRelFormatter { constructor(intl, isEnglish, opts) { this.opts = Object.assign({ style: "long" }, opts); if (!isEnglish && hasRelative()) { this.rtf = getCachedRTF(intl, opts); } } format(count, unit) { if (this.rtf) { return this.rtf.format(count, unit); } else { return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long"); } } formatToParts(count, unit) { if (this.rtf) { return this.rtf.formatToParts(count, unit); } else { return []; } } }

class Locale { static fromOpts(opts) { return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN); } static create(locale, numberingSystem, outputCalendar, defaultToEN = false) { const specifiedLocale = locale || Settings.defaultLocale, localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale()), numberingSystemR = numberingSystem || Settings.defaultNumberingSystem, outputCalendarR = outputCalendar || Settings.defaultOutputCalendar; return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale); } static resetCache() { sysLocaleCache = null; intlDTCache = {}; intlNumCache = {}; intlRelCache = {}; } static fromObject({ locale, numberingSystem, outputCalendar } = {}) { return Locale.create(locale, numberingSystem, outputCalendar); } constructor(locale, numbering, outputCalendar, specifiedLocale) { const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale); this.locale = parsedLocale; this.numberingSystem = numbering || parsedNumberingSystem || null; this.outputCalendar = outputCalendar || parsedOutputCalendar || null; this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar); this.weekdaysCache = { format: {}, standalone: {} }; this.monthsCache = { format: {}, standalone: {} }; this.meridiemCache = null; this.eraCache = {}; this.specifiedLocale = specifiedLocale; this.fastNumbersCached = null; } get fastNumbers() { if (this.fastNumbersCached == null) { this.fastNumbersCached = supportsFastNumbers(this); } return this.fastNumbersCached; } listingMode(defaultOK = true) { const intl = hasIntl(), hasFTP = intl && hasFormatToParts(), isActuallyEn = this.isEnglish(), hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory"); if (!hasFTP && !(isActuallyEn && hasNoWeirdness) && !defaultOK) { return "error"; } else if (!hasFTP || isActuallyEn && hasNoWeirdness) { return "en"; } else { return "intl"; } } clone(alts) { if (!alts || Object.getOwnPropertyNames(alts).length === 0) { return this; } else { return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || false); } } redefaultToEN(alts = {}) { return this.clone(Object.assign({}, alts, { defaultToEN: true })); } redefaultToSystem(alts = {}) { return this.clone(Object.assign({}, alts, { defaultToEN: false })); } months(length, format = false, defaultOK = true) { return listStuff(this, length, defaultOK, months, () => { const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone"; if (!this.monthsCache[formatStr][length]) { this.monthsCache[formatStr][length] = mapMonths(dt => this.extract(dt, intl, "month")); } return this.monthsCache[formatStr][length]; }); } weekdays(length, format = false, defaultOK = true) { return listStuff(this, length, defaultOK, weekdays, () => { const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone"; if (!this.weekdaysCache[formatStr][length]) { this.weekdaysCache[formatStr][length] = mapWeekdays(dt => this.extract(dt, intl, "weekday")); } return this.weekdaysCache[formatStr][length]; }); } meridiems(defaultOK = true) { return listStuff(this, undefined, defaultOK, () => meridiems, () => { if (!this.meridiemCache) { const intl = { hour: "numeric", hour12: true }; this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(dt => this.extract(dt, intl, "dayperiod")); } return this.meridiemCache; }); } eras(length, defaultOK = true) { return listStuff(this, length, defaultOK, eras, () => { const intl = { era: length }; if (!this.eraCache[length]) { this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(dt => this.extract(dt, intl, "era")); } return this.eraCache[length]; }); } extract(dt, intlOpts, field) { const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find(m => m.type.toLowerCase() === field); return matching ? matching.value : null; } numberFormatter(opts = {}) { return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts); } dtFormatter(dt, intlOpts = {}) { return new PolyDateFormatter(dt, this.intl, intlOpts); } relFormatter(opts = {}) { return new PolyRelFormatter(this.intl, this.isEnglish(), opts); } isEnglish() { return this.locale === "en" || this.locale.toLowerCase() === "en-us" || hasIntl() && new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us"); } equals(other) { return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar; } }

function combineRegexes(...regexes) { const full = regexes.reduce((f, r) => f + r.source, ""); return RegExp(`^${full}$`); }

function combineExtractors(...extractors) { return m => extractors.reduce(([mergedVals, mergedZone, cursor], ex) => { const [val, zone, next] = ex(m, cursor); return [Object.assign(mergedVals, val), mergedZone || zone, next]; }, [{}, null, 1]).slice(0, 2); }

function parse(s, ...patterns) { if (s == null) { return [null, null]; } for (const [regex, extractor] of patterns) { const m = regex.exec(s); if (m) { return extractor(m); } } return [null, null]; }

function simpleParse(...keys) { return (match, cursor) => { const ret = {}; let i; for (i = 0; i < keys.length; i++) { ret[keys[i]] = parseInteger(match[cursor + i]); } return [ret, null, cursor + i]; }; }

const offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${offsetRegex.source}?`), isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`), isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/, isoOrdinalRegex = /(\d{4})-?(\d{3})/, extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay"), extractISOOrdinalData = simpleParse("year", "ordinal"), sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/, sqlTimeRegex = RegExp(`${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`), sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);

function int(match, pos, fallback) { const m = match[pos]; return isUndefined(m) ? fallback : parseInteger(m); }

function extractISOYmd(match, cursor) { const item = { year: int(match, cursor), month: int(match, cursor + 1, 1), day: int(match, cursor + 2, 1) }; return [item, null, cursor + 3]; }

function extractISOTime(match, cursor) { const item = { hour: int(match, cursor, 0), minute: int(match, cursor + 1, 0), second: int(match, cursor + 2, 0), millisecond: parseMillis(match[cursor + 3]) }; return [item, null, cursor + 4]; }

function extractISOOffset(match, cursor) { const local = !match[cursor] && !match[cursor + 1], fullOffset = signedOffset(match[cursor + 1], match[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset); return [{}, zone, cursor + 3]; }

function extractIANAZone(match, cursor) { const zone = match[cursor] ? IANAZone.create(match[cursor]) : null; return [{}, zone, cursor + 1]; }

const isoDuration = /^-?P(?:(?:(-?\d{1,9})Y)?(?:(-?\d{1,9})M)?(?:(-?\d{1,9})W)?(?:(-?\d{1,9})D)?(?:T(?:(-?\d{1,9})H)?(?:(-?\d{1,9})M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,9}))?S)?)?)$/;

function extractISODuration(match) { const [s, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match; const hasNegativePrefix = s[0] === "-"; const maybeNegate = num => num && hasNegativePrefix ? -num : num; return [{ years: maybeNegate(parseInteger(yearStr)), months: maybeNegate(parseInteger(monthStr)), weeks: maybeNegate(parseInteger(weekStr)), days: maybeNegate(parseInteger(dayStr)), hours: maybeNegate(parseInteger(hourStr)), minutes: maybeNegate(parseInteger(minuteStr)), seconds: maybeNegate(parseInteger(secondStr)), milliseconds: maybeNegate(parseMillis(millisecondsStr)) }]; }

const obsOffsets = { GMT: 0, EDT: -4 * 60, EST: -5 * 60, CDT: -5 * 60, CST: -6 * 60, MDT: -6 * 60, MST: -7 * 60, PDT: -7 * 60, PST: -8 * 60 };

function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) { const result = { year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr), month: monthsShort.indexOf(monthStr) + 1, day: parseInteger(dayStr), hour: parseInteger(hourStr), minute: parseInteger(minuteStr) }; if (secondStr) result.second = parseInteger(secondStr); if (weekdayStr) { result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1; } return result; }

const rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;

function extractRFC2822(match) { const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr, obsOffset, milOffset, offHourStr, offMinuteStr] = match, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr); let offset; if (obsOffset) { offset = obsOffsets[obsOffset]; } else if (milOffset) { offset = 0; } else { offset = signedOffset(offHourStr, offMinuteStr); } return [result, new FixedOffsetZone(offset)]; }

function preprocessRFC2822(s) { return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim(); }

const rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, rfc850 = /^(Monday|Tuesday|Wedsday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;

function extractRFC1123Or850(match) { const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr); return [result, FixedOffsetZone.utcInstance]; }

function extractASCII(match) { const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr); return [result, FixedOffsetZone.utcInstance]; }

const isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
const isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
const isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
const isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
const extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset);
const extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset);
const extractISOOrdinalDataAndTime = combineExtractors(extractISOOrdinalData, extractISOTime);
const extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset);

function parseISODate(s) { return parse(s, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDataAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]); }
function parseRFC2822Date(s) { return parse(preprocessRFC2822(s), [rfc2822, extractRFC2822]); }
function parseHTTPDate(s) { return parse(s, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]); }
function parseISODuration(s) { return parse(s, [isoDuration, extractISODuration]); }
const sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
const sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
const extractISOYmdTimeOffsetAndIANAZone = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
const extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
function parseSQL(s) { return parse(s, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeOffsetAndIANAZone], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]); }

const INVALID = "Invalid Duration"; const lowOrderMatrix = { weeks: { days: 7, hours: 7 * 24, minutes: 7 * 24 * 60, seconds: 7 * 24 * 60 * 60, milliseconds: 7 * 24 * 60 * 60 * 1000 }, days: { hours: 24, minutes: 24 * 60, seconds: 24 * 60 * 60, milliseconds: 24 * 60 * 60 * 1000 }, hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1000 }, minutes: { seconds: 60, milliseconds: 60 * 1000 }, seconds: { milliseconds: 1000 } }, casualMatrix = Object.assign({ years: { quarters: 4, months: 12, weeks: 52, days: 365, hours: 365 * 24, minutes: 365 * 24 * 60, seconds: 365 * 24 * 60 * 60, milliseconds: 365 * 24 * 60 * 60 * 1000 }, quarters: { months: 3, weeks: 13, days: 91, hours: 91 * 24, minutes: 91 * 24 * 60, seconds: 91 * 24 * 60 * 60, milliseconds: 91 * 24 * 60 * 60 * 1000 }, months: { weeks: 4, days: 30, hours: 30 * 24, minutes: 30 * 24 * 60, seconds: 30 * 24 * 60 * 60, milliseconds: 30 * 24 * 60 * 60 * 1000 } }, lowOrderMatrix), daysInYearAccurate = 146097.0 / 400, daysInMonthAccurate = 146097.0 / 4800, accurateMatrix = Object.assign({ years: { quarters: 4, months: 12, weeks: daysInYearAccurate / 7, days: daysInYearAccurate, hours: daysInYearAccurate * 24, minutes: daysInYearAccurate * 24 * 60, seconds: daysInYearAccurate * 24 * 60 * 60, milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000 }, quarters: { months: 3, weeks: daysInYearAccurate / 28, days: daysInYearAccurate / 4, hours: daysInYearAccurate * 24 / 4, minutes: daysInYearAccurate * 24 * 60 / 4, seconds: daysInYearAccurate * 24 * 60 * 60 / 4, milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000 / 4 }, months: { weeks: daysInMonthAccurate / 7, days: daysInMonthAccurate, hours: daysInMonthAccurate * 24, minutes: daysInMonthAccurate * 24 * 60, seconds: daysInMonthAccurate * 24 * 60 * 60, milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000 } }, lowOrderMatrix); const orderedUnits = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"]; const reverseUnits = orderedUnits.slice(0).reverse();

function clone(dur, alts, clear = false) { const conf = { values: clear ? alts.values : Object.assign({}, dur.values, alts.values || {}), loc: dur.loc.clone(alts.loc), conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy }; return new Duration(conf); }

function antiTrunc(n) { return n < 0 ? Math.floor(n) : Math.ceil(n); }

function convert(matrix, fromMap, fromUnit, toMap, toUnit) { const conv = matrix[toUnit][fromUnit], raw = fromMap[fromUnit] / conv, sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]), added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw); toMap[toUnit] += added; fromMap[fromUnit] -= added * conv; }

function normalizeValues(matrix, vals) { reverseUnits.reduce((previous, current) => { if (!isUndefined(vals[current])) { if (previous) { convert(matrix, vals, previous, vals, current); } return current; } else { return previous; } }, null); }

class Duration { constructor(config) { const accurate = config.conversionAccuracy === "longterm" || false; this.values = config.values; this.loc = config.loc || Locale.create(); this.conversionAccuracy = accurate ? "longterm" : "casual"; this.invalid = config.invalid || null; this.matrix = accurate ? accurateMatrix : casualMatrix; this.isLuxonDuration = true; } static fromMillis(count, opts) { return Duration.fromObject(Object.assign({ milliseconds: count }, opts)); } static fromObject(obj) { if (obj == null || typeof obj !== "object") { throw new InvalidArgumentError(`Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`); } return new Duration({ values: normalizeObject(obj, Duration.normalizeUnit, ["locale", "numberingSystem", "conversionAccuracy", "zone" ]), loc: Locale.fromObject(obj), conversionAccuracy: obj.conversionAccuracy }); } static fromISO(text, opts) { const [parsed] = parseISODuration(text); if (parsed) { const obj = Object.assign(parsed, opts); return Duration.fromObject(obj); } else { return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`); } } static invalid(reason, explanation = null) { if (!reason) { throw new InvalidArgumentError("need to specify a reason the Duration is invalid"); } const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation); if (Settings.throwOnInvalid) { throw new InvalidDurationError(invalid); } else { return new Duration({ invalid }); } } static normalizeUnit(unit) { const normalized = { year: "years", years: "years", quarter: "quarters", quarters: "quarters", month: "months", months: "months", week: "weeks", weeks: "weeks", day: "days", days: "days", hour: "hours", hours: "hours", minute: "minutes", minutes: "minutes", second: "seconds", seconds: "seconds", millisecond: "milliseconds", milliseconds: "milliseconds" }[unit ? unit.toLowerCase() : unit]; if (!normalized) throw new InvalidUnitError(unit); return normalized; } static isDuration(o) { return o && o.isLuxonDuration || false; } get locale() { return this.isValid ? this.loc.locale : null; } get numberingSystem() { return this.isValid ? this.loc.numberingSystem : null; } toFormat(fmt, opts = {}) { const fmtOpts = Object.assign({}, opts, { floor: opts.round !== false && opts.floor !== false }); return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID; } toObject(opts = {}) { if (!this.isValid) return {}; const base = Object.assign({}, this.values); if (opts.includeConfig) { base.conversionAccuracy = this.conversionAccuracy; base.numberingSystem = this.loc.numberingSystem; base.locale = this.loc.locale; } return base; } toISO() { if (!this.isValid) return null; let s = "P"; if (this.years !== 0) s += this.years + "Y"; if (this.months !== 0 || this.quarters !== 0) s += this.months + this.quarters * 3 + "M"; if (this.weeks !== 0) s += this.weeks + "W"; if (this.days !== 0) s += this.days + "D"; if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) s += "T"; if (this.hours !== 0) s += this.hours + "H"; if (this.minutes !== 0) s += this.minutes + "M"; if (this.seconds !== 0 || this.milliseconds !== 0) s += roundTo(this.seconds + this.milliseconds / 1000, 3) + "S"; if (s === "P") s += "T0S"; return s; } toJSON() { return this.toISO(); } toString() { return this.toISO(); } valueOf() { return this.as("milliseconds"); } plus(duration) { if (!this.isValid) return this; const dur = friendlyDuration(duration), result = {}; for (const k of orderedUnits) { if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) { result[k] = dur.get(k) + this.get(k); } } return clone(this, { values: result }, true); } minus(duration) { if (!this.isValid) return this; const dur = friendlyDuration(duration); return this.plus(dur.negate()); } mapUnits(fn) { if (!this.isValid) return this; const result = {}; for (const k of Object.keys(this.values)) { result[k] = asNumber(fn(this.values[k], k)); } return clone(this, { values: result }, true); } get(unit) { return this[Duration.normalizeUnit(unit)]; } set(values) { if (!this.isValid) return this; const mixed = Object.assign(this.values, normalizeObject(values, Duration.normalizeUnit, [])); return clone(this, { values: mixed }); } reconfigure({ locale, numberingSystem, conversionAccuracy } = {}) { const loc = this.loc.clone({ locale, numberingSystem }), opts = { loc }; if (conversionAccuracy) { opts.conversionAccuracy = conversionAccuracy; } return clone(this, opts); } as(unit) { return this.isValid ? this.shiftTo(unit).get(unit) : NaN; } normalize() { if (!this.isValid) return this; const vals = this.toObject(); normalizeValues(this.matrix, vals); return clone(this, { values: vals }, true); } shiftTo(...units) { if (!this.isValid) return this; if (units.length === 0) { return this; } units = units.map(u => Duration.normalizeUnit(u)); const built = {}, accumulated = {}, vals = this.toObject(); let lastUnit; for (const k of orderedUnits) { if (units.indexOf(k) >= 0) { lastUnit = k; let own = 0; for (const ak in accumulated) { own += this.matrix[ak][k] * accumulated[ak]; accumulated[ak] = 0; } if (isNumber(vals[k])) { own += vals[k]; } const i = Math.trunc(own); built[k] = i; accumulated[k] = own - i; } else if (isNumber(vals[k])) { accumulated[k] = vals[k]; } } for (const key in accumulated) { if (accumulated[key] !== 0) { built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key]; } } return clone(this, { values: built }, true).normalize(); } negate() { if (!this.isValid) return this; const negated = {}; for (const k of Object.keys(this.values)) { negated[k] = -this.values[k]; } return clone(this, { values: negated }, true); } get years() { return this.isValid ? this.values.years || 0 : NaN; } get quarters() { return this.isValid ? this.values.quarters || 0 : NaN; } get months() { return this.isValid ? this.values.months || 0 : NaN; } get weeks() { return this.isValid ? this.values.weeks || 0 : NaN; } get days() { return this.isValid ? this.values.days || 0 : NaN; } get hours() { return this.isValid ? this.values.hours || 0 : NaN; } get minutes() { return this.isValid ? this.values.minutes || 0 : NaN; } get seconds() { return this.isValid ? this.values.seconds || 0 : NaN; } get milliseconds() { return this.isValid ? this.values.milliseconds || 0 : NaN; } get isValid() { return this.invalid === null; } get invalidReason() { return this.invalid ? this.invalid.reason : null; } get invalidExplanation() { return this.invalid ? this.invalid.explanation : null; } equals(other) { if (!this.isValid || !other.isValid) { return false; } if (!this.loc.equals(other.loc)) { return false; } for (const u of orderedUnits) { if (this.values[u] !== other.values[u]) { return false; } } return true; } }

function friendlyDuration(durationish) { if (isNumber(durationish)) { return Duration.fromMillis(durationish); } else if (Duration.isDuration(durationish)) { return durationish; } else if (typeof durationish === "object") { return Duration.fromObject(durationish); } else { throw new InvalidArgumentError(`Unknown duration argument ${durationish} of type ${typeof durationish}`); } }

const INVALID$1 = "Invalid Interval"; function validateStartEnd(start, end) { if (!start || !start.isValid) { return Interval.invalid("missing or invalid start"); } else if (!end || !end.isValid) { return Interval.invalid("missing or invalid end"); } else if (end < start) { return Interval.invalid("end before start", `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`); } else { return null; } }

class Interval { constructor(config) { this.s = config.start; this.e = config.end; this.invalid = config.invalid || null; this.isLuxonInterval = true; } static invalid(reason, explanation = null) { if (!reason) { throw new InvalidArgumentError("need to specify a reason the Interval is invalid"); } const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation); if (Settings.throwOnInvalid) { throw new InvalidIntervalError(invalid); } else { return new Interval({ invalid }); } } static from