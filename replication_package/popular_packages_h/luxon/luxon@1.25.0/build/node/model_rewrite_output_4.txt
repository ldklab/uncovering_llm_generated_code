The Node.js code provided is a part of the Luxon library, a library for handling dates and times in JavaScript. Let's go over its functionality and then see a possible rewrite.

**Functionality:**
The code includes definitions and implementations for handling various aspects of date and time operations. It defines several error classes for managing errors related to dates and times, such as when a date-time is invalid, or a duration has conflicts. It includes format patterns and utility functions for parsing and formatting dates and times, converting between units, and handling time zones. Specifically:

1. **Error Handling:** Custom error classes like `LuxonError`, `InvalidDateTimeError`, `InvalidIntervalError`, etc., help manage exceptions specific to date-time operations. These are used across the library to throw or catch domain-specific errors.

2. **Formatting Constants:** Constants define various date and time formats (e.g., `DATE_SHORT`, `TIME_SIMPLE`), which are used for formatting a date-time object into a string.

3. **Utility Functions:** Utilitarian functions (e.g., `isUndefined`, `isNumber`, `hasIntl`, etc.) provide basic checks and functionalities to support the main logic of the library.

4. **Zone Management:** Classes for managing time zones such as `Zone`, `LocalZone`, `IANAZone`, and `FixedOffsetZone` ensure that operations on dates and times account for time zone differences correctly.

5. **Parsing and Formatting:** Functions for parsing ISO, RFC2822, and SQL-style date strings and turning them into Luxon `DateTime` objects.

6. **Constructing DateTime Objects:** Provides static methods on the `DateTime` class for creating date-time instances from various input formats (e.g., ISO dates, JavaScript Date objects, strings with specific formats).

Here's a possible rewrite organizing everything into a single markdown block. The idea is to simplify and organize classes, constants, and utility functions more clearly.

```javascript
'use strict';

// Export format
Object.defineProperty(exports, '__esModule', { value: true });

class LuxonError extends Error {}

// Custom errors for invalid operations
class InvalidDateTimeError extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
}

class InvalidIntervalError extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
}

class InvalidDurationError extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
}

class ConflictingSpecificationError extends LuxonError {}

class InvalidUnitError extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
}

class InvalidArgumentError extends LuxonError {}

class ZoneIsAbstractError extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
}

// Format constants used in localisation of dates and times
const n = "numeric", s = "short", l = "long";
const DATE_SHORT = { year: n, month: n, day: n };
const DATE_MED = { year: n, month: s, day: n };
const DATE_MED_WITH_WEEKDAY = { year: n, month: s, day: n, weekday: s };
const DATE_FULL = { year: n, month: l, day: n };
const DATE_HUGE = { year: n, month: l, day: n, weekday: l };
const TIME_SIMPLE = { hour: n, minute: n };
const TIME_WITH_SECONDS = { hour: n, minute: n, second: n };
const TIME_WITH_SHORT_OFFSET = { hour: n, minute: n, second: n, timeZoneName: s };
const TIME_WITH_LONG_OFFSET = { hour: n, minute: n, second: n, timeZoneName: l };
const TIME_24_SIMPLE = { hour: n, minute: n, hour12: false };
const TIME_24_WITH_SECONDS = { hour: n, minute: n, second: n, hour12: false };
const TIME_24_WITH_SHORT_OFFSET = { hour: n, minute: n, second: n, hour12: false, timeZoneName: s };
const TIME_24_WITH_LONG_OFFSET = { hour: n, minute: n, second: n, hour12: false, timeZoneName: l };
const DATETIME_SHORT = { year: n, month: n, day: n, hour: n, minute: n };
const DATETIME_SHORT_WITH_SECONDS = { year: n, month: n, day: n, hour: n, minute: n, second: n };
const DATETIME_MED = { year: n, month: s, day: n, hour: n, minute: n };
const DATETIME_MED_WITH_SECONDS = { year: n, month: s, day: n, hour: n, minute: n, second: n };
const DATETIME_MED_WITH_WEEKDAY = { year: n, month: s, day: n, weekday: s, hour: n, minute: n };
const DATETIME_FULL = { year: n, month: l, day: n, hour: n, minute: n, timeZoneName: s };
const DATETIME_FULL_WITH_SECONDS = { year: n, month: l, day: n, hour: n, minute: n, second: n, timeZoneName: s };
const DATETIME_HUGE = { year: n, month: l, day: n, weekday: l, hour: n, minute: n, timeZoneName: l };
const DATETIME_HUGE_WITH_SECONDS = { year: n, month: l, day: n, weekday: l, hour: n, minute: n, second: n, timeZoneName: l };

// Utility functions for type checking and other basic operations
function isUndefined(o) { return typeof o === "undefined"; }
function isNumber(o) { return typeof o === "number"; }
function isInteger(o) { return typeof o === "number" && o % 1 === 0; }
function isString(o) { return typeof o === "string"; }

// Intl support check
function hasIntl() { try { return typeof Intl !== "undefined" && Intl.DateTimeFormat; } catch (e) { return false; } }
function hasFormatToParts() { return !isUndefined(Intl.DateTimeFormat.prototype.formatToParts); }
function hasRelative() { try { return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat; } catch (e) { return false; } }

// Classes for handling zones
class Zone { /* Zone interface methods like type, name, offsetName, etc. */ }
class LocalZone extends Zone { /* Implementation specifics */ }
class IANAZone extends Zone { /* Implementation specifics */ }
class FixedOffsetZone extends Zone { /* Implementation specifics */ }
class InvalidZone extends Zone { /* Implementation specifics */ }

// Classes for Duration handling
class Duration { /* Class specifics about handling Durations */ }
class Interval { /* Class specifics about handling Intervals */ }

// Utility classes for Locale and Settings
class Settings { /* Static getters and setters for overall Luxon behavior */ }
class Formatter { /* Class specifics for formatting dates and times */ }
class Locale { /* Class specifics about handling locales */ }

// Main DateTime class for handling various date-time related operations
class DateTime {
  static fromISO(text, opts) { /* Implementation specifics for creating from ISO */ }
  static fromRFC2822(text, opts) { /* Implementation specifics for creating from RFC2822 */ }
  static fromHTTP(text, opts) { /* Implementation specifics for creating from HTTP header date */ }
  static fromSQL(text, opts) { /* Implementation specifics for creating DateTime from SQL */ }
  
  constructor(config) { /* Basic constructor for DateTime */ }

  // Other date-time methods like plus, minus, diff, startOf, endOf, toFormat, etc.
  static isDateTime(o) { return o && o.isLuxonDateTime || false; }
}

exports.DateTime = DateTime;
exports.Duration = Duration;
exports.Interval = Interval;
exports.Settings = Settings;
```