The provided Node.js code is a module that exports a function `simplifyAccess`, which processes JavaScript code to simplify assignment expressions and update expressions using Babel. Here's a breakdown of its functionality:

1. **SimplifyAccess Function**: 
   - The `simplifyAccess` function takes in a `path` and `bindingNames`. The `path` typically represents a part of the AST (Abstract Syntax Tree) provided by AST parsers such as Babel, while `bindingNames` is a set containing variable names to apply the simplification on.
   - The function calls `traverse` method on the `path` which initiates AST traversal using the `simpleAssignmentVisitor`.

2. **simpleAssignmentVisitor**: 
   - This is an object that provides handlers for particular node types in the AST, specifically `UpdateExpression` and `AssignmentExpression`.
   
   - **UpdateExpression**: 
     - It simplifies unary update operators (`++` and `--`) to assignment expressions (`+= 1` or `-= 1`) or maintains the order of operations/side-effects through generated sequence expressions.
     - Checks are performed to ensure the expression updates are valid within the local scope and involve identifiers that are present in `bindingNames`.

   - **AssignmentExpression**: 
     - It simplifies compound assignment expressions (such as `+=`, `-=`, etc.) to basic assignment expressions by re-arranging expressions. This involves transforming expressions like `a += b` to `a = a + b`.
     - It ensures simplifications are performed only once, avoiding duplicate transformations by utilizing a `WeakSet` to track processed nodes.

3. **@babel/types**: 
   - The module uses Babel's type definitions to construct and modify AST nodes, which include expressions like `assignmentExpression`, `binaryExpression`, `unaryExpression`, `numericLiteral`, and `sequenceExpression`.

Hereâ€™s a possible re-write of the code following the above explanation: 

```javascript
"use strict";

const babelTypes = require("@babel/types");

module.exports = simplifyAccess;

// Function that simplifies AST Node expressions
function simplifyAccess(path, bindingNames) {
  path.traverse(visitor, {
    scope: path.scope,
    bindingNames,
    seenNodes: new WeakSet()
  });
}

// Visitor object to handle specific nodes in the AST
const visitor = {
  UpdateExpression: {
    exit: function(path) {
      const { scope, bindingNames } = this;
      const argument = path.get("argument");

      if (!argument.isIdentifier()) return;
      const localName = argument.node.name;
      if (!bindingNames.has(localName) || 
          scope.getBinding(localName) !== path.scope.getBinding(localName)) return;

      if (path.parentPath.isExpressionStatement() && !path.isCompletionRecord()) {
        const operator = path.node.operator === "++" ? "+=" : "-=";
        path.replaceWith(babelTypes.assignmentExpression(operator, argument.node, babelTypes.numericLiteral(1)));
      } else if (path.node.prefix) {
        path.replaceWith(
          babelTypes.assignmentExpression(
            "=", 
            babelTypes.identifier(localName), 
            babelTypes.binaryExpression(
              path.node.operator[0], 
              babelTypes.unaryExpression("+", argument.node), 
              babelTypes.numericLiteral(1)
            )
          )
        );
      } else {
        const oldIdentifier = path.scope.generateUidIdentifierBasedOnNode(argument.node, "old");
        path.scope.push({ id: oldIdentifier });

        const binaryExpr = babelTypes.binaryExpression(
          path.node.operator[0], 
          babelTypes.identifier(oldIdentifier.name), 
          babelTypes.numericLiteral(1)
        );

        path.replaceWith(
          babelTypes.sequenceExpression([
            babelTypes.assignmentExpression("=", babelTypes.identifier(oldIdentifier.name), babelTypes.unaryExpression("+", argument.node)),
            babelTypes.assignmentExpression("=", argument.node, binaryExpr),
            babelTypes.identifier(oldIdentifier.name)
          ])
        );
      }
    }
  },
  AssignmentExpression: {
    exit: function(path) {
      const { scope, seenNodes, bindingNames } = this;
      if (path.node.operator === "=") return;
      if (seenNodes.has(path.node)) return;

      seenNodes.add(path.node);
      const left = path.get("left");

      if (!left.isIdentifier()) return;
      const localName = left.node.name;
      if (!bindingNames.has(localName) || 
          scope.getBinding(localName) !== path.scope.getBinding(localName)) return;

      path.node.right = babelTypes.binaryExpression(
        path.node.operator.slice(0, -1), 
        babelTypes.cloneNode(left.node), 
        path.node.right
      );
      path.node.operator = "=";
    }
  }
};
```