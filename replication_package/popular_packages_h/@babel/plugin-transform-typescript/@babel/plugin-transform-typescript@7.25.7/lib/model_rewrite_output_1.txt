The provided Node.js code is a Babel plugin for transforming TypeScript into JavaScript. This plugin includes several transformations that handle different syntax related to TypeScript, including type aliases, enums, namespaces, and type assertions. It removes TypeScript-specific constructs that are not directly translatable to JavaScript, such as type annotations and TypeScript-specific extensions to functions, classes, and modules. The plugin uses different helpers from Babel to manage class features, enums, and namespaces, and it adds certain compliance checks regarding CommonJS module transformations.

```javascript
"use strict";

import { declare } from "@babel/helper-plugin-utils";
import syntaxTypeScript from "@babel/plugin-syntax-typescript";
import createClassFeaturesPlugin from "@babel/helper-create-class-features-plugin";
import transformConstEnum from "./const-enum.js";
import transformEnum from "./enum.js";
import registerGlobalType from "./global-types.js";
import namespaceTransform from "./namespace.js";

function isInType(path) {
  switch (path.parent.type) {
    case "TSTypeReference":
    case "TSExpressionWithTypeArguments":
    case "TSTypeQuery":
      return true;
    case "TSQualifiedName":
      return path.parentPath.findParent((p) => p.type !== "TSQualifiedName").type !== "TSImportEqualsDeclaration";
    case "ExportSpecifier":
      return path.parent.exportKind === "type" || path.parentPath.parent.exportKind === "type";
    default:
      return false;
  }
}

const NEEDS_EXPLICIT_ESM = new WeakMap();
const PARSED_PARAMS = new WeakSet();

function safeRemove(path) {
  const ids = path.getBindingIdentifiers();
  for (const name of Object.keys(ids)) {
    const binding = path.scope.getBinding(name);
    if (binding && binding.identifier === ids[name]) {
      binding.scope.removeBinding(name);
    }
  }
  path.remove();
}

function assertCjsTransformEnabled(path, pass, wrong, suggestion, extra = "") {
  if (pass.file.get("@babel/plugin-transform-modules-*") !== "commonjs") {
    throw path.buildCodeFrameError(
      `\`${wrong}\` is only supported when compiling modules to CommonJS.\n` +
      `Please consider using \`${suggestion}\`${extra} or add ` +
      `@babel/plugin-transform-modules-commonjs to your Babel config.`
    );
  }
}

export default declare((api, opts) => {
  api.assertVersion(7);
  
  const {
    types: t,
    template
  } = api;

  const {
    allowNamespaces = true,
    jsxPragma = "React.createElement",
    jsxPragmaFrag = "React.Fragment",
    onlyRemoveTypeImports = false,
    optimizeConstEnums = false
  } = opts;

  var {
    allowDeclareFields = false
  } = opts;

  const classMemberVisitors = {
    field(path) {
      const {
        node
      } = path;

      if (!allowDeclareFields && node.declare) {
        throw path.buildCodeFrameError(
          `The 'declare' modifier is only allowed when the 'allowDeclareFields' option is enabled.`
        );
      }

      if (node.declare && (!node.value || !node.decorators) || node.definite && (!node.value || !allowDeclareFields && !node.decorators && !t.isClassPrivateProperty(node))) {
        path.remove();
      } else {
        node.accessibility = node.abstract = node.readonly = node.optional = node.typeAnnotation = node.definite = node.declare = node.override = null;
      }
    },
    
    method({ node }) {
      node.accessibility = node.abstract = node.optional = node.override = null;
    },
    
    constructor(path, classPath) {
      const assigns = [];
      const { scope } = path;

      for (const paramPath of path.get("params")) {
        const param = paramPath.node;
        if (param.type === "TSParameterProperty") {
          const parameter = param.parameter;
          if (PARSED_PARAMS.has(parameter)) continue;
          PARSED_PARAMS.add(parameter);
          let id;

          if (t.isIdentifier(parameter)) {
            id = parameter;
          } else if (t.isAssignmentPattern(parameter) && t.isIdentifier(parameter.left)) {
            id = parameter.left;
          } else {
            throw paramPath.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
          }

          assigns.push(template.statement.ast`
            this.${t.cloneNode(id)} = ${t.cloneNode(id)}
          `);
          paramPath.replaceWith(paramPath.get("parameter"));
          scope.registerBinding("param", paramPath);
        }
      }

      createClassFeaturesPlugin.injectInitialization(classPath, path, assigns);
    }
  };

  return {
    name: "transform-typescript",
    inherits: syntaxTypeScript,
    visitor: {
      Pattern: visitPattern,
      Identifier: visitPattern,
      RestElement: visitPattern,

      Program: {
        enter(path, state) {
          const { file } = state;
          let fileJsxPragma = null;
          let fileJsxPragmaFrag = null;
          const programScope = path.scope;

          if (!registerGlobalType.GLOBAL_TYPES.has(programScope)) {
            registerGlobalType.GLOBAL_TYPES.set(programScope, new Set());
          }

          if (file.ast.comments) {
            for (const comment of file.ast.comments) {
              const jsxMatches = /\*?\s*@jsx((?:Frag)?)\s+(\S+)/.exec(comment.value);
              if (jsxMatches) {
                if (jsxMatches[1]) {
                  fileJsxPragmaFrag = jsxMatches[2];
                } else {
                  fileJsxPragma = jsxMatches[2];
                }
              }
            }
          }

          let pragmaImportName = fileJsxPragma || jsxPragma;
          if (pragmaImportName) {
            [pragmaImportName] = pragmaImportName.split(".");
          }

          let pragmaFragImportName = fileJsxPragmaFrag || jsxPragmaFrag;
          if (pragmaFragImportName) {
            [pragmaFragImportName] = pragmaFragImportName.split(".");
          }

          for (let stmt of path.get("body")) {
            if (stmt.isImportDeclaration()) {
              if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {
                NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);
              }

              if (stmt.node.importKind === "type") {
                for (const specifier of stmt.node.specifiers) {
                  registerGlobalType(programScope, specifier.local.name);
                }
                stmt.remove();
                continue;
              }

              const importsToRemove = new Set();
              const specifiersLength = stmt.node.specifiers.length;

              const isAllSpecifiersElided = () =>
                specifiersLength > 0 && specifiersLength === importsToRemove.size;

              for (const specifier of stmt.node.specifiers) {
                if (specifier.type === "ImportSpecifier" && specifier.importKind === "type") {
                  registerGlobalType(programScope, specifier.local.name);
                  const binding = stmt.scope.getBinding(specifier.local.name);
                  if (binding) {
                    importsToRemove.add(binding.path);
                  }
                }
              }

              if (onlyRemoveTypeImports) {
                NEEDS_EXPLICIT_ESM.set(path.node, false);
              } else {
                if (stmt.node.specifiers.length === 0) {
                  NEEDS_EXPLICIT_ESM.set(path.node, false);
                  continue;
                }

                for (const specifier of stmt.node.specifiers) {
                  const binding = stmt.scope.getBinding(specifier.local.name);
                  if (binding && !importsToRemove.has(binding.path)) {
                    if (isImportTypeOnly({
                      binding,
                      programPath: path,
                      pragmaImportName,
                      pragmaFragImportName
                    })) {
                      importsToRemove.add(binding.path);
                    } else {
                      NEEDS_EXPLICIT_ESM.set(path.node, false);
                    }
                  }
                }
              }

              if (isAllSpecifiersElided() && !onlyRemoveTypeImports) {
                stmt.remove();
              } else {
                for (const importPath of importsToRemove) {
                  importPath.remove();
                }
              }

              continue;
            }

            if (stmt.isExportDeclaration()) {
              stmt = stmt.get("declaration");
            }

            if (
              stmt.isVariableDeclaration({ declare: true }) ||
              stmt.isTSTypeAliasDeclaration() ||
              stmt.isTSDeclareFunction() && stmt.get("id").isIdentifier() ||
              stmt.isTSInterfaceDeclaration() ||
              stmt.isClassDeclaration({ declare: true }) ||
              stmt.isTSEnumDeclaration({ declare: true }) ||
              stmt.isTSModuleDeclaration({ declare: true }) && stmt.get("id").isIdentifier()
            ) {
              registerGlobalType(programScope, stmt.node.id.name);
            }
          }
        },
        
        exit(path) {
          if (path.node.sourceType === "module" && NEEDS_EXPLICIT_ESM.get(path.node)) {
            path.pushContainer("body", t.exportNamedDeclaration());
          }
        }
      },

      ExportNamedDeclaration(path, state) {
        if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {
          NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);
        }

        if (path.node.exportKind === "type") {
          path.remove();
          return;
        }

        if (
          path.node.source &&
          path.node.specifiers.length > 0 &&
          path.node.specifiers.every(
            (specifier) =>
              specifier.type === "ExportSpecifier" && specifier.exportKind === "type"
          )
        ) {
          path.remove();
          return;
        }

        if (
          !path.node.source &&
          path.node.specifiers.length > 0 &&
          path.node.specifiers.every(
            (specifier) =>
              t.isExportSpecifier(specifier) &&
              registerGlobalType.isGlobalType(path, specifier.local.name)
          )
        ) {
          path.remove();
          return;
        }

        if (t.isTSModuleDeclaration(path.node.declaration)) {
          const namespace = path.node.declaration;
          const { id } = namespace;
          if (t.isIdentifier(id)) {
            if (path.scope.hasOwnBinding(id.name)) {
              path.replaceWith(namespace);
            } else {
              const [newExport] = path.replaceWithMultiple([
                t.exportNamedDeclaration(
                  t.variableDeclaration("let", [t.variableDeclarator(t.cloneNode(id))])
                ),
                namespace,
              ]);
              path.scope.registerDeclaration(newExport);
            }
          }
        }

        NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);
      },

      ExportAllDeclaration(path) {
        if (path.node.exportKind === "type") path.remove();
      },

      ExportSpecifier(path) {
        const parent = path.parent;
        if (
          !parent.source &&
          registerGlobalType.isGlobalType(path, path.node.local.name) ||
          path.node.exportKind === "type"
        ) {
          path.remove();
        }
      },
      
      ExportDefaultDeclaration(path, state) {
        if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {
          NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);
        }

        if (
          t.isIdentifier(path.node.declaration) &&
          registerGlobalType.isGlobalType(path, path.node.declaration.name)
        ) {
          path.remove();
          return;
        }

        NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);
      },

      TSDeclareFunction(path) {
        safeRemove(path);
      },

      TSDeclareMethod(path) {
        safeRemove(path);
      },

      VariableDeclaration(path) {
        if (path.node.declare) {
          safeRemove(path);
        }
      },

      VariableDeclarator({ node }) {
        if (node.definite) node.definite = null;
      },

      TSIndexSignature(path) {
        path.remove();
      },

      ClassDeclaration(path) {
        const { node } = path;
        if (node.declare) {
          safeRemove(path);
        }
      },

      Class(path) {
        const { node } = path;
        if (node.typeParameters) node.typeParameters = null;
        if (node.superTypeParameters) node.superTypeParameters = null;
        if (node.implements) node.implements = null;
        if (node.abstract) node.abstract = null;
        
        path.get("body.body").forEach((child) => {
          if (child.isClassMethod() || child.isClassPrivateMethod()) {
            if (child.node.kind === "constructor") {
              classMemberVisitors.constructor(child, path);
            } else {
              classMemberVisitors.method(child);
            }
          } else if (
            child.isClassProperty() ||
            child.isClassPrivateProperty() ||
            child.isClassAccessorProperty()
          ) {
            classMemberVisitors.field(child);
          }
        });
      },

      Function(path) {
        const { node } = path;
        if (node.typeParameters) node.typeParameters = null;
        if (node.returnType) node.returnType = null;
        
        const params = node.params;
        if (params.length > 0 && t.isIdentifier(params[0], { name: "this" })) {
          params.shift();
        }
      },

      TSModuleDeclaration(path) {
        namespaceTransform(path, allowNamespaces);
      },

      TSInterfaceDeclaration(path) {
        path.remove();
      },

      TSTypeAliasDeclaration(path) {
        path.remove();
      },

      TSEnumDeclaration(path) {
        if (optimizeConstEnums && path.node.const) {
          transformConstEnum(path, t);
        } else {
          transformEnum(path, t);
        }
      },

      TSImportEqualsDeclaration(path, pass) {
        const { id, moduleReference, isExport } = path.node;
        let init;
        let varKind;

        if (t.isTSExternalModuleReference(moduleReference)) {
          assertCjsTransformEnabled(
            path,
            pass,
            `import ${id.name} = require(...);`,
            `import ${id.name} from '...';`,
            " alongside Typescript's --allowSyntheticDefaultImports option"
          );
          init = t.callExpression(t.identifier("require"), [moduleReference.expression]);
          varKind = "const";
        } else {
          init = entityNameToExpr(moduleReference);
          varKind = "var";
        }

        const newNode = t.variableDeclaration(varKind, [t.variableDeclarator(id, init)]);
        path.replaceWith(isExport ? t.exportNamedDeclaration(newNode) : newNode);
        path.scope.registerDeclaration(path);
      },
      
      TSExportAssignment(path, pass) {
        assertCjsTransformEnabled(path, pass, `export = <value>;`, `export default <value>;`);
        path.replaceWith(template.statement.ast`module.exports = ${path.node.expression}`);
      },

      TSTypeAssertion(path) {
        path.replaceWith(path.node.expression);
      },

      [`TSAsExpression${t.tsSatisfiesExpression ? "|TSSatisfiesExpression" : ""}`](path) {
        let { node } = path;
        do {
          node = node.expression;
        } while (t.isTSAsExpression(node) || t.tsSatisfiesExpression && t.tsSatisfiesExpression(node));
        path.replaceWith(node);
      },

      [api.types.tsInstantiationExpression ? "TSNonNullExpression|TSInstantiationExpression" : "TSNonNullExpression"](path) {
        path.replaceWith(path.node.expression);
      },

      CallExpression(path) {
        path.node.typeParameters = null;
      },

      OptionalCallExpression(path) {
        path.node.typeParameters = null;
      },

      NewExpression(path) {
        path.node.typeParameters = null;
      },

      JSXOpeningElement(path) {
        path.node.typeParameters = null;
      },

      TaggedTemplateExpression(path) {
        path.node.typeParameters = null;
      }
    }
  };

  function entityNameToExpr(node) {
    if (t.isTSQualifiedName(node)) {
      return t.memberExpression(entityNameToExpr(node.left), node.right);
    }
    return node;
  }

  function visitPattern({ node }) {
    if (node.typeAnnotation) node.typeAnnotation = null;
    if (t.isIdentifier(node) && node.optional) node.optional = null;
  }

  function isImportTypeOnly({
    binding,
    programPath,
    pragmaImportName,
    pragmaFragImportName
  }) {
    for (const path of binding.referencePaths) {
      if (!isInType(path)) {
        return false;
      }
    }
    if (binding.identifier.name !== pragmaImportName && binding.identifier.name !== pragmaFragImportName) {
      return true;
    }

    let sourceFileHasJsx = false;
    programPath.traverse({
      "JSXElement|JSXFragment"(path) {
        sourceFileHasJsx = true;
        path.stop();
      }
    });

    return !sourceFileHasJsx;
  }
});
```