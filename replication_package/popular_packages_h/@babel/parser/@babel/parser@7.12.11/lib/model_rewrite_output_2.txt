### Explanation

The Node.js code provided is a module exporting a JavaScript parser implemented similarly to Babel's parser. It is structured to parse JavaScript source code and convert it into an Abstract Syntax Tree (AST). The script supports multiple plugins allowing the parsing of different JavaScript and ECMAScript proposal syntax features.

1. **Modules and Exports:**
    - Uses `Object.defineProperty` to define `__esModule` for compatibility with other module systems.
    - The main parsing function, `parse`, is exported to allow external usage.

2. **Parsing Core:**
    - The `Parser` class extends various helper classes to handle language tokens, state management, and specific syntax features like decorators and private class properties.
    - Numerous helper functions and classes (like `Token`, `State`, `Tokenizer`) are defined to tokenize input, manage parser state, and extend functionality using plugins.

3. **Plugin System:**
    - A robust plugin system is in place to manage and validate syntax plugin features (e.g., `decorators`, `dynamicImport`).
    - Includes plugins for various JavaScript features (`jsx`, `typescript`, `flow`, etc.), enabling the parser to handle a wide array of syntax.

4. **Parser Workflow:**
    - Upon execution, the parser processes the input into tokens, attempts to match these tokens against the expected JavaScript grammar, and constructs an AST, representing the code's syntactic structure.
    - Error handling and strict mode are considered during parsing.

5. **Function Entry Points:**
    - `parse` and `parseExpression` serve as the main entry points to convert source code to an AST or parse single expressions.

6. **Error Handling:**
    - Implements error mechanisms to throw descriptive errors when encountering unexpected tokens or syntax violations, configurable by the user.

### Rewritten Code

```javascript
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const parserPlugins = {
  decorators: {
    validate(options) {
      if (options.decoratorsBeforeExport == null) {
        throw new Error(
          "The 'decorators' plugin requires a 'decoratorsBeforeExport' option, which must be a boolean."
        );
      }
    },
  },
};

const defaultOptions = {
  sourceType: "script",
  plugins: [],
  strictMode: null,
  errorRecovery: false,
};

class ParsingState {
  constructor(options) {
    this.strict = options.strictMode === false ? false : options.sourceType === "module";
    this.pos = 0;
    this.type = null;
    // other state properties...
  }

  initParserState(input) {
    this.curLine = 1;
    this.startLoc = this.endLoc = this.createPosition();
    // other initializations...
  }

  createPosition() {
    return { line: this.curLine, column: this.pos - this.lineStart };
  }
  
  clone(skipArrays = false) {
    const state = new ParsingState();
    for (const key in this) {
      let value = this[key];
      if (!skipArrays && Array.isArray(value)) {
        value = value.slice();
      }
      state[key] = value;
    }
    return state;
  }
}

class Parser {
  constructor(options, input) {
    this.options = { ...defaultOptions, ...options };
    this.plugins = this.initializePlugins(this.options.plugins);
    this.state = new ParsingState(this.options);
    this.state.initParserState(input);
    this.input = input;
    // additional setup...
  }

  initializePlugins(plugins) {
    const pluginMap = new Map();
    for (const plugin of plugins) {
      const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];
      pluginMap.set(name, options || {});
      parserPlugins[name]?.validate(options);
    }
    return pluginMap;
  }

  parse() {
    try {
      this.state.errors = null;
      const file = this.createNode("File");
      const program = this.createNode("Program");
      this.nextToken();
      program.body = this.parseProgramBody();
      file.program = program;
      file.comments = this.state.comments;
      this.finalizeParsing(file);
      return file;
    } catch (err) {
      this.handleError(err);
    }
  }

  parseProgramBody() {
    const body = [];
    while (!this.isEndOfFile()) {
      body.push(this.parseStatement());
    }
    return body;
  }

  isEndOfFile() {
    return this.state.type === 'eof';
  }

  parseStatement() {
    this.skipWhitespace();
    // Logic to parse different types of statements...
  }

  skipWhitespace() {
    // Logic for skipping whitespace...
  }

  finalizeParsing(ast) {
    ast.errors = this.state.errors;
    return ast;
  }

  handleError(error) {
    if (this.options.errorRecovery) {
      this.state.errors.push(error);
    } else {
      throw error;
    }
  }

  createNode(type) {
    return { type, start: this.state.pos, end: null, loc: this.state.createPosition() };
  }
}

function parse(input, options) {
  const parser = new Parser(options, input);
  return parser.parse();
}

exports.parse = parse;
```