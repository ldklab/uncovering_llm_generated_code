The given Node.js code defines a Babel plugin designed to transform JavaScript class syntax. It uses various Babel helper utilities and core functions to achieve its transformation goals. Here's a brief explanation of its functionality:

1. **Imports and Initialization:**
   - Imports helper utilities and core functions from Babel.
   - Imports a custom class transformation function.
   - Determines built-in classes for "builtin" and "browser" environments using the `globals` package.
   - The `builtinClasses` set is created to contain these class names after filtering for capitalized names, which typically represent class names in JavaScript.

2. **Babel Plugin Declaration:**
   - The plugin is declared using `@babel/helper-plugin-utils`'s `declare` function, asserting that Babel version 7 or higher is being used.
   - A visitor object is defined for traversing the AST (Abstract Syntax Tree) and modifying class-related nodes.

3. **AST Node Visitors:**
   - **ExportDefaultDeclaration:** Splits export default declarations when they are class declarations using a helper utility.
   - **ClassDeclaration:** Replaces class declarations with a `let` variable declaration if the class is anonymous or adds a reference name using Babel's scope utility.
   - **ClassExpression:** Performs transformations on class expressions that haven't been visited yet. It potentially replaces inferred names to ensure consistency and applies class transformations. If the class expression part of a call expression is an arrow function, it converts it to a regular function expression.

Below is the rewritten code:

```javascript
"use strict";

const { declare } = require("@babel/helper-plugin-utils");
const annotateAsPure = require("@babel/helper-annotate-as-pure").default;
const functionName = require("@babel/helper-function-name").default;
const splitExportDeclaration = require("@babel/helper-split-export-declaration").default;
const { types } = require("@babel/core");
const globals = require("globals").default;
const transformClass = require("./transformClass").default;

const getBuiltinClasses = category => Object.keys(globals[category]).filter(name => /^[A-Z]/.test(name));
const builtinClasses = new Set([...getBuiltinClasses("builtin"), ...getBuiltinClasses("browser")]);

module.exports = declare((api, { loose }) => {
  api.assertVersion(7);

  const VISITED = Symbol();
  
  return {
    name: "transform-classes",
    visitor: {
      ExportDefaultDeclaration(path) {
        if (!path.get("declaration").isClassDeclaration()) return;
        splitExportDeclaration(path);
      },

      ClassDeclaration(path) {
        const { node } = path;
        const ref = node.id || path.scope.generateUidIdentifier("class");
        path.replaceWith(types.variableDeclaration("let", [types.variableDeclarator(ref, types.toExpression(node))]));
      },

      ClassExpression(path, state) {
        const { node } = path;
        if (node[VISITED]) return;
        const inferred = functionName(path);

        if (inferred && inferred !== node) {
          path.replaceWith(inferred);
          return;
        }

        node[VISITED] = true;
        path.replaceWith(transformClass(path, state.file, builtinClasses, loose));

        if (path.isCallExpression()) {
          annotateAsPure(path);

          if (path.get("callee").isArrowFunctionExpression()) {
            path.get("callee").arrowFunctionToExpression();
          }
        }
      }
    }
  };
});
```