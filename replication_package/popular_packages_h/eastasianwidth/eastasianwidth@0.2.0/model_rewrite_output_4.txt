The provided code defines an object `eaw` which contains functions to calculate and handle the East Asian Width (EAW) properties of characters in a string. The EAW categorizes characters into various width classes based on their Unicode values. These classes are Fullwidth ('F'), Halfwidth ('H'), Wide ('W'), Narrow ('Na'), Ambiguous ('A'), and Neutral ('N').

Here's a breakdown of the functions:

1. **eastAsianWidth(character):** Determines the EAW class of a given character based on its Unicode code point.
2. **characterLength(character):** Returns the display width of a characterâ€”2 for 'F', 'W', or 'A' characters, 1 otherwise.
3. **stringToArray(string):** Converts a string into an array, accounting for surrogate pairs.
4. **length(string):** Computes the total display width of a string based on its characters' EAW widths.
5. **slice(text, start, end):** Similar to the native `String.prototype.slice` method, but operates on EAW character widths. It slices a string based on start and end EAW positions.

The code also ensures compatibility for both Node.js and browser environments, assigning `eaw` to `module.exports` or `window.eastasianwidth` accordingly.

Here's the rewritten code:

```javascript
const eaw = {};

if (typeof module === 'undefined') {
  window.eastasianwidth = eaw;
} else {
  module.exports = eaw;
}

eaw.eastAsianWidth = function (character) {
  const x = character.charCodeAt(0);
  const y = (character.length === 2) ? character.charCodeAt(1) : 0;
  let codePoint = x;

  if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF) {
    codePoint = ((x & 0x3FF) << 10) | (y & 0x3FF);
    codePoint += 0x10000;
  }

  if (codePoint === 0x3000 ||
    (0xFF01 <= codePoint && codePoint <= 0xFF60) ||
    (0xFFE0 <= codePoint && codePoint <= 0xFFE6)) {
    return 'F';
  }

  if (codePoint === 0x20A9 ||
    (0xFF61 <= codePoint && codePoint <= 0xFFBE) ||
    (0xFFC2 <= codePoint && codePoint <= 0xFFC7) ||
    (0xFFCA <= codePoint && codePoint <= 0xFFCF) ||
    (0xFFD2 <= codePoint && codePoint <= 0xFFD7) ||
    (0xFFDA <= codePoint && codePoint <= 0xFFDC) ||
    (0xFFE8 <= codePoint && codePoint <= 0xFFEE)) {
    return 'H';
  }

  if ((0x1100 <= codePoint && codePoint <= 0x115F) ||
    (0x11A3 <= codePoint && codePoint <= 0x11A7) ||
    (0x11FA <= codePoint && codePoint <= 0x11FF) ||
    (0x2329 <= codePoint && codePoint <= 0x232A) ||
    (0x2E80 <= codePoint && codePoint <= 0x2E99) ||
    (0x2E9B <= codePoint && codePoint <= 0x2EF3) ||
    (0x2F00 <= codePoint && codePoint <= 0x2FD5) ||
    (0x2FF0 <= codePoint && codePoint <= 0x2FFB) ||
    (0x3001 <= codePoint && codePoint <= 0x303E) ||
    (0x3041 <= codePoint && codePoint <= 0x3096) ||
    (0x3099 <= codePoint && codePoint <= 0x30FF) ||
    (0x3105 <= codePoint && codePoint <= 0x312D) ||
    (0x3131 <= codePoint && codePoint <= 0x318E) ||
    (0x3190 <= codePoint && codePoint <= 0x31BA) ||
    (0x31C0 <= codePoint && codePoint <= 0x31E3) ||
    (0x31F0 <= codePoint && codePoint <= 0x321E) ||
    (0x3220 <= codePoint && codePoint <= 0x3247) ||
    (0x3250 <= codePoint && codePoint <= 0x32FE) ||
    (0x3300 <= codePoint && codePoint <= 0x4DBF) ||
    (0x4E00 <= codePoint && codePoint <= 0xA48C) ||
    (0xA490 <= codePoint && codePoint <= 0xA4C6) ||
    (0xA960 <= codePoint && codePoint <= 0xA97C) ||
    (0xAC00 <= codePoint && codePoint <= 0xD7A3) ||
    (0xD7B0 <= codePoint && codePoint <= 0xD7C6) ||
    (0xD7CB <= codePoint && codePoint <= 0xD7FB) ||
    (0xF900 <= codePoint && codePoint <= 0xFAFF) ||
    (0xFE10 <= codePoint && codePoint <= 0xFE19) ||
    (0xFE30 <= codePoint && codePoint <= 0xFE52) ||
    (0xFE54 <= codePoint && codePoint <= 0xFE66) ||
    (0xFE68 <= codePoint && codePoint <= 0xFE6B) ||
    (0x1B000 <= codePoint && codePoint <= 0x1B001) ||
    (0x1F200 <= codePoint && codePoint <= 0x1F202) ||
    (0x1F210 <= codePoint && codePoint <= 0x1F23A) ||
    (0x1F240 <= codePoint && codePoint <= 0x1F248) ||
    (0x1F250 <= codePoint && codePoint <= 0x1F251) ||
    (0x20000 <= codePoint && codePoint <= 0x2F73F) ||
    (0x2B740 <= codePoint && codePoint <= 0x2FFFD) ||
    (0x30000 <= codePoint && codePoint <= 0x3FFFD)) {
    return 'W';
  }

  if ((0x0020 <= codePoint && codePoint <= 0x007E) ||
    (0x00A2 <= codePoint && codePoint <= 0x00A3) ||
    (0x00A5 <= codePoint && codePoint <= 0x00A6) ||
    codePoint === 0x00AC ||
    codePoint === 0x00AF ||
    (0x27E6 <= codePoint && codePoint <= 0x27ED) ||
    (0x2985 <= codePoint && codePoint <= 0x2986)) {
    return 'Na';
  }

  const ambiguousCharacters = [
    0x00A1, 0x00A4, [0x00A7, 0x00A8], 0x00AA, [0x00AD, 0x00AE], [0x00B0, 0x00B4],
    [0x00B6, 0x00BA], [0x00BC, 0x00BF], 0x00C6, 0x00D0, [0x00D7, 0x00D8],
    [0x00DE, 0x00E1], 0x00E6, [0x00E8, 0x00EA], [0x00EC, 0x00ED], 0x00F0,
    [0x00F2, 0x00F3], [0x00F7, 0x00FA], 0x00FC, 0x00FE, 0x0101, 0x0111,
    0x0113, 0x011B, [0x0126, 0x0127], 0x012B, [0x0131, 0x0133], 0x0138,
    [0x013F, 0x0142], 0x0144, [0x0148, 0x014B], 0x014D, [0x0152, 0x0153],
    [0x0166, 0x0167], 0x016B, 0x01CE, 0x01D0, 0x01D2, 0x01D4, 0x01D6, 0x01D8,
    0x01DA, 0x01DC, 0x0251, 0x0261, 0x02C4, 0x02C7, [0x02C9, 0x02CB], 0x02CD,
    0x02D0, [0x02D8, 0x02DB], 0x02DD, 0x02DF, [0x0300, 0x036F], [0x0391, 0x03A1],
    [0x03A3, 0x03A9], [0x03B1, 0x03C1], [0x03C3, 0x03C9], 0x0401, [0x0410, 0x044F],
    0x0451, 0x2010, [0x2013, 0x2016], [0x2018, 0x2019], [0x201C, 0x201D],
    [0x2020, 0x2022], [0x2024, 0x2027], 0x2030, [0x2032, 0x2033], 0x2035, 0x203B,
    0x203E, 0x2074, 0x207F, [0x2081, 0x2084], 0x20AC, 0x2103, 0x2105, 0x2109,
    0x2113, 0x2116, [0x2121, 0x2122], 0x2126, 0x212B, [0x2153, 0x2154],
    [0x215B, 0x215E], [0x2160, 0x216B], [0x2170, 0x2179], 0x2189, [0x2190, 0x2199],
    [0x21B8, 0x21B9], 0x21D2, 0x21D4, 0x21E7, 0x2200, [0x2202, 0x2203],
    [0x2207, 0x2208], 0x220B, 0x220F, 0x2211, 0x2215, 0x221A, [0x221D, 0x2220],
    0x2223, 0x2225, [0x2227, 0x222C], 0x222E, [0x2234, 0x2237], [0x223C, 0x223D],
    0x2248, 0x224C, 0x2252, [0x2260, 0x2261], [0x2264, 0x2267], [0x226A, 0x226B],
    [0x226E, 0x226F], [0x2282, 0x2283], [0x2286, 0x2287], 0x2295, 0x2299, 0x22A5,
    0x22BF, 0x2312, [0x2460, 0x24E9], [0x24EB, 0x254B], [0x2550, 0x2573],
    [0x2580, 0x258F], [0x2592, 0x2595], [0x25A0, 0x25A1], [0x25A3, 0x25A9],
    [0x25B2, 0x25B3], [0x25B6, 0x25B7], [0x25BC, 0x25BD], [0x25C0, 0x25C1],
    [0x25C6, 0x25C8], 0x25CB, [0x25CE, 0x25D1], [0x25E2, 0x25E5], 0x25EF,
    [0x2605, 0x2606], 0x2609, [0x260E, 0x260F], [0x2614, 0x2615], 0x261C, 0x261E,
    0x2640, 0x2642, [0x2660, 0x2661], [0x2663, 0x2665], [0x2667, 0x266A],
    [0x266C, 0x266D], 0x266F, [0x269E, 0x269F], [0x26BE, 0x26BF], [0x26C4, 0x26CD],
    0x26CF, [0x26E1, 0x26E1], 0x26E3, [0x26E8, 0x26FF], 0x273D, 0x2757,
    [0x2776, 0x277F], [0x2B55, 0x2B59], [0x3248, 0x324F], [0xE000, 0xF8FF],
    [0xFE00, 0xFE0F], 0xFFFD, [0x1F100, 0x1F10A], [0x1F110, 0x1F12D],
    [0x1F130, 0x1F169], [0x1F170, 0x1F19A], [0xE0100, 0xE01EF], [0xF0000, 0xFFFFD],
    [0x100000, 0x10FFFD]
  ];

  for (const range of ambiguousCharacters) {
    if (Array.isArray(range)) {
      if (codePoint >= range[0] && codePoint <= range[1]) {
        return 'A';
      }
    } else {
      if (codePoint === range) {
        return 'A';
      }
    }
  }

  return 'N';
};

eaw.characterLength = function (character) {
  const width = this.eastAsianWidth(character);
  return width === 'F' || width === 'W' || width === 'A' ? 2 : 1;
};

function stringToArray(string) {
  return string.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
}

eaw.length = function (string) {
  const characters = stringToArray(string);
  return characters.reduce((len, char) => len + this.characterLength(char), 0);
};

eaw.slice = function (text, start = 0, end = 1) {
  const textLen = this.length(text);
  start = start < 0 ? textLen + start : start;
  end = end < 0 ? textLen + end : end;
  const characters = stringToArray(text);

  let result = '';
  let eawLen = 0;

  for (const char of characters) {
    const charLen = this.characterLength(char);

    if (eawLen >= start - (charLen === 2 ? 1 : 0)) {
      if (eawLen + charLen <= end) {
        result += char;
      } else {
        break;
      }
    }
    eawLen += charLen;
  }

  return result;
};
```