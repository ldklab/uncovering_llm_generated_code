import{createMemoryHistory,Action,parsePath}from'history';import PropTypes from'prop-types';import{createContext,useRef,unstable_useTransition,useReducer,useLayoutEffect,createElement,useContext,useEffect,useMemo,useCallback,Children,isValidElement,Fragment}from'react';function k(a,b){if(!a)throw Error(b);}function l(a,b){if(!a){"undefined"!==typeof console&&console.warn(b);try{throw Error(b);}catch(c){}}}let m={};function p(a,b,c){b||m[a]||(m[a]=!0,l(!1,c))}let q=createContext({pending:!1,static:!1});q.displayName="Location";let r=createContext({outlet:null,params:Object.freeze({}),pathname:"",route:null});r.displayName="Route";
function t({children:a,initialEntries:b,initialIndex:c,timeoutMs:d=5E3}){let e=useRef();null==e.current&&(e.current=createMemoryHistory({initialEntries:b,initialIndex:c}));let [g,f]=unstable_useTransition({timeoutMs:d}),h=e.current,[n,L]=useReducer((b,a)=>a,{action:h.action,location:h.location});useLayoutEffect(()=>h.listen(b=>{g(()=>{L(b)})}),[h,g]);return createElement(u,{children:a,action:n.action,location:n.location,navigator:h,pending:f})}t.displayName="MemoryRouter";
t.propTypes={children:PropTypes.node,initialEntries:PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string,PropTypes.shape({pathname:PropTypes.string,search:PropTypes.string,hash:PropTypes.string,state:PropTypes.object,key:PropTypes.string})])),initialIndex:PropTypes.number,timeoutMs:PropTypes.number};
function v({to:a,replace:b,state:c}){w()?void 0:k(!1,"<Navigate> may be used only in the context of a <Router> component.");l(!useContext(q).static,"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");let d=x();useEffect(()=>{d(a,{replace:b,state:c})});return null}v.displayName="Navigate";
v.propTypes={to:PropTypes.oneOfType([PropTypes.string,PropTypes.shape({pathname:PropTypes.string,search:PropTypes.string,hash:PropTypes.string})]).isRequired,replace:PropTypes.bool,state:PropTypes.object};function y(){return z()}y.displayName="Outlet";y.propTypes={};function A({element:a=createElement(y,null)}){return a}A.displayName="Route";A.propTypes={caseSensitive:PropTypes.bool,children:PropTypes.node,element:PropTypes.element,path:PropTypes.string};
function u({children:a=null,action:b=Action.Pop,location:c,navigator:d,pending:e=!1,static:g=!1}){w()?k(!1,"You cannot render a <Router> inside another <Router>. You never need more than one."):void 0;return createElement(q.Provider,{children:a,value:{action:b,location:c,navigator:d,pending:e,static:g}})}u.displayName="Router";
u.propTypes={children:PropTypes.node,action:PropTypes.oneOf(["POP","PUSH","REPLACE"]),location:PropTypes.object.isRequired,navigator:PropTypes.shape({createHref:PropTypes.func.isRequired,push:PropTypes.func.isRequired,replace:PropTypes.func.isRequired,go:PropTypes.func.isRequired,block:PropTypes.func.isRequired}).isRequired,pending:PropTypes.bool,static:PropTypes.bool};function B({basename:a="",children:b}){b=C(b);return D(b,a)}B.displayName="Routes";B.propTypes={basename:PropTypes.string,children:PropTypes.node};
function w(){return null!=useContext(q).location}function E(){w()?void 0:k(!1,"useLocation() may be used only in the context of a <Router> component.");return useContext(q).location}
function x(){w()?void 0:k(!1,"useNavigate() may be used only in the context of a <Router> component.");let a=useContext(q),b=a.navigator,c=a.pending,{pathname:d}=useContext(r),e=useRef(!1);useEffect(()=>{e.current=!0});return useCallback((a,f={})=>{e.current?"number"===typeof a?b.go(a):(a=F(a,d),(f.replace||c?b.replace:b.push)(a,f.state)):l(!1,"You should call navigate() in a useEffect, not when your component is first rendered.")},[b,d,c])}function z(){return useContext(r).outlet}
function G(a){let {pathname:b}=useContext(r);return useMemo(()=>F(a,b),[a,b])}
function D(a,b=""){let {route:c,pathname:d,params:e}=useContext(r);var g=c&&c.path;p(d,!c||c.path.endsWith("*"),`You rendered descendant <Routes> (or called \`useRoutes\`) at "${d}"`+` (under <Route path="${g}">) but the parent route path has no trailing "*".`+" This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.\n\n"+`Please change the parent <Route path="${g}"> to <Route path="${g}/*">.`);b=b?[d,b].join("/").replace(/\/\/+/g,"/"):d;
g=useRef();let f=E(),h=useMemo(()=>H(a,f,b),[f,a,b]);if(!h)return null;g.current!==f&&(g.current=f,h.forEach(({route:b,params:a},c)=>b.preload&&b.preload(a,f,c)));return h.reduceRight((a,{params:c,pathname:d,route:f})=>createElement(r.Provider,{children:f.element,value:{outlet:a,params:Object.freeze({...e,...c}),pathname:[b,d].join("/").replace(/\/\/+/g,"/"),route:f}}),null)}
function I(a){return a.map(b=>{let a={path:b.path||"/",caseSensitive:!0===b.caseSensitive,element:b.element||createElement(y,null),preload:b.preload};b.children&&(a.children=I(b.children));return a})}
function C(a){let b=[];Children.forEach(a,a=>{if(isValidElement(a))if(a.type===Fragment)b.push.apply(b,C(a.props.children));else{var c={path:a.props.path||"/",caseSensitive:!0===a.props.caseSensitive,element:a,preload:a.props.preload};a.props.children&&(a=C(a.props.children),a.length&&(c.children=a));b.push(c)}});return b}
function H(a,b,c=""){"string"===typeof b&&(b=parsePath(b));b=b.pathname||"/";if(c)if(c=c.replace(/^\/*/,"/").replace(/\/+$/,""),b.startsWith(c))b=b===c?"/":b.slice(c.length);else return null;a=J(a);K(a);var d=null;for(c=0;null==d&&c<a.length;++c)a:{d=b;let g=a[c][1],f="/",h={},n=[];for(let a=0;a<g.length;++a){let b=g[a];var e="/"===f?d:d.slice(f.length)||"/";e=M({path:b.path,caseSensitive:b.caseSensitive,end:a===g.length-1},e);if(!e){d=null;break a}f=[f,e.pathname].join("/").replace(/\/\/+/g,"/");
h={...h,...e.params};n.push({route:b,pathname:f,params:Object.freeze(h)})}d=n}return d}function J(a,b=[],c="",d=[],e=[]){a.forEach((a,f)=>{let g=[c,a.path].join("/").replace(/\/\/+/g,"/"),n=d.concat(a);f=e.concat(f);a.children&&J(a.children,b,g,n,f);b.push([g,n,f])});return b}function K(a){let b=a.reduce((a,[b])=>{a[b]=N(b);return a},{});O(a,(a,d)=>{let [c,,g]=a;a=b[c];let [f,,h]=d;d=b[f];return a!==d?d-a:P(g,h)})}let Q=/^:\w+$/,R=a=>"*"===a;
function N(a){a=a.split("/");let b=a.length;a.some(R)&&(b+=-2);return a.filter(a=>"*"!==a).reduce((a,b)=>a+(Q.test(b)?2:""===b?1:10),b)}function P(a,b){return a.length===b.length&&a.slice(0,-1).every((a,d)=>a===b[d])?a[a.length-1]-b[b.length-1]:0}function O(a,b){let c=a.slice(0);a.sort((a,e)=>b(a,e)||c.indexOf(a)-c.indexOf(e))}
function M(a,b){"string"===typeof a&&(a={path:a});let {path:c,caseSensitive:d=!1,end:e=!0}=a,[g,f]=S(c,d,e);b=b.match(g);if(!b)return null;a=b[1];let h=b.slice(2);b=f.reduce((a,b,c)=>{c=h[c];try{var d=decodeURIComponent(c.replace(/\+/g," "))}catch(T){l(!1,`The value for the URL param "${b}" will not be decoded because`+` the string "${c}" is a malformed URL segment. This is probably`+` due to a bad percent encoding (${T}).`),d=c}a[b]=d;return a},{});return{path:c,pathname:a,params:b}}
function S(a,b,c){let d=[],e="^("+a.replace(/^\/*/,"/").replace(/\/?\*?$/,"").replace(/[\\.*+^$?{}|()[\]]/g,"\\$&").replace(/:(\w+)/g,(a,b)=>{d.push(b);return"([^\\/]+)"})+")";a.endsWith("*")?(a.endsWith("/*")&&(e+="\\/?"),d.push("*"),e+="(.*)"):c&&(e+="\\/?");c&&(e+="$");return[new RegExp(e,b?void 0:"i"),d]}function F(a,b="/"){let {pathname:c,search:d="",hash:e=""}="string"===typeof a?parsePath(a):a;return{pathname:c?U(c,c.startsWith("/")?"/":b):b,search:d,hash:e}}
function U(a,b){let c=b.replace(/\/+$/,"").replace(/\/\/+/g,"/").split("/");a.replace(/\/\/+/g,"/").split("/").forEach(a=>{".."===a?1<c.length&&c.pop():"."!==a&&c.push(a)});return 1<c.length?c.join("/").replace(/\/\/+/g,"/"):"/"}
function generatePath(a,b={}){return a.replace(/:(\w+)/g,(a,d)=>{null==b[d]?k(!1,`Missing ":${d}" param`):void 0;return b[d]}).replace(/\/*\*$/,()=>null==b["*"]?"":b["*"].replace(/^\/*/,"/"))};
function useBlocker(a,b=!0){w()?void 0:k(!1,"useBlocker() may be used only in the context of a <Router> component.");let c=useContext(q).navigator;useEffect(()=>{if(b){var d=c.block(b=>{a({...b,retry(){d();b.retry()}})});return d}},[c,a,b])};function useHref(a){w()?void 0:k(!1,"useHref() may be used only in the context of a <Router> component.");let b=useContext(q).navigator;a=G(a);return b.createHref(a)};function useLocationPending(){return useContext(q).pending};
function useMatch(a){w()?void 0:k(!1,"useMatch() may be used only in the context of a <Router> component.");let b=E();return M(a,b.pathname)};function useParams(){return useContext(r).params};function useRoutes(a,b=""){w()?void 0:k(!1,"useRoutes() may be used only in the context of a <Router> component.");let c=useMemo(()=>I(a),[a]);return D(c,b)};export{t as MemoryRouter,v as Navigate,y as Outlet,A as Route,u as Router,B as Routes,I as createRoutesFromArray,C as createRoutesFromChildren,generatePath,M as matchPath,H as matchRoutes,F as resolvePath,useBlocker,useHref,w as useInRouterContext,E as useLocation,useLocationPending,useMatch,x as useNavigate,z as useOutlet,useParams,G as useResolvedPath,useRoutes}
//# sourceMappingURL=react-router.development.js.map
