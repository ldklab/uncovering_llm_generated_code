The Node.js code provided above implements a system for adding and managing "require" hooks in a Node.js environment. This allows users to modify the module loading process by executing a custom function (hook) whenever a module is required. Here’s a breakdown of its functionality:

1. **Module Imports and Initialization:**
   - It imports the `module` and `path` modules using custom `_interopRequireDefault` function.
   - It specifies that the module is an ES module by setting `exports.__esModule` to true.

2. **Regular Expressions and Module Guard:**
   - It defines a regex `nodeModulesRegex` to check if a file is within `node_modules`.
   - It checks and uses a module constructor for `Module` to accommodate different environments (like testing environments).

3. **Error Handling:**
   - It defines an error message for when a require hook returns a non-string or null, which should be returned as part of a valid hook implementation.

4. **shouldCompile Function:**
   - Determines if a given file should be processed by a hook based on filename, extensions, a custom matcher function, and whether it’s in `node_modules`.

5. **addHook Function:**
   - This is the main function to attach a require hook.
   - It takes a `hook` function and optional `opts` (options).
   - Validates file extensions and sets up the hook only for files matching specified extensions, using a default of `.js` if none are provided.
   - It modifies the `_compile` function of modules, allowing the hook to transform the module's code.
   - Returns a `revert` function to undo the hook, restoring previous loader behavior for the file extensions.

Here is a possible rewrite of the given Node.js code:

```javascript
"use strict";

import module from 'module';
import path from 'path';

export function addHook(hook, opts = {}) {
  const nodeModulesRegex = /^(?:.*[\\/])?node_modules(?:[\\/].*)?$/;
  const HOOK_RETURNED_NOTHING_ERROR_MESSAGE = '[Pirates] A hook returned a non-string, or nothing at all! This is a violation of intergalactic law!\n--------------------\nIf you have no idea what this means or what Pirates is, let me explain: Pirates is a module that makes it easy to implement require hooks. One of the require hooks you\'re using uses it. One of these require hooks didn\'t return anything from its handler, so we don\'t know what to do. You might want to debug this.';
  const Module = module.constructor.length > 1 ? module.constructor : module;

  function shouldCompile(filename, exts, matcher, ignoreNodeModules) {
    if (typeof filename !== 'string') return false;
    if (!exts.includes(path.extname(filename))) return false;
    const resolvedFilename = path.resolve(filename);
    if (ignoreNodeModules && nodeModulesRegex.test(resolvedFilename)) return false;
    if (matcher && typeof matcher === 'function') return !!matcher(resolvedFilename);
    return true;
  }

  let reverted = false;
  const loaders = {};
  const oldLoaders = {};
  let exts;
  
  const originalJSLoader = Module._extensions['.js'];
  const matcher = opts.matcher || null;
  const ignoreNodeModules = opts.ignoreNodeModules !== false;
  
  exts = opts.extensions || opts.exts || opts.extension || opts.ext || ['.js'];
  if (!Array.isArray(exts)) {
    exts = [exts];
  }
  
  exts.forEach(ext => {
    if (typeof ext !== 'string') {
      throw new TypeError(`Invalid Extension: ${ext}`);
    }
    
    const oldLoader = Module._extensions[ext] || originalJSLoader;
    oldLoaders[ext] = oldLoader;
    
    loaders[ext] = Module._extensions[ext] = function newLoader(mod, filename) {
      let compile;
      if (!reverted) {
        if (shouldCompile(filename, exts, matcher, ignoreNodeModules)) {
          compile = mod._compile;
          mod._compile = function _compile(code) {
            mod._compile = compile;  // Reset immediately
            const newCode = hook(code, filename);
            if (typeof newCode !== 'string') {
              throw new Error(HOOK_RETURNED_NOTHING_ERROR_MESSAGE);
            }
            return mod._compile(newCode, filename);
          };
        }
      }
      oldLoader(mod, filename);
    };
  });
  
  return function revert() {
    if (reverted) return;
    reverted = true;
    exts.forEach(ext => {
      if (Module._extensions[ext] === loaders[ext]) {
        if (!oldLoaders[ext]) {
          delete Module._extensions[ext];
        } else {
          Module._extensions[ext] = oldLoaders[ext];
        }
      }
    });
  };
}
```