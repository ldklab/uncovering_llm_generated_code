Here's a detailed explanation of the given Node.js code:

1. **Exports and Imports**: 
   - The code exports multiple functions and constants from different modules including `rollup`, file paths, and constants. 
   - Imports are made from node's core modules (`fs`, `path`, etc.) and from custom paths for additional functionality.

2. **Regex Definition**: 
   - `CSS_LANGS_RE`: This regular expression is used to test if a file name represents a CSS-related language (like CSS, Less, Sass, etc.).

3. **Function `isCSSRequest`**: 
   - This function checks if a given request corresponds to a CSS-related file using the defined regex.

4. **Class `SplitVendorChunkCache`**:
   - Provides a simple caching mechanism using a `Map` to store and reset cache data.

5. **Function `splitVendorChunk`**: 
   - Determines if a module should be placed in the "vendor" chunk during the build process. 
   - Utilizes `SplitVendorChunkCache` to manage the caching state.

6. **Function `staticImportedByEntry`**: 
   - Checks if a module is statically imported by an entry module, assisting in chunk division logic.

7. **Function `splitVendorChunkPlugin`**:
   - A Rollup bundler plugin for handling the chunking strategy of vendor scripts, including configuration adjustments and resetting caches during build start.

8. **Class `ServerHMRBroadcasterClient`**:
   - Manages sending messages from the client to the server in a Hot Module Replacement (HMR) context.

9. **Class `ServerHMRConnector`**:
   - Connects to a server for Hot Module Replacement, managing connections and update events.

10. **Function `createHMROptions`**:
    - Creates the HMR options configuration based on server and specific options.

11. **Object `prepareStackTrace`**:
    - Provides a method to retrieve the contents of a file synchronously.

12. **Function `resolveSourceMapOptions`**:
    - Resolves options related to source map handling, supporting different strategies based on provided configurations.

13. **Function `createViteRuntime`**:
    - Configures and creates a Vite runtime environment, integrating HMR and module fetching logic.

Below is the rewritten code, rearranged for clarity but maintaining the same functionality:

```javascript
import { existsSync, readFileSync } from 'node:fs';
import { i as isInNodeModules, a as arraify } from './chunks/dep-CDnG8rE7.js';
import { ViteRuntime, ESModulesRunner } from 'vite/runtime';

export { parseAst, parseAstAsync } from 'rollup/parseAst';
export {
  b as build,
  g as buildErrorMessage,
  k as createFilter,
  v as createLogger,
  c as createServer,
  d as defineConfig,
  h as fetchModule,
  f as formatPostcssSourceMap,
  x as isFileServingAllowed,
  l as loadConfigFromFile,
  y as loadEnv,
  j as mergeAlias,
  m as mergeConfig,
  n as normalizePath,
  o as optimizeDeps,
  e as preprocessCSS,
  p as preview,
  r as resolveConfig,
  z as resolveEnvPrefix,
  q as rollupVersion,
  w as searchForWorkspaceRoot,
  u as send,
  s as sortUserPlugins,
  t as transformWithEsbuild
} from './chunks/dep-CDnG8rE7.js';
export { VERSION as version } from './constants.js';
export { version as esbuildVersion } from 'esbuild';

// Define a regular expression for identifying CSS-related files
const CSS_LANGS_RE = /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/;
const isCSSRequest = (request) => CSS_LANGS_RE.test(request);

class SplitVendorChunkCache {
  constructor() {
    this.cache = new Map();
  }
  reset() {
    this.cache = new Map();
  }
}

function splitVendorChunk(options = {}) {
  const cache = options.cache ?? new SplitVendorChunkCache();
  return (id, { getModuleInfo }) => {
    if (isInNodeModules(id) && !isCSSRequest(id) && staticImportedByEntry(id, getModuleInfo, cache.cache)) {
      return "vendor";
    }
  };
}

function staticImportedByEntry(id, getModuleInfo, cache, importStack = []) {
  if (cache.has(id)) {
    return cache.get(id);
  }
  if (importStack.includes(id)) {
    cache.set(id, false);
    return false;
  }
  const mod = getModuleInfo(id);
  if (!mod) {
    cache.set(id, false);
    return false;
  }
  if (mod.isEntry) {
    cache.set(id, true);
    return true;
  }
  const someImporterIs = mod.importers.some(
    (importer) => staticImportedByEntry(importer, getModuleInfo, cache, importStack.concat(id))
  );
  cache.set(id, someImporterIs);
  return someImporterIs;
}

function splitVendorChunkPlugin() {
  const caches = [];
  function createSplitVendorChunk(output, config) {
    const cache = new SplitVendorChunkCache();
    caches.push(cache);
    const build = config.build ?? {};
    const format = output?.format;
    if (!build.ssr && !build.lib && format !== "umd" && format !== "iife") {
      return splitVendorChunk({ cache });
    }
  }
  return {
    name: "vite:split-vendor-chunk",
    config(config) {
      let outputs = config?.build?.rollupOptions?.output;
      if (outputs) {
        outputs = arraify(outputs);
        for (const output of outputs) {
          const viteManualChunks = createSplitVendorChunk(output, config);
          if (viteManualChunks) {
            if (output.manualChunks) {
              if (typeof output.manualChunks === "function") {
                const userManualChunks = output.manualChunks;
                output.manualChunks = (id, api) => {
                  return userManualChunks(id, api) ?? viteManualChunks(id, api);
                };
              } else {
                console.warn(
                  "(!) the `splitVendorChunk` plugin doesn't have any effect when using the object form of `build.rollupOptions.output.manualChunks`. Consider using the function form instead."
                );
              }
            } else {
              output.manualChunks = viteManualChunks;
            }
          }
        }
      } else {
        return {
          build: {
            rollupOptions: {
              output: {
                manualChunks: createSplitVendorChunk({}, config)
              }
            }
          }
        };
      }
    },
    buildStart() {
      caches.forEach((cache) => cache.reset());
    }
  };
}

class ServerHMRBroadcasterClient {
  constructor(hmrChannel) {
    this.hmrChannel = hmrChannel;
  }
  send(...args) {
    let payload;
    if (typeof args[0] === "string") {
      payload = {
        type: "custom",
        event: args[0],
        data: args[1]
      };
    } else {
      payload = args[0];
    }
    if (payload.type !== "custom") {
      throw new Error(
        "Cannot send non-custom events from the client to the server."
      );
    }
    this.hmrChannel.send(payload);
  }
}

class ServerHMRConnector {
  handlers = [];
  hmrChannel;
  hmrClient;
  connected = false;
  constructor(server) {
    const hmrChannel = server.hot?.channels.find((c) => c.name === "ssr");
    if (!hmrChannel) {
      throw new Error(
        "Your version of Vite doesn't support HMR during SSR. Please, use Vite 5.1 or higher."
      );
    }
    this.hmrClient = new ServerHMRBroadcasterClient(hmrChannel);
    hmrChannel.api.outsideEmitter.on("send", (payload) => {
      this.handlers.forEach((listener) => listener(payload));
    });
    this.hmrChannel = hmrChannel;
  }
  isReady() {
    return this.connected;
  }
  send(message) {
    const payload = JSON.parse(message);
    this.hmrChannel.api.innerEmitter.emit(payload.event, payload.data, this.hmrClient);
  }
  onUpdate(handler) {
    this.handlers.push(handler);
    handler({ type: "connected" });
    this.connected = true;
  }
}

function createHMROptions(server, options) {
  if (server.config.server.hmr === false || options.hmr === false) {
    return false;
  }
  const connection = new ServerHMRConnector(server);
  return {
    connection,
    logger: options.hmr?.logger
  };
}

const prepareStackTrace = {
  retrieveFile(id) {
    if (existsSync(id)) {
      return readFileSync(id, "utf-8");
    }
  }
};

function resolveSourceMapOptions(options) {
  if (options.sourcemapInterceptor != null) {
    if (options.sourcemapInterceptor === "prepareStackTrace") {
      return prepareStackTrace;
    }
    if (typeof options.sourcemapInterceptor === "object") {
      return { ...prepareStackTrace, ...options.sourcemapInterceptor };
    }
    return options.sourcemapInterceptor;
  }
  if (typeof process !== "undefined" && "setSourceMapsEnabled" in process) {
    return "node";
  }
  return prepareStackTrace;
}

async function createViteRuntime(server, options = {}) {
  const hmr = createHMROptions(server, options);
  return new ViteRuntime(
    {
      ...options,
      root: server.config.root,
      fetchModule: server.ssrFetchModule,
      hmr,
      sourcemapInterceptor: resolveSourceMapOptions(options)
    },
    options.runner || new ESModulesRunner()
  );
}

export { ServerHMRConnector, createViteRuntime, isCSSRequest, splitVendorChunk, splitVendorChunkPlugin };
```