The given Node.js code is a complex module likely intended for use with the `ts-node` library. It deals with TypeScript transpilation, diagnostics, and Node.js module loading extensions for TypeScript files. Broadly, the code includes:

1. **Importing Modules**: The code starts by importing various Node.js core modules and custom modules necessary for TypeScript file transpilation and module resolution.

2. **Environment Setup**: It determines if the Node.js version supports features such as the `package.json` "type" field, which affects module loading, and sets up symbols used across the module to manage registered instances and environment variables.

3. **Error Handling**: A custom error class `TSError` is defined to handle TypeScript diagnostic errors.

4. **Service Setup and Registration**: The code defines functions to create and manage a TypeScript compiler service, including setting default options, handling config file resolution, and managing extensions for TypeScript files within Node.js using `require` hooks.

5. **Source Map and Output Handling**: It integrates a mechanism to handle source maps for error tracing and is responsible for finalizing the output JavaScript code from TypeScript transpilation.

6. **Diagnostics and Errors**: Functions to handle diagnostics, report type errors, and filter relevant diagnostics based on specific criteria are implemented.

7. **Custom Extensions**: It registers custom file extensions handled by `ts-node`, ensuring TypeScript files are correctly compiled and executed when imported in Node.js processes.

8. **ESM Interoperability**: Supports interoperability with the experimental Node.js ECMAScript module loader, enabling module resolution through the ESM API.

9. **Utility Functions**: Other utility functions manage memory caching, path normalization, and file reading to optimize the transpilation process.

Here is a possible rewrite of the code while maintaining its original purpose:

```javascript
"use strict";
const path = require("path");
const module = require("module");
const util = require("util");
const url = require("url");
const makeError = require("make-error");
const { yn, parse, split, normalizeSlashes, createProjectLocalResolveHelper } = require("./util");
const { findAndReadConfig, loadCompiler } = require("./configuration");
const { createModuleTypeClassifier } = require("./module-type-classifier");
const { createResolverFunctions } = require("./resolver-functions");
const { installCommonjsResolveHooksIfNecessary } = require("./cjs-resolve-hooks");
const { classifyModule } = require("./node-module-type-classifier");
const { getExtensions } = require("./file-extensions");
const { createTsTranspileModule } = require("./ts-transpile-module");
const { createRepl } = require("./repl");

// Setup
const engineSupportsPackageTypeField = parseInt(process.versions.node.split('.')[0], 10) >= 12;
let assertScriptCanLoadAsCJS = engineSupportsPackageTypeField
    ? require('../dist-raw/node-internal-modules-cjs-loader').assertScriptCanLoadAsCJSImpl
    : () => {};

const REGISTER_INSTANCE = Symbol.for('ts-node.register.instance');
const env = process.env;
const INSPECT_CUSTOM = util.inspect.custom || 'inspect';

const shouldDebug = yn(env.TS_NODE_DEBUG);
const debug = shouldDebug
    ? (...args) => console.log(`[ts-node ${new Date().toISOString()}]`, ...args)
    : () => undefined;

const VERSION = require('../package.json').version;

const DEFAULTS = {
    cwd: env.TS_NODE_CWD ?? env.TS_NODE_DIR,
    emit: yn(env.TS_NODE_EMIT),
    scope: yn(env.TS_NODE_SCOPE),
    scopeDir: env.TS_NODE_SCOPE_DIR,
    files: yn(env.TS_NODE_FILES),
    pretty: yn(env.TS_NODE_PRETTY),
    compiler: env.TS_NODE_COMPILER,
    compilerOptions: parse(env.TS_NODE_COMPILER_OPTIONS),
    ignore: split(env.TS_NODE_IGNORE),
    project: env.TS_NODE_PROJECT,
    skipProject: yn(env.TS_NODE_SKIP_PROJECT),
    skipIgnore: yn(env.TS_NODE_SKIP_IGNORE),
    preferTsExts: yn(env.TS_NODE_PREFER_TS_EXTS),
    ignoreDiagnostics: split(env.TS_NODE_IGNORE_DIAGNOSTICS),
    transpileOnly: yn(env.TS_NODE_TRANSPILE_ONLY),
    typeCheck: yn(env.TS_NODE_TYPE_CHECK),
    compilerHost: yn(env.TS_NODE_COMPILER_HOST),
    logError: yn(env.TS_NODE_LOG_ERROR),
    experimentalReplAwait: yn(env.TS_NODE_EXPERIMENTAL_REPL_AWAIT) ?? undefined,
    tsTrace: console.log.bind(console),
};

class TSError extends makeError.BaseError {
    constructor(diagnosticText, diagnosticCodes, diagnostics = []) {
        super(`тип Unable to compile TypeScript:\n${diagnosticText}`);
        this.diagnosticCodes = diagnosticCodes;
        this.name = 'TSError';
        Object.defineProperty(this, 'diagnosticText', {
            configurable: true,
            writable: true,
            value: diagnosticText,
        });
        Object.defineProperty(this, 'diagnostics', {
            configurable: true,
            writable: true,
            value: diagnostics,
        });
    }
    [INSPECT_CUSTOM]() {
        return this.diagnosticText;
    }
}

function register(serviceOrOpts) {
    let service = serviceOrOpts;
    if (!serviceOrOpts || !serviceOrOpts[TS_NODE_SERVICE_BRAND]) {
        service = create(serviceOrOpts ?? {});
    }
    const originalJsHandler = require.extensions['.js'];
    process[REGISTER_INSTANCE] = service;
    registerExtensions(service.options.preferTsExts, service.extensions.compiled, service, originalJsHandler);
    installCommonjsResolveHooksIfNecessary(service);
    module.Module._preloadModules(service.options.require);
    return service;
}

function create(rawOptions = {}) {
    const foundConfigResult = findAndReadConfig(rawOptions);
    return createFromPreloadedConfig(foundConfigResult);
}

function createFromPreloadedConfig(foundConfigResult) {
    const { configFilePath, cwd, options, config, compiler, projectLocalResolveDir } = foundConfigResult;
    const projectLocalResolveHelper = createProjectLocalResolveHelper(projectLocalResolveDir);
    const ts = loadCompiler(compiler);
    const targetSupportsTla = config.options.target >= ts.ScriptTarget.ES2018;
    if (options.experimentalReplAwait === true && !targetSupportsTla) {
        throw new Error('Experimental REPL await is not compatible with targets lower than ES2018');
    }
    const tsVersionSupportsTla = versionGteLt(ts.version, '3.8.0');
    if (options.experimentalReplAwait === true && !tsVersionSupportsTla) {
        throw new Error('Experimental REPL await is not compatible with TypeScript versions older than 3.8');
    }
    const shouldReplAwait = options.experimentalReplAwait !== false && tsVersionSupportsTla && targetSupportsTla;
    if (options.swc && !options.typeCheck) {
        if (options.transpileOnly === false) {
            throw new Error("Cannot enable 'swc' option with 'transpileOnly: false'. 'swc' implies 'transpileOnly'.");
        }
        if (options.transpiler) {
            throw new Error("Cannot specify both 'swc' and 'transpiler' options. 'swc' uses the built-in swc transpiler.");
        }
    }
    const readFile = options.readFile || ts.sys.readFile;
    const fileExists = options.fileExists || ts.sys.fileExists;
    const transpileOnly = (options.transpileOnly === true || options.swc === true) && options.typeCheck !== true;
    let transpiler;
    let transpilerBasePath;
    if (options.transpiler) {
        transpiler = options.transpiler;
        transpilerBasePath = optionBasePaths.transpiler;
    } else if (options.swc) {
        transpiler = require.resolve('./transpilers/swc.js');
        transpilerBasePath = optionBasePaths.swc;
    }
    const transformers = options.transformers || undefined;
    const diagnosticFilters = [
        {
            appliesToAllFiles: true,
            filenamesAbsolute: [],
            diagnosticsIgnored: [
                6059,
                18002,
                18003,
                ...(options.experimentalTsImportSpecifiers ? [2691] : []),
                ...(options.ignoreDiagnostics || []),
            ].map(Number),
        },
    ];
    const configDiagnosticList = filterDiagnostics(config.errors, diagnosticFilters);
    const outputCache = new Map();
    const configFileDirname = configFilePath ? path.dirname(configFilePath) : null;
    const scopeDir = options.scopeDir ?? config.options.rootDir ?? configFileDirname ?? cwd;
    const ignoreBaseDir = configFileDirname ?? cwd;
    const isScoped = options.scope ? (fileName) => path.relative(scopeDir, fileName).charAt(0) !== '.' : () => true;
    const shouldIgnore = createIgnore(ignoreBaseDir, options.skipIgnore ? [] : (options.ignore || ['(?:^|/)node_modules/']).map((str) => new RegExp(str)));
    const diagnosticHost = {
        getNewLine: () => ts.sys.newLine,
        getCurrentDirectory: () => cwd,
        getCanonicalFileName: ts.sys.useCaseSensitiveFileNames ? (x) => x : (x) => x.toLowerCase(),
    };
    if (options.transpileOnly && typeof transformers === 'function') {
        throw new TypeError('Transformers function is unavailable in "--transpile-only"');
    }
    let createTranspiler = initializeTranspilerFactory();

    function initializeTranspilerFactory() {
        if (transpiler) {
            if (!transpileOnly) throw new Error('Custom transpiler can only be used when transpileOnly is enabled.');
            const transpilerName = typeof transpiler === 'string' ? transpiler : transpiler[0];
            const transpilerOptions = typeof transpiler === 'string' ? {} : transpiler[1] ?? {};
            const transpilerConfigLocalResolveHelper = transpilerBasePath ? createProjectLocalResolveHelper(transpilerBasePath) : projectLocalResolveHelper;
            const transpilerPath = transpilerConfigLocalResolveHelper(transpilerName, true);
            const transpilerFactory = require(transpilerPath).create;
            return function createTranspiler(compilerOptions, nodeModuleEmitKind) {
                return transpilerFactory({
                    service: {
                        options,
                        config: {
                            ...config,
                            options: compilerOptions,
                        },
                        projectLocalResolveHelper,
                    },
                    transpilerConfigLocalResolveHelper,
                    nodeModuleEmitKind,
                    ...transpilerOptions,
                });
            };
        }
    }

    function enableExperimentalEsmLoaderInterop() {
        experimentalEsmLoader = true;
    }

    installSourceMapSupport();

    function installSourceMapSupport() {
        require('@cspotcode/source-map-support').install({
            environment: 'node',
            retrieveFile(pathOrUrl) {
                let path = pathOrUrl;
                if (experimentalEsmLoader && path.startsWith('file://')) {
                    try {
                        path = url.fileURLToPath(path);
                    } catch (e) {
                        /* swallow error */
                    }
                }
                path = normalizeSlashes(path);
                return outputCache.get(path)?.content || '';
            },
            redirectConflictingLibrary: true,
            onConflictingLibraryRedirect(request, parent, isMain, options, redirectedRequest) {
                debug(`Redirected an attempt to require source-map-support to instead receive @cspotcode/source-map-support. "${parent.filename}" attempted to require or resolve "${request}" and was redirected to "${redirectedRequest}".`);
            },
        });
    }

    const shouldHavePrettyErrors = options.pretty === undefined ? process.stdout.isTTY : options.pretty;
    const formatDiagnostics = shouldHavePrettyErrors ? ts.formatDiagnosticsWithColorAndContext || ts.formatDiagnostics : ts.formatDiagnostics;

    function createTSError(diagnostics) {
        const diagnosticText = formatDiagnostics(diagnostics, diagnosticHost);
        const diagnosticCodes = diagnostics.map((x) => x.code);
        return new TSError(diagnosticText, diagnosticCodes, diagnostics);
    }

    function reportTSError(configDiagnosticList) {
        const error = createTSError(configDiagnosticList);
        if (options.logError) {
            console.error('\x1b[31m%s\x1b[0m', error);
        } else {
            throw error;
        }
    }

    if (configDiagnosticList.length) reportTSError(configDiagnosticList);

    const jsxEmitPreserve = config.options.jsx === ts.JsxEmit.Preserve;

    function getEmitExtension(path) {
        const lastDotIndex = path.lastIndexOf('.');
        if (lastDotIndex >= 0) {
            const ext = path.slice(lastDotIndex);
            switch (ext) {
                case '.js':
                case '.ts':
                    return '.js';
                case '.jsx':
                case '.tsx':
                    return jsxEmitPreserve ? '.jsx' : '.js';
                case '.mjs':
                case '.mts':
                    return '.mjs';
                case '.cjs':
                case '.cts':
                    return '.cjs';
            }
        }
        return '.js';
    }

    let getOutput;
    let getTypeInfo;
    const getCanonicalFileName = ts.createGetCanonicalFileName(ts.sys.useCaseSensitiveFileNames);
    const moduleTypeClassifier = createModuleTypeClassifier({
        basePath: options.optionBasePaths?.moduleTypes,
        patterns: options.moduleTypes,
    });
    const extensions = getExtensions(config, options, ts.version);

    if (!transpileOnly) {
        const fileContents = new Map();
        const rootFileNames = new Set(config.fileNames);
        const cachedReadFile = cachedLookup(debugFn('readFile', readFile));
        if (!options.compilerHost) {
            let projectVersion = 1;
            const fileVersions = new Map(Array.from(rootFileNames).map((fileName) => [fileName, 0]));
            const getCustomTransformers = () => (typeof transformers === 'function' ? transformers(service.getProgram()) : transformers);
            const serviceHost = {
                getProjectVersion: () => String(projectVersion),
                getScriptFileNames: () => Array.from(rootFileNames),
                getScriptVersion: (fileName) => (fileVersions.get(fileName) || 0).toString(),
                getScriptSnapshot(fileName) {
                    let contents = fileContents.get(fileName);
                    if (contents === undefined) {
                        contents = cachedReadFile(fileName);
                        if (contents === undefined) return;
                        fileVersions.set(fileName, 1);
                        fileContents.set(fileName, contents);
                        projectVersion++;
                    }
                    return ts.ScriptSnapshot.fromString(contents);
                },
                readFile: cachedReadFile,
                readDirectory: ts.sys.readDirectory,
                getDirectories: cachedLookup(debugFn('getDirectories', ts.sys.getDirectories)),
                fileExists: cachedLookup(debugFn('fileExists', fileExists)),
                directoryExists: cachedLookup(debugFn('directoryExists', ts.sys.directoryExists)),
                realpath: ts.sys.realpath ? cachedLookup(debugFn('realpath', ts.sys.realpath)) : undefined,
                getNewLine: () => ts.sys.newLine,
                useCaseSensitiveFileNames: () => ts.sys.useCaseSensitiveFileNames,
                getCurrentDirectory: () => cwd,
                getCompilationSettings: () => config.options,
                getDefaultLibFileName: () => ts.getDefaultLibFilePath(config.options),
                getCustomTransformers: getCustomTransformers,
                trace: options.tsTrace,
            };
            const { resolveModuleNames, getResolvedModuleWithFailedLookupLocationsFromCache, resolveTypeReferenceDirectives, isFileKnownToBeInternal, markBucketOfFilenameInternal } = createResolverFunctions({
                host: serviceHost,
                getCanonicalFileName,
                ts,
                cwd,
                config,
                projectLocalResolveHelper,
                options,
                extensions,
            });
            serviceHost.resolveModuleNames = resolveModuleNames;
            serviceHost.getResolvedModuleWithFailedLookupLocationsFromCache = getResolvedModuleWithFailedLookupLocationsFromCache;
            serviceHost.resolveTypeReferenceDirectives = resolveTypeReferenceDirectives;

            const registry = ts.createDocumentRegistry(ts.sys.useCaseSensitiveFileNames, cwd);
            const service = ts.createLanguageService(serviceHost, registry);

            const updateMemoryCache = (contents, fileName) => {
                if (!rootFileNames.has(fileName) && !isFileKnownToBeInternal(fileName)) {
                    markBucketOfFilenameInternal(fileName);
                    rootFileNames.add(fileName);
                    projectVersion++;
                }
                const previousVersion = fileVersions.get(fileName) || 0;
                const previousContents = fileContents.get(fileName);
                if (contents !== previousContents) {
                    fileVersions.set(fileName, previousVersion + 1);
                    fileContents.set(fileName, contents);
                    projectVersion++;
                }
            };

            let previousProgram;
            getOutput = (code, fileName) => {
                updateMemoryCache(code, fileName);
                const programBefore = service.getProgram();
                if (programBefore !== previousProgram) {
                    debug(`compiler rebuilt Program instance when getting output for ${fileName}`);
                }
                const output = service.getEmitOutput(fileName);
                const diagnostics = service.getSemanticDiagnostics(fileName).concat(service.getSyntacticDiagnostics(fileName));
                const programAfter = service.getProgram();
                debug('invariant: Is service.getProject() identical before and after getting emit output and diagnostics? (should always be true)', programBefore === programAfter);
                previousProgram = programAfter;

                const diagnosticList = filterDiagnostics(diagnostics, diagnosticFilters);
                if (diagnosticList.length) reportTSError(diagnosticList);

                if (output.emitSkipped) {
                    return [undefined, undefined, true];
                }
                if (output.outputFiles.length === 0) {
                    throw new TypeError(`Unable to require file: ${path.relative(cwd, fileName)}\n` + 'This is usually the result of a faulty configuration or import. Make sure there is a `.js`, `.json` or other executable extension with loader attached before `ts-node` available.');
                }
                return [output.outputFiles[1].text, output.outputFiles[0].text, false];
            };

            getTypeInfo = (code, fileName, position) => {
                const normalizedFileName = normalizeSlashes(fileName);
                updateMemoryCache(code, normalizedFileName);
                const info = service.getQuickInfoAtPosition(normalizedFileName, position);
                const name = ts.displayPartsToString(info ? info.displayParts : []);
                const comment = ts.displayPartsToString(info ? info.documentation : []);
                return { name, comment };
            };
        } else {
            const sys = {
                ...ts.sys,
                ...diagnosticHost,
                readFile: (fileName) => {
                    const cacheContents = fileContents.get(fileName);
                    if (cacheContents !== undefined) return cacheContents;
                    const contents = cachedReadFile(fileName);
                    if (contents) fileContents.set(fileName, contents);
                    return contents;
                },
                readDirectory: ts.sys.readDirectory,
                getDirectories: cachedLookup(debugFn('getDirectories', ts.sys.getDirectories)),
                fileExists: cachedLookup(debugFn('fileExists', fileExists)),
                directoryExists: cachedLookup(debugFn('directoryExists', ts.sys.directoryExists)),
                resolvePath: cachedLookup(debugFn('resolvePath', ts.sys.resolvePath)),
                realpath: ts.sys.realpath ? cachedLookup(debugFn('realpath', ts.sys.realpath)) : undefined,
            };
            const host = ts.createIncrementalCompilerHost ? ts.createIncrementalCompilerHost(config.options, sys) : {
                ...sys,
                getSourceFile: (fileName, languageVersion) => {
                    const contents = sys.readFile(fileName);
                    if (contents === undefined) return;
                    return ts.createSourceFile(fileName, contents, languageVersion);
                },
                getDefaultLibLocation: () => normalizeSlashes(path.dirname(compiler)),
                getDefaultLibFileName: () => normalizeSlashes(path.join(path.dirname(compiler), ts.getDefaultLibFileName(config.options))),
                useCaseSensitiveFileNames: () => sys.useCaseSensitiveFileNames,
            };
            host.trace = options.tsTrace;
            const { resolveModuleNames, resolveTypeReferenceDirectives, isFileKnownToBeInternal, markBucketOfFilenameInternal } = createResolverFunctions({
                host,
                cwd,
                config,
                ts,
                getCanonicalFileName,
                projectLocalResolveHelper,
                options,
                extensions,
            });
            host.resolveModuleNames = resolveModuleNames;
            host.resolveTypeReferenceDirectives = resolveTypeReferenceDirectives;

            let builderProgram = ts.createIncrementalProgram ? ts.createIncrementalProgram({
                rootNames: Array.from(rootFileNames),
                options: config.options,
                host,
                configFileParsingDiagnostics: config.errors,
                projectReferences: config.projectReferences,
            }) : ts.createEmitAndSemanticDiagnosticsBuilderProgram(Array.from(rootFileNames), config.options, host, undefined, config.errors, config.projectReferences);

            const customTransformers = typeof transformers === 'function' ? transformers(builderProgram.getProgram()) : transformers;

            const updateMemoryCache = (contents, fileName) => {
                const previousContents = fileContents.get(fileName);
                const contentsChanged = previousContents !== contents;
                if (contentsChanged) fileContents.set(fileName, contents);

                let addedToRootFileNames = false;
                if (!rootFileNames.has(fileName) && !isFileKnownToBeInternal(fileName)) {
                    markBucketOfFilenameInternal(fileName);
                    rootFileNames.add(fileName);
                    addedToRootFileNames = true;
                }

                if (addedToRootFileNames || contentsChanged) {
                    builderProgram = ts.createEmitAndSemanticDiagnosticsBuilderProgram(Array.from(rootFileNames), config.options, host, builderProgram, config.errors, config.projectReferences);
                }
            };

            getOutput = (code, fileName) => {
                let outText = '';
                let outMap = '';
                updateMemoryCache(code, fileName);
                const sourceFile = builderProgram.getSourceFile(fileName);
                if (!sourceFile) throw new TypeError(`Unable to read file: ${fileName}`);
                const program = builderProgram.getProgram();
                const diagnostics = ts.getPreEmitDiagnostics(program, sourceFile);
                const diagnosticList = filterDiagnostics(diagnostics, diagnosticFilters);
                if (diagnosticList.length) reportTSError(diagnosticList);
                const result = builderProgram.emit(sourceFile, (path, file) => {
                    if (path.endsWith('.map')) {
                        outMap = file;
                    } else {
                        outText = file;
                    }
                    if (options.emit) sys.writeFile(path, file);
                }, undefined, undefined, customTransformers);
                if (result.emitSkipped) {
                    return [undefined, undefined, true];
                }
                if (outText === '') {
                    if (program.isSourceFileFromExternalLibrary(sourceFile)) {
                        throw new TypeError(`Unable to compile file from external library: ${path.relative(cwd, fileName)}`);
                    }
                    throw new TypeError(`Unable to require file: ${path.relative(cwd, fileName)}\n` + 'This is usually the result of a faulty configuration or import. Make sure there is a `.js`, `.json` or other executable extension with loader attached before `ts-node` available.');
                }
                return [outText, outMap, false];
            };

            getTypeInfo = (code, fileName, position) => {
                const normalizedFileName = normalizeSlashes(fileName);
                updateMemoryCache(code, normalizedFileName);
                const sourceFile = builderProgram.getSourceFile(normalizedFileName);
                if (!sourceFile) throw new TypeError(`Unable to read file: ${fileName}`);
                const node = getTokenAtPosition(ts, sourceFile, position);
                const checker = builderProgram.getProgram().getTypeChecker();
                const symbol = checker.getSymbolAtLocation(node);
                if (!symbol) return { name: '', comment: '' };
                const type = checker.getTypeOfSymbolAtLocation(symbol, node);
                const signatures = [...type.getConstructSignatures(), ...type.getCallSignatures()];
                return {
                    name: signatures.length ? signatures.map((x) => checker.signatureToString(x)).join('\n') : checker.typeToString(type),
                    comment: ts.displayPartsToString(symbol?.getDocumentationComment(checker) || []),
                };
            };

            if (options.emit && config.options.incremental) {
                process.on('exit', () => {
                    builderProgram.getProgram().emitBuildInfo();
                });
            }
        }
    } else {
        getTypeInfo = () => {
            throw new TypeError('Type information is unavailable in "--transpile-only"');
        };
    }

    function createTranspileOnlyGetOutputFunction(overrideModuleType, nodeModuleEmitKind) {
        const compilerOptions = { ...config.options };
        if (overrideModuleType !== undefined) compilerOptions.module = overrideModuleType;
        let customTranspiler = createTranspiler?.(compilerOptions, nodeModuleEmitKind);
        let tsTranspileModule = versionGteLt(ts.version, '4.7.0')
            ? createTsTranspileModule(ts, {
                compilerOptions,
                reportDiagnostics: true,
                transformers: transformers,
            })
            : undefined;
        return (code, fileName) => {
            let result;
            if (customTranspiler) {
                result = customTranspiler.transpile(code, { fileName });
            } else if (tsTranspileModule) {
                result = tsTranspileModule(code, { fileName }, nodeModuleEmitKind === 'nodeesm' ? 'module' : 'commonjs');
            } else {
                result = ts.transpileModule(code, {
                    fileName,
                    compilerOptions,
                    reportDiagnostics: true,
                    transformers: transformers,
                });
            }
            const diagnosticList = filterDiagnostics(result.diagnostics || [], diagnosticFilters);
            if (diagnosticList.length) reportTSError(diagnosticList);
            return [result.outputText, result.sourceMapText, false];
        };
    }

    const shouldOverwriteEmitWhenForcingCommonJS = config.options.module !== ts.ModuleKind.CommonJS;
    const shouldOverwriteEmitWhenForcingEsm = !(config.options.module === ts.ModuleKind.ES2015 ||
        (ts.ModuleKind.ES2020 && config.options.module === ts.ModuleKind.ES2020) ||
        (ts.ModuleKind.ES2022 && config.options.module === ts.ModuleKind.ES2022) ||
        config.options.module === ts.ModuleKind.ESNext);

    const isNodeModuleType = isNodeModuleType(config.options.module, ts);

    const getOutputForceCommonJS = createTranspileOnlyGetOutputFunction(ts.ModuleKind.CommonJS);
    const getOutputForceNodeCommonJS = createTranspileOnlyGetOutputFunction(ts.ModuleKind.NodeNext, 'nodecjs');
    const getOutputForceNodeESM = createTranspileOnlyGetOutputFunction(ts.ModuleKind.NodeNext, 'nodeesm');
    const getOutputForceESM = createTranspileOnlyGetOutputFunction(ts.ModuleKind.ES2022 || ts.ModuleKind.ES2020 || ts.ModuleKind.ES2015);
    const getOutputTranspileOnly = createTranspileOnlyGetOutputFunction();

    function compile(code, fileName, lineOffset = 0) {
        const normalizedFileName = normalizeSlashes(fileName);
        const classification = moduleTypeClassifier.classifyModuleByModuleTypeOverrides(normalizedFileName);
        let value = '';
        let sourceMap = '';
        let emitSkipped = true;
        if (getOutput) {
            [value, sourceMap, emitSkipped] = getOutput(code, normalizedFileName);
        }
        if (classification.moduleType === 'cjs' && (shouldOverwriteEmitWhenForcingCommonJS || emitSkipped)) {
            [value, sourceMap] = getOutputForceCommonJS(code, normalizedFileName);
        } else if (classification.moduleType === 'esm' && (shouldOverwriteEmitWhenForcingEsm || emitSkipped)) {
            [value, sourceMap] = getOutputForceESM(code, normalizedFileName);
        } else if (emitSkipped) {
            const classification = classifyModule(fileName, isNodeModuleType);
            [value, sourceMap] = classification === 'nodecjs'
                ? getOutputForceNodeCommonJS(code, normalizedFileName)
                : classification === 'nodeesm'
                    ? getOutputForceNodeESM(code, normalizedFileName)
                    : classification === 'cjs'
                        ? getOutputForceCommonJS(code, normalizedFileName)
                        : classification === 'esm'
                            ? getOutputForceESM(code, normalizedFileName)
                            : getOutputTranspileOnly(code, normalizedFileName);
        }
        const output = updateOutput(value, normalizedFileName, sourceMap, getEmitExtension);
        outputCache.set(normalizedFileName, { content: output });
        return output;
    }

    let active = true;
    const enabled = (enabled) => enabled === undefined ? active : (active = !!enabled);
    const ignored = (fileName) => {
        if (!active) return true;
        const ext = path.extname(fileName);
        if (extensions.compiled.includes(ext)) {
            return !isScoped(fileName) || shouldIgnore(fileName);
        }
        return true;
    };

    function addDiagnosticFilter(filter) {
        diagnosticFilters.push({
            ...filter,
            filenamesAbsolute: filter.filenamesAbsolute.map((f) => normalizeSlashes(f)),
        });
    }

    const getNodeEsmResolver = once(() => require('../dist-raw/node-internal-modules-esm-resolve').createResolve({
        extensions,
        preferTsExts: options.preferTsExts,
        tsNodeExperimentalSpecifierResolution: options.experimentalSpecifierResolution,
    }));

    const getNodeEsmGetFormat = once(() => require('../dist-raw/node-internal-modules-esm-get_format').createGetFormat(options.experimentalSpecifierResolution, getNodeEsmResolver()));

    const getNodeCjsLoader = once(() => require('../dist-raw/node-internal-modules-cjs-loader').createCjsLoader({
        extensions,
        preferTsExts: options.preferTsExts,
        nodeEsmResolver: getNodeEsmResolver(),
    }));

    return {
        [TS_NODE_SERVICE_BRAND]: true,
        ts,
        compilerPath: compiler,
        config,
        compile,
        getTypeInfo,
        ignored,
        enabled,
        options,
        configFilePath,
        moduleTypeClassifier,
        shouldReplAwait,
        addDiagnosticFilter,
        installSourceMapSupport,
        enableExperimentalEsmLoaderInterop,
        transpileOnly,
        projectLocalResolveHelper,
        getNodeEsmResolver,
        getNodeEsmGetFormat,
        getNodeCjsLoader,
        extensions,
    };
}

function createIgnore(ignoreBaseDir, ignore) {
    return (fileName) => {
        const relname = path.relative(ignoreBaseDir, fileName);
        const path = normalizeSlashes(relname);
        return ignore.some((x) => x.test(path));
    };
}

function registerExtensions(preferTsExts, extensions, service, originalJsHandler) {
    const exts = new Set(extensions);
    for (const cannotAdd of ['.mts', '.cts', '.mjs', '.cjs']) {
        if (exts.has(cannotAdd) && !Object.prototype.hasOwnProperty.call(require.extensions, cannotAdd)) {
            exts.add('.js');
            exts.delete(cannotAdd);
        }
    }
    for (const ext of exts) {
        registerExtension(ext, service, originalJsHandler);
    }
    if (preferTsExts) {
        const preferredExtensions = new Set([...exts, ...Object.keys(require.extensions)]);
        for (const ext of preferredExtensions) {
            const old = Object.getOwnPropertyDescriptor(require.extensions, ext);
            delete require.extensions[ext];
            Object.defineProperty(require.extensions, ext, old);
        }
    }
}

function registerExtension(ext, service, originalHandler) {
    const old = require.extensions[ext] || originalHandler;
    require.extensions[ext] = function (m, filename) {
        if (service.ignored(filename)) return old(m, filename);
        assertScriptCanLoadAsCJS(service, m, filename);
        const _compile = m._compile;
        m._compile = function (code, fileName) {
            debug('module._compile', fileName);
            const result = service.compile(code, fileName);
            return _compile.call(this, result, fileName);
        };
        return old(m, filename);
    };
}

function updateOutput(outputText, fileName, sourceMap, getEmitExtension) {
    const base64Map = Buffer.from(updateSourceMap(sourceMap, fileName), 'utf8').toString('base64');
    const sourceMapContent = `//# sourceMappingURL=data:application/json;base64,${base64Map}`;
    const prefix = '//# sourceMappingURL=';
    const prefixLength = prefix.length;
    const baseName = path.basename(fileName);
    const extName = path.extname(fileName);
    const extension = getEmitExtension(fileName);
    const sourcemapFilename = baseName.slice(0, -extName.length) + extension + '.map';
    const sourceMapLengthWithoutPercentEncoding = prefixLength + sourcemapFilename.length;

    if (outputText.substr(-sourceMapLengthWithoutPercentEncoding, prefixLength) === prefix) {
        return outputText.slice(0, -sourceMapLengthWithoutPercentEncoding) + sourceMapContent;
    }

    const sourceMapLengthWithPercentEncoding = prefixLength + encodeURI(sourcemapFilename).length;
    if (outputText.substr(-sourceMapLengthWithPercentEncoding, prefixLength) === prefix) {
        return outputText.slice(0, -sourceMapLengthWithPercentEncoding) + sourceMapContent;
    }
    return `${outputText}\n${sourceMapContent}`;
}

function updateSourceMap(sourceMapText, fileName) {
    const sourceMap = JSON.parse(sourceMapText);
    sourceMap.file = fileName;
    sourceMap.sources = [fileName];
    delete sourceMap.sourceRoot;
    return JSON.stringify(sourceMap);
}

function filterDiagnostics(diagnostics, filters) {
    return diagnostics.filter((d) => filters.every((f) => {
        return (!f.appliesToAllFiles && f.filenamesAbsolute.indexOf(d.file?.fileName) === -1) ||
            f.diagnosticsIgnored.indexOf(d.code) === -1;
    }));
}

function getTokenAtPosition(ts, sourceFile, position) {
    let current = sourceFile;
    outer: while (true) {
        for (const child of current.getChildren(sourceFile)) {
            const start = child.getFullStart();
            if (start > position) break;
            const end = child.getEnd();
            if (position <= end) {
                current = child;
                continue outer;
            }
        }
        return current;
    }
}

const createEsmHooks = (tsNodeService) => require('./esm').createEsmHooks(tsNodeService);

module.exports = {
    register,
    create,
    createFromPreloadedConfig,
    createEsmHooks,
    TSError,
    VERSION,
    DEFAULTS,
    REGISTER_INSTANCE,
    debug,
    INSPECT_CUSTOM,
    env,
    env as defaultEnv,
    createRepl,
};
```
