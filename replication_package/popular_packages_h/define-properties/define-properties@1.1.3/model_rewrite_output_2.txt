The provided Node.js code defines a utility to add properties to objects in a robust manner, considering potential lack of support for property descriptors, such as those present in older JavaScript environments like IE8. The core functionality is implemented in the `defineProperty` and `defineProperties` functions. Here's a breakdown of the code's functionality:

1. **Dependency and Feature Checks**:
   - It uses `require('object-keys')` to import a function for extracting keys from an object.
   - It checks if the JavaScript `Symbol` type is supported, which is a more modern feature.
   - Several prototypes are stored for use: `Object.prototype.toString` and `Array.prototype.concat`.

2. **Utility Functions**:
   - `isFunction`: Determines if a given input is a function using `typeof` and `toString`.
   - `arePropertyDescriptorsSupported`: Detects if the JavaScript environment supports property descriptors.
   - `defineProperty`: Defines a property on an object with specified characteristics (configurable, enumerable, writable) based on environment descriptor support.
   - `defineProperties`: Iterates over an object of properties (and optional predicates) to define them on a target object, handling symbol keys when supported.

3. **Module Export**:
   - Exports the `defineProperties` function and includes a property to indicate whether the environment supports descriptors.

Rewritten Code:

```javascript
'use strict';

const keys = require('object-keys');
const hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

const toStr = Object.prototype.toString;
const concat = Array.prototype.concat;
const origDefineProperty = Object.defineProperty;

const isFunction = (fn) => typeof fn === 'function' && toStr.call(fn) === '[object Function]';

const arePropertyDescriptorsSupported = () => {
    const obj = {};
    try {
        origDefineProperty(obj, 'x', { enumerable: false, value: obj });
        for (const _ in obj) {
            return false;
        }
        return obj.x === obj;
    } catch (e) {
        return false;
    }
};

const supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

const defineProperty = (object, name, value, predicate) => {
    if (name in object && (!isFunction(predicate) || !predicate())) {
        return;
    }
    if (supportsDescriptors) {
        origDefineProperty(object, name, {
            configurable: true,
            enumerable: false,
            value: value,
            writable: true
        });
    } else {
        object[name] = value;
    }
};

const defineProperties = (object, map, predicates = {}) => {
    let props = keys(map);
    if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map));
    }
    for (let i = 0; i < props.length; i += 1) {
        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
    }
};

defineProperties.supportsDescriptors = Boolean(supportsDescriptors);

module.exports = defineProperties;
```