The provided Node.js code defines a function called `deepmerge` which is designed to recursively merge two or more objects. It supports various custom options to control the merge behavior, including merging arrays, handling non-enumerable properties, and dealing with certain special objects (e.g., dates, regular expressions, and React elements). Here's a breakdown of its main functionalities:

1. **isMergeableObject**: Determines if an object can be merged, ensuring it's a non-null object and not a special object like a RegExp, Date, or React element.
   
2. **cloneUnlessOtherwiseSpecified**: Clones the value unless specified otherwise by the options provided.
   
3. **defaultArrayMerge**: Defines how arrays should be merged, concatenating them and then applying cloning logic to each element.
   
4. **mergeObject**: Merges two objects recursively, respecting the merge options and protecting against prototype poisoning.

5. **deepmerge**: The main function that conditionally merges the target and source objects based on their type and specified options.

6. **deepmerge.all**: Merges an array of objects together using `deepmerge`.

The code is efficiently organized to handle different edge cases and custom merging strategies via user-defined callbacks or functions.

Here's the rewritten code with the same functionality:

```javascript
'use strict';

const isMergeableObject = (value) =>
  isNonNullObject(value) && !isSpecial(value);

const isNonNullObject = (value) => value && typeof value === 'object';

const isSpecial = (value) => {
  const stringValue = Object.prototype.toString.call(value);
  return (
    stringValue === '[object RegExp]' ||
    stringValue === '[object Date]' ||
    isReactElement(value)
  );
};

const canUseSymbol = typeof Symbol === 'function' && Symbol.for;
const REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

const isReactElement = (value) => value.$$typeof === REACT_ELEMENT_TYPE;

const emptyTarget = (val) => (Array.isArray(val) ? [] : {});

const cloneUnlessOtherwiseSpecified = (value, options) =>
  options.clone !== false && options.isMergeableObject(value)
    ? deepmerge(emptyTarget(value), value, options)
    : value;

const defaultArrayMerge = (target, source, options) =>
  target.concat(source).map((element) =>
    cloneUnlessOtherwiseSpecified(element, options)
  );

const getMergeFunction = (key, options) => {
  if (!options.customMerge) {
    return deepmerge;
  }
  const customMerge = options.customMerge(key);
  return typeof customMerge === 'function' ? customMerge : deepmerge;
};

const getEnumerableOwnPropertySymbols = (target) =>
  Object.getOwnPropertySymbols
    ? Object.getOwnPropertySymbols(target).filter((symbol) =>
        Object.propertyIsEnumerable.call(target, symbol)
      )
    : [];

const getKeys = (target) =>
  Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));

const propertyIsOnObject = (object, property) => {
  try {
    return property in object;
  } catch (_) {
    return false;
  }
};

const propertyIsUnsafe = (target, key) =>
  propertyIsOnObject(target, key) &&
  !(Object.hasOwnProperty.call(target, key) &&
    Object.propertyIsEnumerable.call(target, key));

const mergeObject = (target, source, options) => {
  const destination = {};
  if (options.isMergeableObject(target)) {
    getKeys(target).forEach((key) => {
      destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    });
  }
  getKeys(source).forEach((key) => {
    if (propertyIsUnsafe(target, key)) {
      return;
    }

    if (
      propertyIsOnObject(target, key) &&
      options.isMergeableObject(source[key])
    ) {
      destination[key] = getMergeFunction(key, options)(
        target[key],
        source[key],
        options
      );
    } else {
      destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    }
  });
  return destination;
};

const deepmerge = (target, source, options = {}) => {
  options.arrayMerge = options.arrayMerge || defaultArrayMerge;
  options.isMergeableObject = options.isMergeableObject || isMergeableObject;
  options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

  const sourceIsArray = Array.isArray(source);
  const targetIsArray = Array.isArray(target);
  const sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

  if (!sourceAndTargetTypesMatch) {
    return cloneUnlessOtherwiseSpecified(source, options);
  } else if (sourceIsArray) {
    return options.arrayMerge(target, source, options);
  } else {
    return mergeObject(target, source, options);
  }
};

deepmerge.all = (array, options) => {
  if (!Array.isArray(array)) {
    throw new Error('first argument should be an array');
  }

  return array.reduce((prev, next) => deepmerge(prev, next, options), {});
};

module.exports = deepmerge;
```