The given Node.js code is a module that renders a DOM node or array of DOM nodes to a string, similar to how `outerHTML` would work in a browser. It includes several functions that handle the serialization and formatting of different DOM node types (e.g., text, tags, comments, directives). The code also manages XML and HTML modes, encoding entity handling, and managing foreign content (such as SVG or MathML) integration within HTML documents.

Here is the rewritten Node.js code:

```javascript
"use strict";

const { encodeXML, escapeAttribute, escapeText } = require("entities");
const ElementType = require("domelementtype");
const { attributeNames, elementNames } = require("./foreignNames.js");

function replaceQuotes(value) {
    return value.replace(/"/g, "&quot;");
}

function formatAttributes(attributes, opts) {
    if (!attributes) return;

    const encode = opts.encodeEntities === false || (opts.decodeEntities === false)
        ? replaceQuotes
        : opts.xmlMode || opts.encodeEntities !== "utf8"
            ? encodeXML
            : escapeAttribute;

    return Object.keys(attributes)
        .map(key => {
            let value = attributes[key] || "";
            if (opts.xmlMode === "foreign") {
                key = attributeNames.get(key) || key;
            }
            if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
                return key;
            }
            return `${key}="${encode(value)}"`;
        })
        .join(" ");
}

const singleTag = new Set([
    "area", "base", "basefont", "br", "col", "command", "embed",
    "frame", "hr", "img", "input", "isindex", "keygen", "link", 
    "meta", "param", "source", "track", "wbr"
]);

const unencodedElements = new Set([
    "style", "script", "xmp", "iframe", "noembed",
    "noframes", "plaintext", "noscript"
]);

const foreignModeIntegrationPoints = new Set([
    "mi", "mo", "mn", "ms", "mtext", "annotation-xml",
    "foreignObject", "desc", "title"
]);

const foreignElements = new Set(["svg", "math"]);

function render(node, options = {}) {
    const nodes = Array.isArray(node) ? node : [node];
    return nodes.map(n => renderNode(n, options)).join("");
}

function renderNode(node, options) {
    switch (node.type) {
        case ElementType.Root:
            return render(node.children, options);
        case ElementType.Doctype:
        case ElementType.Directive:
            return renderDirective(node);
        case ElementType.Comment:
            return renderComment(node);
        case ElementType.CDATA:
            return renderCdata(node);
        case ElementType.Script:
        case ElementType.Style:
        case ElementType.Tag:
            return renderTag(node, options);
        case ElementType.Text:
            return renderText(node, options);
        default:
            return "";
    }
}

function renderTag(elem, opts) {
    if (opts.xmlMode === "foreign") {
        elem.name = elementNames.get(elem.name) || elem.name;
        if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
            opts = { ...opts, xmlMode: false };
        }
    }

    if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = { ...opts, xmlMode: "foreign" };
    }

    let tag = `<${elem.name}`;
    const attribs = formatAttributes(elem.attribs, opts);
    if (attribs) {
        tag += ` ${attribs}`;
    }

    if (elem.children.length === 0 
        && (opts.xmlMode ? opts.selfClosingTags !== false 
                         : opts.selfClosingTags && singleTag.has(elem.name))) {
        tag += (!opts.xmlMode ? " " : "") + "/>";
    } else {
        tag += ">";
        if (elem.children.length > 0) {
            tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
            tag += `</${elem.name}>`;
        }
    }
    return tag;
}

function renderDirective(elem) {
    return `<${elem.data}>`;
}

function renderText(elem, opts) {
    let data = elem.data || "";
    if (opts.encodeEntities !== false 
        && (opts.decodeEntities !== false) 
        && (!opts.xmlMode 
            && elem.parent 
            && unencodedElements.has(elem.parent.name)) !== true) {
        data = opts.xmlMode || opts.encodeEntities !== "utf8"
            ? encodeXML(data)
            : escapeText(data);
    }
    return data;
}

function renderCdata(elem) {
    return `<![CDATA[${elem.children[0].data}]]>`;
}

function renderComment(elem) {
    return `<!--${elem.data}-->`;
}

exports.render = render;
exports.default = render;
```