The provided Node.js code defines an `iconv-lite` module, which is used for encoding and decoding character sets. Here is the functionality explained:

1. **Imports and Initial Setup**:
   - It imports a safe buffer implementation from `safer-buffer`.
   - It requires a module for BOM (Byte Order Mark) handling.
   - It initializes `iconv` and sets up properties to hold encodings, default characters for errors, and cache codec data.

2. **Encoding and Decoding Functions**:
   - `iconv.encode`: Converts a given string to a specified encoding using an encoder object.
   - `iconv.decode`: Converts a given buffer to a string using a specified encoding decoder. Issues a warning for string inputs which are deprecated.

3. **Encoding and Decoding Helpers**:
   - `iconv.encodingExists`: Checks if the specified encoding exists by attempting to get its codec.
   - `iconv.toEncoding` and `iconv.fromEncoding`: Aliases for `encode` and `decode` respectively.

4. **Codec Management**:
   - `iconv.getCodec`: Retrieves or initializes the codec for a given encoding using lazy loading if necessary.
   - `iconv._canonicalizeEncoding`: Sanitizes and standardizes encoding string representations.

5. **Codec Handlers**:
   - `iconv.getEncoder` and `iconv.getDecoder`: Obtain the encoder or decoder for a given encoding, handling BOM if applicable.

6. **Streaming API**:
   - Provides streaming capabilities for encoding and decoding using Node.js's `stream` module, though it's not enabled by default in browser environments.
   - `iconv.enableStreamingAPI`: Enables the streaming API by injecting the stream module.
   - Default implementations for `encodeStream` and `decodeStream` are provided if streaming is supported.

7. **Behavior in Different Environments**:
   - Tries to load the `stream` module to enable streaming capabilities.
   - Provides an error message if streaming is attempted without enabling it in environments missing the `stream` module.
   - Checks and warns if the JavaScript source files are not using UTF-8 encoding.

Here's the rewritten Node.js code based on the above explanation:

```javascript
"use strict";

const { Buffer } = require("safer-buffer");
const bomHandling = require("./bom-handling");
const iconv = module.exports;

// Initialize codecs storage and default error characters.
iconv.encodings = null;
iconv.defaultCharUnicode = '�';
iconv.defaultCharSingleByte = '?';

// Encode a string into a specific encoding.
iconv.encode = function(str, encoding, options) {
    str = String(str || "");
    const encoder = iconv.getEncoder(encoding, options);
    const res = encoder.write(str);
    const trail = encoder.end();
    return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;
};

// Decode a buffer into a string with a specific encoding.
iconv.decode = function(buf, encoding, options) {
    if (typeof buf === 'string') {
        if (!iconv.skipDecodeWarning) {
            console.error('Iconv-lite warning: decode()-ing strings is deprecated.');
            iconv.skipDecodeWarning = true;
        }
        buf = Buffer.from(String(buf || ""), "binary");
    }
    const decoder = iconv.getDecoder(encoding, options);
    const res = decoder.write(buf);
    const trail = decoder.end();
    return trail ? res + trail : res;
};

// Check if a given encoding exists.
iconv.encodingExists = function(enc) {
    try {
        iconv.getCodec(enc);
        return true;
    } catch (e) {
        return false;
    }
};

// Aliases for convert functions.
iconv.toEncoding = iconv.encode;
iconv.fromEncoding = iconv.decode;

// Cache and retrieve codecs by encoding name.
iconv._codecDataCache = {};
iconv.getCodec = function(encoding) {
    if (!iconv.encodings) iconv.encodings = require("../encodings");
    let enc = iconv._canonicalizeEncoding(encoding);
    const codecOptions = {};

    while (true) {
        let codec = iconv._codecDataCache[enc];
        if (codec) return codec;

        let codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
            case "string":
                enc = codecDef;
                break;

            case "object":
                Object.assign(codecOptions, codecDef);
                if (!codecOptions.encodingName) codecOptions.encodingName = enc;
                enc = codecDef.type;
                break;

            case "function":
                if (!codecOptions.encodingName) codecOptions.encodingName = enc;
                codec = new codecDef(codecOptions, iconv);
                iconv._codecDataCache[codecOptions.encodingName] = codec;
                return codec;

            default:
                throw new Error(`Encoding not recognized: '${encoding}'`);
        }
    }
};

// Helper to clean up encoding names.
iconv._canonicalizeEncoding = function(encoding) {
    return String(encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
};

// Get encoder and decoder for a given encoding.
iconv.getEncoder = function(encoding, options) {
    const codec = iconv.getCodec(encoding);
    let encoder = new codec.encoder(options, codec);
    if (codec.bomAware && options?.addBOM) {
        encoder = new bomHandling.PrependBOM(encoder, options);
    }
    return encoder;
};

iconv.getDecoder = function(encoding, options) {
    const codec = iconv.getCodec(encoding);
    let decoder = new codec.decoder(options, codec);
    if (codec.bomAware && !(options?.stripBOM === false)) {
        decoder = new bomHandling.StripBOM(decoder, options);
    }
    return decoder;
};

// Enable streaming API support if the stream module is available.
iconv.enableStreamingAPI = function(stream_module) {
    if (iconv.supportsStreams) return;
    const streams = require("./streams")(stream_module);
    iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;

    iconv.encodeStream = function(encoding, options) {
        return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
    };
    iconv.decodeStream = function(encoding, options) {
        return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
    };

    iconv.supportsStreams = true;
};

let stream_module;
try {
    stream_module = require("stream");
} catch (e) {}

if (stream_module && stream_module.Transform) {
    iconv.enableStreamingAPI(stream_module);
} else {
    iconv.encodeStream = iconv.decodeStream = function() {
        throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
    };
}

if ("Ā" !== "\u0100") {
    console.error("iconv-lite warning: js files use non-utf8 encoding.");
}
```