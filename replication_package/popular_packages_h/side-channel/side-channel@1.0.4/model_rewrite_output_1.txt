The provided Node.js code defines a module that creates a side channel for storing key-value pairs using different data structures depending on the environment and the nature of the keys. Here's a breakdown of the functionality:

1. **Intrinsics and Utility Imports**: The code imports utilities to get intrinsic object references and bind methods (`get-intrinsic` and `call-bind/callBound`). It also imports an object inspection utility for error handling (`object-inspect`).

2. **Error and Collection References**: The intrinsic references for `TypeError`, `WeakMap`, and `Map` are obtained. Specific List and Map methods are bounded (`get`, `set`, `has`) for use within the functions.

3. **List Handling Functions**: 
   - `listGetNode`: Traverses a linked list to find a node with a given key while moving the accessed node to the front for faster future access (acting as a self-organizing list).
   - `listGet`: Retrieves the value associated with a key from a linked list.
   - `listSet`: Adds or updates a key-value pair in the linked list, ensuring the most recent node is at the front.
   - `listHas`: Checks if a key exists in the linked list.

4. **Side Channel Implementation**: 
   - It exports a function `getSideChannel` which returns an object (`channel`) that provides methods to `assert`, `get`, `has`, and `set` values in the side channel.
   - Depending on the key type and availability of `WeakMap`, `Map`, or fallback linked list, the appropriate data structure is chosen for storing key-value pairs.
   - `assert` throws an error if the key does not exist in the side channel.
   - `get`, `has`, and `set` methods manipulate the data based on which storage strategy (WeakMap, Map, or linked list) is available.

Here's the rewritten code with the same functionality:

```javascript
'use strict';

const GetIntrinsic = require('get-intrinsic');
const callBound = require('call-bind/callBound');
const inspect = require('object-inspect');

const $TypeError = GetIntrinsic('%TypeError%');
const $WeakMap = GetIntrinsic('%WeakMap%', true);
const $Map = GetIntrinsic('%Map%', true);

const $weakMapGet = callBound('WeakMap.prototype.get', true);
const $weakMapSet = callBound('WeakMap.prototype.set', true);
const $weakMapHas = callBound('WeakMap.prototype.has', true);
const $mapGet = callBound('Map.prototype.get', true);
const $mapSet = callBound('Map.prototype.set', true);
const $mapHas = callBound('Map.prototype.has', true);

function listGetNode(list, key) {
    for (let prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
            prev.next = curr.next;
            curr.next = list.next;
            list.next = curr;
            return curr;
        }
    }
}

function listGet(objects, key) {
    const node = listGetNode(objects, key);
    return node && node.value;
}

function listSet(objects, key, value) {
    const node = listGetNode(objects, key);
    if (node) {
        node.value = value;
    } else {
        objects.next = { key, next: objects.next, value };
    }
}

function listHas(objects, key) {
    return !!listGetNode(objects, key);
}

module.exports = function createSideChannel() {
    let weakMapInstance;
    let mapInstance;
    let listInstance;

    const channel = {
        assert(key) {
            if (!channel.has(key)) {
                throw new $TypeError(`Side channel does not contain ${inspect(key)}`);
            }
        },
        get(key) {
            if ($WeakMap && (typeof key === 'object' || typeof key === 'function')) {
                return weakMapInstance && $weakMapGet(weakMapInstance, key);
            } else if ($Map) {
                return mapInstance && $mapGet(mapInstance, key);
            } else {
                return listInstance && listGet(listInstance, key);
            }
        },
        has(key) {
            if ($WeakMap && (typeof key === 'object' || typeof key === 'function')) {
                return weakMapInstance && $weakMapHas(weakMapInstance, key);
            } else if ($Map) {
                return mapInstance && $mapHas(mapInstance, key);
            } else {
                return listInstance && listHas(listInstance, key);
            }
        },
        set(key, value) {
            if ($WeakMap && (typeof key === 'object' || typeof key === 'function')) {
                if (!weakMapInstance) {
                    weakMapInstance = new $WeakMap();
                }
                $weakMapSet(weakMapInstance, key, value);
            } else if ($Map) {
                if (!mapInstance) {
                    mapInstance = new $Map();
                }
                $mapSet(mapInstance, key, value);
            } else {
                if (!listInstance) {
                    listInstance = { key: {}, next: null };
                }
                listSet(listInstance, key, value);
            }
        }
    };

    return channel;
};
```