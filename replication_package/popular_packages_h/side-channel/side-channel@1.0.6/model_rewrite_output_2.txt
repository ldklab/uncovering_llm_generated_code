The provided Node.js code defines a module that exposes a function to create a "side channel" for storing key-value pairs. The implementation supports storing data using different data structures: `WeakMap`, `Map`, or a custom linked list. The choice of data structure depends on the JavaScript environment's available intrinsic objects. The main functions provided by the side channel are `set`, `get`, `has`, and `assert`.

- **`set(key, value)`**: Stores a value associated with a key. For objects and functions, it prefers using `WeakMap`; otherwise, it uses `Map` or falls back to a linked list.
  
- **`get(key)`**: Retrieves the value associated with a key.

- **`has(key)`**: Checks if a key exists in the store.

- **`assert(key)`**: Asserts that a key is present in the store and throws a `TypeError` if it is not.

The code also optimizes access to recently accessed nodes in the linked list by moving them to the head of the list.

Here's a possible rewrite of this code:

```js
'use strict';

const GetIntrinsic = require('get-intrinsic');
const callBound = require('call-bind/callBound');
const inspect = require('object-inspect');

const $TypeError = require('es-errors/type');
const $WeakMap = GetIntrinsic('%WeakMap%', true);
const $Map = GetIntrinsic('%Map%', true);

const $weakMapGet = callBound('WeakMap.prototype.get', true);
const $weakMapSet = callBound('WeakMap.prototype.set', true);
const $weakMapHas = callBound('WeakMap.prototype.has', true);
const $mapGet = callBound('Map.prototype.get', true);
const $mapSet = callBound('Map.prototype.set', true);
const $mapHas = callBound('Map.prototype.has', true);

function listGetNode(list, key) {
  let prev = list;
  let curr;
  while ((curr = prev.next) !== null) {
    if (curr.key === key) {
      prev.next = curr.next;
      curr.next = list.next;
      list.next = curr;
      return curr;
    }
    prev = curr;
  }
}

function listGet(objects, key) {
  const node = listGetNode(objects, key);
  return node && node.value;
}

function listSet(objects, key, value) {
  const node = listGetNode(objects, key);
  if (node) {
    node.value = value;
  } else {
    objects.next = { key, next: objects.next, value };
  }
}

function listHas(objects, key) {
  return !!listGetNode(objects, key);
}

module.exports = function getSideChannel() {
  let $wm;
  let $m;
  let $o;

  const channel = {
    assert(key) {
      if (!channel.has(key)) {
        throw new $TypeError('Side channel does not contain ' + inspect(key));
      }
    },
    get(key) {
      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
        if ($wm) return $weakMapGet($wm, key);
      } else if ($Map) {
        if ($m) return $mapGet($m, key);
      } else {
        if ($o) return listGet($o, key);
      }
    },
    has(key) {
      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
        if ($wm) return $weakMapHas($wm, key);
      } else if ($Map) {
        if ($m) return $mapHas($m, key);
      } else {
        if ($o) return listHas($o, key);
      }
      return false;
    },
    set(key, value) {
      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
        if (!$wm) $wm = new $WeakMap();
        $weakMapSet($wm, key, value);
      } else if ($Map) {
        if (!$m) $m = new $Map();
        $mapSet($m, key, value);
      } else {
        if (!$o) $o = { key: {}, next: null };
        listSet($o, key, value);
      }
    }
  };
  return channel;
};
```