The Node.js code provided is a script that is designed to manage and execute commands with environment variables set specifically for that command. Here's a breakdown of the main functionalities of the script:

1. **Imports**: 
   - `cross-spawn` is used to spawn child processes that can run shell commands.
   - Custom modules `commandConvert` and `varValueConvert` are imported for processing commands and environment variable values.

2. **Function `crossEnv`**:
   - Accepts command-line arguments and optional configuration, parses them to extract environment variables, and then executes the command with these variables.
   - Uses regular expressions to identify environment variable declarations in the input arguments.
   - Sets up signal handlers to properly terminate spawned child processes.
   - Ensures the provided command runs with the specified environment variables and command-line arguments.

3. **Parsing**:
   - The `parseCommand` function is responsible for parsing command-line arguments into environment variable settings, a command, and command arguments.
   - Uses a regular expression to detect environment variable assignments and parse them accordingly, distinguishing any command and its arguments that follow.

4. **Environment Variables Handling**:
   - The `getEnvVars` function constructs the environment for the child process by combining the current process environment with any specified environment variables passed through the command line.

The code effectively sets a specified environment for executing a given command and manages the execution life cycle, including responding to termination signals.

Here is a possible rewrite of the code:

```javascript
const { spawn } = require('cross-spawn');
const commandConvert = require('./command');
const varValueConvert = require('./variable');

module.exports = crossEnv;

const envSetterRegex = /(\w+)=('(.*)'|"(.*)"|(.*))/;

function crossEnv(args, options = {}) {
  const [envSetters, command, commandArgs] = parseCommand(args);
  const env = constructEnvVars(envSetters);

  if (command) {
    const proc = spawn(
      commandConvert(command, env, true),
      commandArgs.map(arg => commandConvert(arg, env)),
      {
        stdio: 'inherit',
        shell: options.shell,
        env,
      }
    );

    ['SIGTERM', 'SIGINT', 'SIGBREAK', 'SIGHUP'].forEach(signal => {
      process.on(signal, () => proc.kill(signal));
    });

    proc.on('exit', (code, signal) => {
      const exitCode = code === null ? (signal === 'SIGINT' ? 0 : 1) : code;
      process.exit(exitCode);
    });

    return proc;
  }

  return null;
}

function parseCommand(args) {
  const envSetters = {};
  let command = null;
  let commandArgs = [];

  for (let i = 0; i < args.length; i++) {
    const match = envSetterRegex.exec(args[i]);
    if (match) {
      const value = match[3] ?? match[5] ?? match[4];
      envSetters[match[1]] = value;
    } else {
      const [cmd, ...cmdArgs] = args.slice(i).map(arg =>
        arg.replace(/\\\\|(\\)?'|([\\])(?=[$"\\])/g, match => 
          ({ '\\\\': '\\', "\\'": "'"}[match] || ''))
      );
      command = cmd;
      commandArgs = cmdArgs;
      break;
    }
  }

  return [envSetters, command, commandArgs];
}

function constructEnvVars(envSetters) {
  const envVars = { ...process.env };
  
  if (process.env.APPDATA) {
    envVars.APPDATA = process.env.APPDATA;
  }

  Object.entries(envSetters).forEach(([varName, value]) => {
    envVars[varName] = varValueConvert(value, varName);
  });

  return envVars;
}
```