The provided Node.js code is a module that checks if a specified feature or package is part of the core Node.js modules for a particular node version. Here's a breakdown of its functionality:

1. **specifierIncluded():** 
   - Determines if a specific version specifier matches the current Node.js version.
   - Compares the current version of Node.js (`current`) with a version specified by a string specifier (`specifier`).
   - Supports comparison operators `<` (less than) and `>=` (greater than or equal to).

2. **matchesRange():**
   - Checks if the current Node.js version satisfies a given range of version specifiers.
   - The range may contain multiple specifiers combined using `&&`, indicating all conditions must be met.

3. **versionIncluded():**
   - Determines if the current Node.js version matches a specified version requirement (specifierValue).
   - Handles both boolean specifiers and array of specifiers by calling `matchesRange()`.
   - Defaults to using the version specified in `process.versions.node` if no `nodeVersion` is provided.

4. **isCore():**
   - Exports a function that verifies whether a core module (`x`) is available in the specified Node.js version.
   - Checks if the module exists in `data` (presumably from `core.json`) and if the version requirements are met using `versionIncluded()`.

Below is a rewritten, organized version of the code:

```javascript
'use strict';

const has = require('has');
const data = require('./core.json');

function specifierIncluded(current, specifier) {
    const nodeParts = current.split('.');
    const parts = specifier.split(' ');
    const op = parts.length > 1 ? parts[0] : '=';
    const versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');

    for (let i = 0; i < 3; ++i) {
        const cur = parseInt(nodeParts[i] || 0, 10);
        const ver = parseInt(versionParts[i] || 0, 10);

        if (cur === ver) {
            continue;
        }
        if (op === '<') {
            return cur < ver;
        }
        if (op === '>=') {
            return cur >= ver;
        }
        return false;
    }
    return op === '>=';
}

function matchesRange(current, range) {
    const specifiers = range.split(/ ?&& ?/);
    if (specifiers.length === 0) {
        return false;
    }
    return specifiers.every(specifier => specifierIncluded(current, specifier));
}

function versionIncluded(nodeVersion, specifierValue) {
    if (typeof specifierValue === 'boolean') {
        return specifierValue;
    }

    const current = nodeVersion ?? process?.versions?.node;

    if (typeof current !== 'string') {
        throw new TypeError(nodeVersion === undefined
            ? 'Unable to determine current node version'
            : 'If provided, a valid node version is required');
    }

    if (specifierValue && typeof specifierValue === 'object') {
        return specifierValue.some(range => matchesRange(current, range));
    }
    return matchesRange(current, specifierValue);
}

module.exports = function isCore(x, nodeVersion) {
    return has(data, x) && versionIncluded(nodeVersion, data[x]);
};
```