The functionality of the provided Node.js code is primarily related to managing "visitor keys" for an Abstract Syntax Tree (AST). Visitor keys are essentially the properties of nodes in an AST that are traversed or visited during operations like walking or searching through the tree. Here's a breakdown of the functionality:

1. **Visitor Keys Definition**: The `VisitorKeys` object is defined as a dictionary where keys represent different types of nodes (like `ArrayExpression`, `ArrowFunctionExpression`) and each value is an array of related properties (like `params`, `body`) which should be visited.

2. **Type Definitions**: A type `VisitorKeys` is defined as an object that has string keys mapping to a read-only array of strings, indicating that the properties for each node type are fixed.

3. **Node Types**: It gathers all node types (keys of the `VisitorKeys` object) into an array called `NODE_TYPES`.

4. **Data Freezing**: The code freezes all reference objects within the `VisitorKeys` to ensure immutability, which is essential to ensure the integrity of the visitor keys during operations.

5. **Key Blacklist**: A blacklist of keys is maintained (`KEY_BLACKLIST`), which are ignored when checking which keys should be used for visiting nodes, such as keys related to comments or internal metadata.

6. **Filter Function**: A utility function `filterKey` is provided to check if a key should be used. It excludes keys that are on the blacklist or have names starting with an underscore.

7. **Key Retrieval**: The `getKeys` function allows fetching the keys from a given AST node that are valid for visiting, employing the filter function.

8. **Union Functionality**: The `unionWith` function allows for merging custom additional visitor keys with the existing `VisitorKeys`, creating a combined set where existing keys are augmented without overriding.

9. **Exports**: The module exports the `KEYS`, `getKeys`, and `unionWith` functions so that they can be used in other parts of the application or by other modules.

Here is a rewritten version of the code following this explanation:

```javascript
'use strict';

/**
 * @typedef {{ readonly [type: string]: ReadonlyArray<string> }} VisitorKeys
 */

/**
 * @type {VisitorKeys}
 */
const KEYS = {
    ArrayExpression: ["elements"],
    ArrayPattern: ["elements"],
    ArrowFunctionExpression: ["params", "body"],
    AssignmentExpression: ["left", "right"],
    AssignmentPattern: ["left", "right"],
    AwaitExpression: ["argument"],
    BinaryExpression: ["left", "right"],
    BlockStatement: ["body"],
    BreakStatement: ["label"],
    CallExpression: ["callee", "arguments"],
    CatchClause: ["param", "body"],
    ChainExpression: ["expression"],
    ClassBody: ["body"],
    ClassDeclaration: ["id", "superClass", "body"],
    ClassExpression: ["id", "superClass", "body"],
    ConditionalExpression: ["test", "consequent", "alternate"],
    ContinueStatement: ["label"],
    DebuggerStatement: [],
    DoWhileStatement: ["body", "test"],
    EmptyStatement: [],
    ExperimentalRestProperty: ["argument"],
    ExperimentalSpreadProperty: ["argument"],
    ExportAllDeclaration: ["exported", "source"],
    ExportDefaultDeclaration: ["declaration"],
    ExportNamedDeclaration: ["declaration", "specifiers", "source"],
    ExportSpecifier: ["exported", "local"],
    ExpressionStatement: ["expression"],
    ForInStatement: ["left", "right", "body"],
    ForOfStatement: ["left", "right", "body"],
    ForStatement: ["init", "test", "update", "body"],
    FunctionDeclaration: ["id", "params", "body"],
    FunctionExpression: ["id", "params", "body"],
    Identifier: [],
    IfStatement: ["test", "consequent", "alternate"],
    ImportDeclaration: ["specifiers", "source"],
    ImportDefaultSpecifier: ["local"],
    ImportExpression: ["source"],
    ImportNamespaceSpecifier: ["local"],
    ImportSpecifier: ["imported", "local"],
    JSXAttribute: ["name", "value"],
    JSXClosingElement: ["name"],
    JSXClosingFragment: [],
    JSXElement: ["openingElement", "children", "closingElement"],
    JSXEmptyExpression: [],
    JSXExpressionContainer: ["expression"],
    JSXFragment: ["openingFragment", "children", "closingFragment"],
    JSXIdentifier: [],
    JSXMemberExpression: ["object", "property"],
    JSXNamespacedName: ["namespace", "name"],
    JSXOpeningElement: ["name", "attributes"],
    JSXOpeningFragment: [],
    JSXSpreadAttribute: ["argument"],
    JSXSpreadChild: ["expression"],
    JSXText: [],
    LabeledStatement: ["label", "body"],
    Literal: [],
    LogicalExpression: ["left", "right"],
    MemberExpression: ["object", "property"],
    MetaProperty: ["meta", "property"],
    MethodDefinition: ["key", "value"],
    NewExpression: ["callee", "arguments"],
    ObjectExpression: ["properties"],
    ObjectPattern: ["properties"],
    PrivateIdentifier: [],
    Program: ["body"],
    Property: ["key", "value"],
    PropertyDefinition: ["key", "value"],
    RestElement: ["argument"],
    ReturnStatement: ["argument"],
    SequenceExpression: ["expressions"],
    SpreadElement: ["argument"],
    StaticBlock: ["body"],
    Super: [],
    SwitchCase: ["test", "consequent"],
    SwitchStatement: ["discriminant", "cases"],
    TaggedTemplateExpression: ["tag", "quasi"],
    TemplateElement: [],
    TemplateLiteral: ["quasis", "expressions"],
    ThisExpression: [],
    ThrowStatement: ["argument"],
    TryStatement: ["block", "handler", "finalizer"],
    UnaryExpression: ["argument"],
    UpdateExpression: ["argument"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id", "init"],
    WhileStatement: ["test", "body"],
    WithStatement: ["object", "body"],
    YieldExpression: ["argument"]
};

// Gather all node types from KEYS
const NODE_TYPES = Object.keys(KEYS);

// Freeze the visitor keys to ensure immutability
for (const type of NODE_TYPES) {
    Object.freeze(KEYS[type]);
}
Object.freeze(KEYS);

// List of keys to ignore when traversing
const KEY_BLACKLIST = new Set([
    "parent",
    "leadingComments",
    "trailingComments"
]);

// Function to filter valid keys for traversal
function filterKey(key) {
    return !KEY_BLACKLIST.has(key) && key[0] !== "_";
}

// Retrieve keys of a given AST node for visiting
function getKeys(node) {
    return Object.keys(node).filter(filterKey);
}

// Create a union set of KEYS and additionalKeys
function unionWith(additionalKeys) {
    const result = { ...KEYS };

    for (const [type, keys] of Object.entries(additionalKeys)) {
        const combinedKeys = result[type] ? new Set([...result[type], ...keys]) : new Set(keys);
        result[type] = Object.freeze([...combinedKeys]);
    }

    return Object.freeze(result);
}

// Exporting the relevant functions and KEYS object
exports.KEYS = KEYS;
exports.getKeys = getKeys;
exports.unionWith = unionWith;
```