The given Node.js code provides functionality to manage and manipulate a set of "visitor keys", which are used to traverse Abstract Syntax Tree (AST) nodes in a consistent manner. The code accomplishes the following goals:

1. **Initialize Visitor Keys**: The `KEYS` object, imported from `visitor-keys.json`, defines the initial set of keys used to traverse AST node types.

2. **Define Node Types**: `NODE_TYPES` is a list of all possible node types, derived from the keys present in the `KEYS` object.

3. **Freeze Keys**: The code ensures immutability by freezing the `KEYS` object and its values to prevent modifications at runtime.

4. **Blacklist Definition**: A blacklist is defined using `KEY_BLACKLIST` for keys that should be ignored in operations (e.g., "parent" or comment-related keys and keys starting with an underscore).

5. **Filter Function**: The `filterKey` function determines if a key should be considered, based on the blacklist and if it starts with an underscore.

6. **Module Exports**: The module exports an object that provides three main functionalities:
   - **Access to Visitor Keys**: It exposes the `KEYS` to access the node type keys.
   - **Get Keys of a Node**: The `getKeys` function returns a filtered list of keys for a given node.
   - **Union with Additional Keys**: The `unionWith` method allows merging additional keys into `KEYS`, creating a union set that extends the original set with new keys.

Here is a possible rewrite of the Node.js code to achieve these functionalities:

```javascript
"use strict";

const KEYS = require("./visitor-keys.json");

// Define node types by extracting keys from the KEYS object and freeze them for immutability.
const NODE_TYPES = Object.freeze(Object.keys(KEYS));

// Freeze each array of keys inside the KEYS object to prevent modifications.
NODE_TYPES.forEach(type => Object.freeze(KEYS[type]));
// Freeze the whole KEYS object to make it immutable.
Object.freeze(KEYS);

// Keys to be ignored due to specific reasons such as non-structural/documentation nature.
const KEY_BLACKLIST = new Set(["parent", "leadingComments", "trailingComments"]);

/**
 * Determines if a key should be included based on blacklist criteria and naming conventions.
 * @param {string} key - The key being evaluated.
 * @returns {boolean} - Returns true if the key is valid; otherwise, false.
 */
function filterKey(key) {
    return !KEY_BLACKLIST.has(key) && key[0] !== "_";
}

// Module exports to provide public API for working with visitor keys.
module.exports = Object.freeze({
    KEYS, // Expose the immutable KEYS for direct access.

    /**
     * Retrieves applicable visitor keys from a node, using the filterKey function.
     * @param {Object} node - The AST node to process.
     * @returns {string[]} - Array of valid keys from the node.
     */
    getKeys(node) {
        return Object.keys(node).filter(filterKey);
    },

    /**
     * Creates and returns a new set of visitor keys by merging KEYS with additional keys.
     * @param {Object} additionalKeys - Keys to be added to the current KEY set.
     * @returns {{ [type: string]: string[] | undefined }} - The combined set of keys.
     */
    unionWith(additionalKeys) {
        const result = { ...KEYS };

        for (const type of Object.keys(additionalKeys)) {
            const combinedKeys = new Set(result[type] ? result[type] : []);
            additionalKeys[type].forEach(key => combinedKeys.add(key));

            result[type] = Object.freeze(Array.from(combinedKeys));
        }

        return Object.freeze(result);
    }
});
```