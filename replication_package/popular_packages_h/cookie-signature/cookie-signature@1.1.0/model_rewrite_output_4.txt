The given Node.js code defines two functions, `sign` and `unsign`, intended to create and verify a signed value using HMAC SHA-256 for ensuring data integrity. 

### Functionality:
1. **`sign(val, secret)`**:
   - **Purpose**: This function generates a digital signature for a given value using a secret key.
   - **Arguments**:
     - `val`: The string value to be signed.
     - `secret`: The secret key used for signing.
   - **Process**:
     - Checks that both `val` and `secret` are strings, throwing an error if not.
     - Creates a HMAC using SHA-256 with the `secret`.
     - Updates the HMAC with the `val`.
     - Produces a digest of the HMAC in base64 format, trims any trailing `=` signs, and appends it to the value `val` separated by a dot (`.`).
   - **Returns**: The original value concatenated with its signature.

2. **`unsign(val, secret)`**:
   - **Purpose**: This function verifies the integrity of a signed value using the secret key.
   - **Arguments**:
     - `val`: The signed string to verify.
     - `secret`: The secret key used to verify the signature.
   - **Process**:
     - Ensures both `val` and `secret` are strings, throwing an error if they aren't.
     - Extracts the original value and recalculates its signature.
     - Uses `crypto.timingSafeEqual` to compare the recalculated signature with the existing signature concatenated to the original value.
   - **Returns**: The unsigned original value if the signature is valid, `false` otherwise.

```javascript
const crypto = require('crypto');

/**
 * Sign the given `val` with `secret`.
 *
 * @param {string} val - The value to sign.
 * @param {string} secret - The secret key for signing.
 * @returns {string} - The signed value.
 * @throws {TypeError} - If `val` or `secret` is not a string.
 * @api private
 */
exports.sign = (val, secret) => {
  if (typeof val !== 'string') throw new TypeError("Cookie value must be provided as a string.");
  if (typeof secret !== 'string') throw new TypeError("Secret string must be provided.");

  const hmac = crypto.createHmac('sha256', secret)
                      .update(val)
                      .digest('base64')
                      .replace(/=+$/, '');

  return `${val}.${hmac}`;
};

/**
 * Unsign and decode the given `val` with `secret`,
 * returning `false` if the signature is invalid.
 *
 * @param {string} val - The value to unsign.
 * @param {string} secret - The secret key for unsigning.
 * @returns {string|boolean} - The original value if valid, otherwise `false`.
 * @throws {TypeError} - If `val` or `secret` is not a string.
 * @api private
 */
exports.unsign = (val, secret) => {
  if (typeof val !== 'string') throw new TypeError("Signed cookie string must be provided.");
  if (typeof secret !== 'string') throw new TypeError("Secret string must be provided.");

  const originalValue = val.slice(0, val.lastIndexOf('.'));
  const signature = exports.sign(originalValue, secret);
  const signatureBuffer = Buffer.from(signature);
  const valueBuffer = Buffer.alloc(signatureBuffer.length, val);

  return crypto.timingSafeEqual(signatureBuffer, valueBuffer) ? originalValue : false;
};
```