The provided Node.js code defines a module that determines the appropriate proxy server for a given URL based on environment variables. Here's how the code functions:

1. **URL Parsing and Default Ports**:
   - It begins by requiring the `parse` function from the `url` module to analyze URL strings.
   - A set of default ports is defined for various protocols like HTTP, HTTPS, FTP, etc.

2. **Helper Function for String Matching**:
   - `stringEndsWith` is a polyfill for `String.prototype.endsWith`, which checks if a string ends with a specified substring.

3. **getProxyForUrl Function**:
   - It takes a URL (string or object) and determines the proxy URL that should handle requests to the given URL.
   - The function parses the URL to extract the protocol, hostname, and port.
   - If the hostname or protocol is missing, it returns an empty string to indicate no proxy.
   - Issues with matching IPv6 addresses are handled by stripping the port from the hostname manually.
   - The function determines if the URL should be proxied by invoking `shouldProxy`.

4. **shouldProxy Function**:
   - This function decides if a URL should be proxied based on the `NO_PROXY` environment variable.
   - If `NO_PROXY` is set to `*`, all URLs bypass the proxy. Otherwise, it checks specific host and port combinations.
   - The function supports exact hostname matches and wildcards to determine proxy exemption.

5. **getEnv Function**:
   - This is a utility function to retrieve environment variable values in a case-insensitive manner.

6. **Exported Functionality**:
   - The module exports the `getProxyForUrl` function for external usage.

Here is the code rewritten in a single markdown code block:

```javascript
'use strict';

const { parse } = require('url');

const DEFAULT_PORTS = {
  ftp: 21,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443,
};

const stringEndsWith = String.prototype.endsWith || function(s) {
  return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
};

/**
 * @param {string|object} url - The URL, or the result from url.parse.
 * @return {string} The URL of the proxy that should handle the request to the
 *  given URL. If no proxy is set, this will be an empty string.
 */
function getProxyForUrl(url) {
  const parsedUrl = typeof url === 'string' ? parse(url) : url || {};
  let proto = parsedUrl.protocol;
  let hostname = parsedUrl.host;
  let port = parsedUrl.port;
  if (typeof hostname !== 'string' || !hostname || typeof proto !== 'string') {
    return '';  // Don't proxy URLs without a valid scheme or host.
  }
  
  proto = proto.split(':', 1)[0];
  hostname = hostname.replace(/:\d*$/, '');
  port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
  if (!shouldProxy(hostname, port)) {
    return '';  // Don't proxy URLs that match NO_PROXY.
  }
  
  let proxy = 
    getEnv(`npm_config_${proto}_proxy`) ||
    getEnv(`${proto}_proxy`) ||
    getEnv('npm_config_proxy') ||
    getEnv('all_proxy');
  if (proxy && proxy.indexOf('://') === -1) {
    proxy = `${proto}://${proxy}`;
  }
  return proxy;
}

/**
 * Determines whether a given URL should be proxied.
 *
 * @param {string} hostname - The host name of the URL.
 * @param {number} port - The effective port of the URL.
 * @returns {boolean} Whether the given URL should be proxied.
 * @private
 */
function shouldProxy(hostname, port) {
  const NO_PROXY = (getEnv('npm_config_no_proxy') || getEnv('no_proxy')).toLowerCase();
  if (!NO_PROXY) {
    return true;  // Always proxy if NO_PROXY is not set.
  }
  if (NO_PROXY === '*') {
    return false;  // Never proxy if wildcard is set.
  }

  return NO_PROXY.split(/[,\s]/).every(function(proxy) {
    if (!proxy) {
      return true;  // Skip zero-length hosts.
    }
    const parsedProxy = proxy.match(/^(.+):(\d+)$/);
    const parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
    const parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
    if (parsedProxyPort && parsedProxyPort !== port) {
      return true;  // Skip if ports don't match.
    }

    if (!/^[.*]/.test(parsedProxyHostname)) {
      return hostname !== parsedProxyHostname;
    }

    if (parsedProxyHostname.charAt(0) === '*') {
      parsedProxyHostname = parsedProxyHostname.slice(1);
    }
    return !stringEndsWith.call(hostname, parsedProxyHostname);
  });
}

/**
 * Get the value for an environment variable.
 *
 * @param {string} key - The name of the environment variable.
 * @return {string} The value of the environment variable.
 * @private
 */
function getEnv(key) {
  return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || '';
}

module.exports.getProxyForUrl = getProxyForUrl;
```