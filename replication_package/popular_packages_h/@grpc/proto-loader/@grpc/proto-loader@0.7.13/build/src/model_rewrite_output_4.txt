The Node.js code provided is part of a module handling Protocol Buffers using the `protobufjs` library. Its main functionality is to load, process, and map Protocol Buffer (`.proto`) files into JavaScript objects. This module can serialize and deserialize Protocol Buffer messages, create package definitions from protocol buffer descriptor sets, and manage reflection objects like services, messages, and enums.

Here's a breakdown of the main functionalities:

1. **`isAnyExtension` Function**: Checks if an object has a `@type` property of type string.
2. **`IdempotencyLevel Enum`**: Enum to manage idempotency levels in RPC methods.
3. **Descriptor Options**: Object with configuration for handling Protocol Buffer descriptors.
4. **Utility Functions**: Such as `joinName`, `isHandledReflectionObject`, `isNamespaceBase` to aid in handling protobuf reflection objects.
5. **Serialization/Deserialization Functions**: `createSerializer` and `createDeserializer` handle serialization and deserialization of protobuf messages.
6. **Definition Creation**: Functions like `createMethodDefinition`, `createServiceDefinition`, `createMessageDefinition`, `createEnumDefinition`, and `createDefinition` are used to map protobuf structures (like services, messages, enums) into JavaScript definitions.
7. **`createPackageDefinition` & `createPackageDefinitionFromDescriptorSet`**: These functions parse and create package definitions from protobuf descriptor sets or roots derived from proto files.
8. **`load` and `loadSync` Functions**: These load `.proto` files asynchronously or synchronously, and convert them into package definitions.
9. **`fromJSON` Function**: Converts a JSON representation of a protobuf structure into package definitions.
10. **`loadFileDescriptorSetFromBuffer` and `loadFileDescriptorSetFromObject`**: Methods for loading file descriptor sets either from a buffer or an object.
11. **Adding Common Protos**: A utility function call to add common proto types.

The rewritten version maintains the same functionality with a slightly different presentation:

```javascript
"use strict";

const camelCase = require("lodash.camelcase");
const Protobuf = require("protobufjs");
const descriptor = require("protobufjs/ext/descriptor");
const { loadProtosWithOptions, loadProtosWithOptionsSync, addCommonProtos } = require("./util");
const Long = require("long");

exports.Long = Long;

function isAnyExtension(obj) {
    return ('@type' in obj) && (typeof obj['@type'] === 'string');
}
exports.isAnyExtension = isAnyExtension;

var IdempotencyLevel = {
    IDEMPOTENCY_UNKNOWN: "IDEMPOTENCY_UNKNOWN",
    NO_SIDE_EFFECTS: "NO_SIDE_EFFECTS",
    IDEMPOTENT: "IDEMPOTENT",
};
exports.IdempotencyLevel = IdempotencyLevel;

const descriptorOptions = {
    longs: String,
    enums: String,
    bytes: String,
    defaults: true,
    oneofs: true,
    json: true,
};

function joinName(baseName, name) {
    return baseName === '' ? name : `${baseName}.${name}`;
}

function isHandledReflectionObject(obj) {
    return (obj instanceof Protobuf.Service || obj instanceof Protobuf.Type || obj instanceof Protobuf.Enum);
}

function isNamespaceBase(obj) {
    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;
}

function getAllHandledReflectionObjects(obj, parentName) {
    const objName = joinName(parentName, obj.name);
    if (isHandledReflectionObject(obj)) {
        return [[objName, obj]];
    } else {
        if (isNamespaceBase(obj) && obj.nested !== undefined) {
            return Object.keys(obj.nested)
                .map(name => getAllHandledReflectionObjects(obj.nested[name], objName))
                .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);
        }
    }
    return [];
}

function createDeserializer(cls, options) {
    return function deserialize(argBuf) {
        return cls.toObject(cls.decode(argBuf), options);
    };
}

function createSerializer(cls) {
    return function serialize(arg) {
        if (Array.isArray(arg)) {
            throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);
        }
        const message = cls.fromObject(arg);
        return cls.encode(message).finish();
    };
}

function mapMethodOptions(options) {
    return (options || []).reduce((obj, item) => {
        for (const [key, value] of Object.entries(item)) {
            switch (key) {
                case 'uninterpreted_option':
                    obj.uninterpreted_option.push(item.uninterpreted_option);
                    break;
                default:
                    obj[key] = value;
                    break;
            }
        }
        return obj;
    }, {
        deprecated: false,
        idempotency_level: IdempotencyLevel.IDEMPOTENCY_UNKNOWN,
        uninterpreted_option: [],
    });
}

function createMethodDefinition(method, serviceName, options, fileDescriptors) {
    const requestType = method.resolvedRequestType;
    const responseType = method.resolvedResponseType;
    return {
        path: `/${serviceName}/${method.name}`,
        requestStream: !!method.requestStream,
        responseStream: !!method.responseStream,
        requestSerialize: createSerializer(requestType),
        requestDeserialize: createDeserializer(requestType, options),
        responseSerialize: createSerializer(responseType),
        responseDeserialize: createDeserializer(responseType, options),
        originalName: camelCase(method.name),
        requestType: createMessageDefinition(requestType, fileDescriptors),
        responseType: createMessageDefinition(responseType, fileDescriptors),
        options: mapMethodOptions(method.parsedOptions),
    };
}

function createServiceDefinition(service, name, options, fileDescriptors) {
    const def = {};
    service.methodsArray.forEach(method =>
        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors)
    );
    return def;
}

function createMessageDefinition(message, fileDescriptors) {
    const messageDescriptor = message.toDescriptor('proto3');
    return {
        format: 'Protocol Buffer 3 DescriptorProto',
        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),
        fileDescriptorProtos: fileDescriptors,
    };
}

function createEnumDefinition(enumType, fileDescriptors) {
    const enumDescriptor = enumType.toDescriptor('proto3');
    return {
        format: 'Protocol Buffer 3 EnumDescriptorProto',
        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),
        fileDescriptorProtos: fileDescriptors,
    };
}

function createDefinition(obj, name, options, fileDescriptors) {
    if (obj instanceof Protobuf.Service) {
        return createServiceDefinition(obj, name, options, fileDescriptors);
    } else if (obj instanceof Protobuf.Type) {
        return createMessageDefinition(obj, fileDescriptors);
    } else if (obj instanceof Protobuf.Enum) {
        return createEnumDefinition(obj, fileDescriptors);
    } else {
        throw new Error('Type mismatch in reflection object handling');
    }
}

function createPackageDefinition(root, options) {
    const def = {};
    root.resolveAll();
    const descriptorList = root.toDescriptor('proto3').file;
    const bufferList = descriptorList.map(value => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));
    getAllHandledReflectionObjects(root, '').forEach(([name, obj]) =>
        def[name] = createDefinition(obj, name, options, bufferList)
    );
    return def;
}

function createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {
    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);
    root.resolveAll();
    return createPackageDefinition(root, options);
}

function load(filename, options) {
    return loadProtosWithOptions(filename, options).then(loadedRoot =>
        createPackageDefinition(loadedRoot, options)
    );
}
exports.load = load;

function loadSync(filename, options) {
    const loadedRoot = loadProtosWithOptionsSync(filename, options);
    return createPackageDefinition(loadedRoot, options);
}
exports.loadSync = loadSync;

function fromJSON(json, options = {}) {
    const loadedRoot = Protobuf.Root.fromJSON(json);
    loadedRoot.resolveAll();
    return createPackageDefinition(loadedRoot, options);
}
exports.fromJSON = fromJSON;

function loadFileDescriptorSetFromBuffer(descriptorSet, options) {
    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);
    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);
}
exports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;

function loadFileDescriptorSetFromObject(descriptorSet, options) {
    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);
    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);
}
exports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;

addCommonProtos();
```