The provided Node.js code is a polyfill for web streams, specifically targeting environments that do not natively support the Streams API. This polyfill offers equivalent implementations for readable, writable, and transform streams, complete with controllers, readers, and strategies, following the streams specification from WHATWG. 

Here's a breakdown of the functionalities implemented within the code:

1. **Stream Constructors:**
    - `ReadableStream` - Represents a source of data from which you can read.
    - `WritableStream` - Represents a destination to which you can write.
    - `TransformStream` - A combination of a writable stream and a readable stream, where data is transformed from the writable to the readable stream.

2. **Controllers and Readers:**
    - `ReadableStreamDefaultController`, `ReadableByteStreamController`, and `WritableStreamDefaultController` allow direct control over the stream operations.
    - `ReadableStreamDefaultReader` and `ReadableStreamBYOBReader` provide mechanisms to read from streams.

3. **Queuing Strategies:**
    - `ByteLengthQueuingStrategy` and `CountQueuingStrategy` specify how internal queues are controlled.

4. **Utilities:**
    - Several utility functions facilitate various stream operations like error handling, setting backpressure, and enqueuing/chunk handling.

5. **Polyfill Registration:** Finally, the polyfill registers the streams classes within the global scope if not already provided, allowing use across different environments.

Here is a concise rewrite, organizing the relevant core functional elements concisely in the code block.

```javascript
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.WebStreamsPolyfill = {}));
}(this, (function (exports) { 'use strict';

    var SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol : function (description) { return "Symbol(" + description + ")"; };
    var globals = typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : undefined;

    function newPromise(executor) { return new Promise(executor); }
    function promiseResolvedWith(value) { return Promise.resolve(value); }
    function promiseRejectedWith(reason) { return Promise.reject(reason); }
    function noop() {}

    class SimpleQueue {
        constructor() {
            this._queue = [];
            this._queueTotalSize = 0;
        }
        get length() { return this._queue.length; }
        shift() { return this._queue.shift(); }
        push(element) { this._queue.push(element); }
        peek() { return this._queue[0]; }
        forEach(callback) { this._queue.forEach(callback); }
    }

    class ReadableStream {
        constructor(source) {
            // Initialize stream and set up controller
        }
        getReader() { return new ReadableStreamDefaultReader(this); }
        cancel(reason) { /* Handle stream cancellation */ }
        pipeTo(destination, options) { /* Pipe stream to destination */ }
    }

    class ReadableStreamDefaultReader {
        constructor(stream) {
            // Initialize reader for the provided stream
        }
        read() { /* Read from the stream */ }
        releaseLock() { /* Release the lock on the stream */ }
    }

    class WritableStream {
        constructor(sink) {
            // Initialize stream and set up controller
        }
        getWriter() { return new WritableStreamDefaultWriter(this); }
        abort(reason) { /* Abort the stream */ }
    }

    class WritableStreamDefaultWriter {
        constructor(stream) {
            // Initialize writer for the provided stream
        }
        write(chunk) { /* Write to the stream */ }
        close() { /* Close the stream */ }
        releaseLock() { /* Release the lock on the stream */ }
    }

    class TransformStream {
        constructor(transformer) {
            // Initialize transform stream
        }
    }

    exports.ReadableStream = ReadableStream;
    exports.WritableStream = WritableStream;
    exports.TransformStream = TransformStream;

    if (typeof globals !== 'undefined') {
        Object.defineProperty(globals, 'ReadableStream', { value: ReadableStream, writable: true, configurable: true });
        Object.defineProperty(globals, 'WritableStream', { value: WritableStream, writable: true, configurable: true });
        Object.defineProperty(globals, 'TransformStream', { value: TransformStream, writable: true, configurable: true });
    }

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=polyfill.js.map
```