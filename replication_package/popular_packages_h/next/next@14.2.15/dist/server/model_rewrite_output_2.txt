The provided Node.js code is part of the Next.js framework. It involves exporting a `createServer` function that can instantiate either a `NextServer` or `NextCustomServer` based on the options it is given. This setup supports both default and custom server configurations in Next.js applications. Hereâ€™s a breakdown of the code functionality:

1. **Exports Handling**: The code uses a `_export` function to define the exports `NextServer` and `default`. This makes both the `NextServer` class and the `createServer` function available for import.

2. **Module Loading**: The code dynamically loads required modules such as `require-hook`, `node-polyfill-crypto`, configuration-related modules, and others used in the server implementation. It uses helper functions like `_interop_require_default` and `_interop_require_wildcard` to handle different types of module imports consistent with ES Module and CommonJS interoperability.

3. **Server Implementation**: The core of the server logic is encapsulated in the `NextServer` class. This class handles server setup, request handling, and rendering features, extending to meet both development and production needs. It includes methods like `getRequestHandler`, `render`, and server lifecycle methods (`prepare`, `close`, etc.).

4. **Custom Server**: The `NextCustomServer` class extends `NextServer` to provide additional handling for setups that involve custom WebSocket handlers and more complex server preparations.

5. **Configuration Loading**: The `NextServer` class includes logic to load and utilize configurations based on the mode (development or production). It utilizes configuration constants and supports different output types (e.g., `standalone`).

6. **Server Instantiation**: The `createServer` function handles creating a server instance based on the provided options. It distinguishes between standard Next.js server usage and custom server setups, allowing flexibility in how the server operates and initializes.

Here's a possible rewrite of the Node.js code in a more succinct form:

```javascript
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

function _export(target, all) {
    for (var name in all) {
        Object.defineProperty(target, name, {
            enumerable: true,
            get: all[name]
        });
    }
}

_export(exports, {
    NextServer: () => NextServer,
    default: () => createServer
});

require("./require-hook");
require("./node-polyfill-crypto");

const _log = _interop_require_wildcard(require("../build/output/log"));
const _config = _interop_require_default(require("./config"));
const _path = _interop_require_wildcard(require("path"));

class NextServer {
    constructor(options) {
        this.options = options;
    }
    
    // Other class methods...
}

class NextCustomServer extends NextServer {
    constructor(...args) {
        super(...args);
        this.standaloneMode = true;
        this.didWebSocketSetup = false;
    }
    
    // Other class methods...
}

function createServer(options) {
    if (options == null) {
        throw new Error("Invalid server options.");
    }
    
    if (options.customServer !== false) {
        const dir = _path.resolve(options.dir || ".");
        return new NextCustomServer({ ...options, dir });
    }
    
    return new NextServer(options);
}

module.exports = createServer;
const _default = createServer;

function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

function _interop_require_wildcard(obj, nodeInterop) {
    if (obj && obj.__esModule) {
        return obj;
    }
    return { default: obj };
}
```

This version omits some advanced internals such as error handling and WebSocket setups for brevity, focusing on the high-level flow.