The given Node.js code is a module that exports functionalities for scanning, parsing, and modifying JSON documents. It encapsulates its definitions using an Immediately Invoked Function Expression (IIFE) pattern compatible with both Node.js and AMD environments. Here's an explanation of the code's main components:

1. **Module Pattern**: The code is wrapped in a function that checks if `module` and `exports` are defined (for Node.js) or if `define` is defined and supports AMD (for Asynchronous Module Definition environments). Depending on the environment, it either exports the function directly via `module.exports` or via `define`.

2. **Imports**: The module imports several utility functions and classes from local files (`./impl/format`, `./impl/edit`, `./impl/scanner`, and `./impl/parser`), which presumably handle specific JSON processing tasks.

3. **Exports**:
   - **Scanner Functions**: `createScanner` is exported to create a scanner for JSON parsing.
   - **Enumerations**: `ScanError` and `SyntaxKind` enumerations specify different error types and syntax kinds encountered during JSON processing.
   - **Parser Functions**: Multiple functions are exported for parsing JSON (`parse`, `parseTree`), finding nodes (`findNodeAtLocation`, `findNodeAtOffset`), and getting node paths and values (`getNodePath`, `getNodeValue`).
   - **Utility Functions**: Functions for JSON document modification (`modify`), formatting (`format`), applying edits (`applyEdits`), and stripping comments (`stripComments`) are provided.
   - **Print Functions**: `printParseErrorCode` is a utility function for converting parse error codes to strings.

4. **Functionality**:
   - `format`, `modify`, and `applyEdits` functions handle JSON document modifications and formatting, providing ways to transform the JSON text according to specified options.
   - `ScanError` and `ParseErrorCode` enums define error codes for identifying parsing and scanning errors, with `printParseErrorCode` providing a way to get a string description of these errors.

Here's a rewritten version of the given Node.js code adhering to the explanation:

```javascript
(function(factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    } else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./impl/format", "./impl/edit", "./impl/scanner", "./impl/parser"], factory);
    }
})(function(require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });

    const formatter = require("./impl/format");
    const edit = require("./impl/edit");
    const scanner = require("./impl/scanner");
    const parser = require("./impl/parser");

    exports.createScanner = scanner.createScanner;

    var ScanError;
    (function(ScanError) {
        ScanError[ScanError["None"] = 0] = "None";
        ScanError[ScanError["UnexpectedEndOfComment"] = 1] = "UnexpectedEndOfComment";
        ScanError[ScanError["UnexpectedEndOfString"] = 2] = "UnexpectedEndOfString";
        ScanError[ScanError["UnexpectedEndOfNumber"] = 3] = "UnexpectedEndOfNumber";
        ScanError[ScanError["InvalidUnicode"] = 4] = "InvalidUnicode";
        ScanError[ScanError["InvalidEscapeCharacter"] = 5] = "InvalidEscapeCharacter";
        ScanError[ScanError["InvalidCharacter"] = 6] = "InvalidCharacter";
    })(ScanError || (exports.ScanError = ScanError = {}));

    var SyntaxKind;
    (function(SyntaxKind) {
        SyntaxKind[SyntaxKind["OpenBraceToken"] = 1] = "OpenBraceToken";
        SyntaxKind[SyntaxKind["CloseBraceToken"] = 2] = "CloseBraceToken";
        SyntaxKind[SyntaxKind["OpenBracketToken"] = 3] = "OpenBracketToken";
        SyntaxKind[SyntaxKind["CloseBracketToken"] = 4] = "CloseBracketToken";
        SyntaxKind[SyntaxKind["CommaToken"] = 5] = "CommaToken";
        SyntaxKind[SyntaxKind["ColonToken"] = 6] = "ColonToken";
        SyntaxKind[SyntaxKind["NullKeyword"] = 7] = "NullKeyword";
        SyntaxKind[SyntaxKind["TrueKeyword"] = 8] = "TrueKeyword";
        SyntaxKind[SyntaxKind["FalseKeyword"] = 9] = "FalseKeyword";
        SyntaxKind[SyntaxKind["StringLiteral"] = 10] = "StringLiteral";
        SyntaxKind[SyntaxKind["NumericLiteral"] = 11] = "NumericLiteral";
        SyntaxKind[SyntaxKind["LineCommentTrivia"] = 12] = "LineCommentTrivia";
        SyntaxKind[SyntaxKind["BlockCommentTrivia"] = 13] = "BlockCommentTrivia";
        SyntaxKind[SyntaxKind["LineBreakTrivia"] = 14] = "LineBreakTrivia";
        SyntaxKind[SyntaxKind["Trivia"] = 15] = "Trivia";
        SyntaxKind[SyntaxKind["Unknown"] = 16] = "Unknown";
        SyntaxKind[SyntaxKind["EOF"] = 17] = "EOF";
    })(SyntaxKind || (exports.SyntaxKind = SyntaxKind = {}));

    exports.getLocation = parser.getLocation;
    exports.parse = parser.parse;
    exports.parseTree = parser.parseTree;
    exports.findNodeAtLocation = parser.findNodeAtLocation;
    exports.findNodeAtOffset = parser.findNodeAtOffset;
    exports.getNodePath = parser.getNodePath;
    exports.getNodeValue = parser.getNodeValue;
    exports.visit = parser.visit;
    exports.stripComments = parser.stripComments;

    var ParseErrorCode;
    (function(ParseErrorCode) {
        ParseErrorCode[ParseErrorCode["InvalidSymbol"] = 1] = "InvalidSymbol";
        ParseErrorCode[ParseErrorCode["InvalidNumberFormat"] = 2] = "InvalidNumberFormat";
        ParseErrorCode[ParseErrorCode["PropertyNameExpected"] = 3] = "PropertyNameExpected";
        ParseErrorCode[ParseErrorCode["ValueExpected"] = 4] = "ValueExpected";
        ParseErrorCode[ParseErrorCode["ColonExpected"] = 5] = "ColonExpected";
        ParseErrorCode[ParseErrorCode["CommaExpected"] = 6] = "CommaExpected";
        ParseErrorCode[ParseErrorCode["CloseBraceExpected"] = 7] = "CloseBraceExpected";
        ParseErrorCode[ParseErrorCode["CloseBracketExpected"] = 8] = "CloseBracketExpected";
        ParseErrorCode[ParseErrorCode["EndOfFileExpected"] = 9] = "EndOfFileExpected";
        ParseErrorCode[ParseErrorCode["InvalidCommentToken"] = 10] = "InvalidCommentToken";
        ParseErrorCode[ParseErrorCode["UnexpectedEndOfComment"] = 11] = "UnexpectedEndOfComment";
        ParseErrorCode[ParseErrorCode["UnexpectedEndOfString"] = 12] = "UnexpectedEndOfString";
        ParseErrorCode[ParseErrorCode["UnexpectedEndOfNumber"] = 13] = "UnexpectedEndOfNumber";
        ParseErrorCode[ParseErrorCode["InvalidUnicode"] = 14] = "InvalidUnicode";
        ParseErrorCode[ParseErrorCode["InvalidEscapeCharacter"] = 15] = "InvalidEscapeCharacter";
        ParseErrorCode[ParseErrorCode["InvalidCharacter"] = 16] = "InvalidCharacter";
    })(ParseErrorCode || (exports.ParseErrorCode = ParseErrorCode = {}));

    function printParseErrorCode(code) {
        switch (code) {
            case 1: return 'InvalidSymbol';
            case 2: return 'InvalidNumberFormat';
            case 3: return 'PropertyNameExpected';
            case 4: return 'ValueExpected';
            case 5: return 'ColonExpected';
            case 6: return 'CommaExpected';
            case 7: return 'CloseBraceExpected';
            case 8: return 'CloseBracketExpected';
            case 9: return 'EndOfFileExpected';
            case 10: return 'InvalidCommentToken';
            case 11: return 'UnexpectedEndOfComment';
            case 12: return 'UnexpectedEndOfString';
            case 13: return 'UnexpectedEndOfNumber';
            case 14: return 'InvalidUnicode';
            case 15: return 'InvalidEscapeCharacter';
            case 16: return 'InvalidCharacter';
            default: return '<unknown ParseErrorCode>';
        }
    }
    exports.printParseErrorCode = printParseErrorCode;

    function format(documentText, range, options) {
        return formatter.format(documentText, range, options);
    }
    exports.format = format;

    function modify(text, path, value, options) {
        return edit.setProperty(text, path, value, options);
    }
    exports.modify = modify;

    function applyEdits(text, edits) {
        let sortedEdits = edits.slice(0).sort((a, b) => {
            const diff = a.offset - b.offset;
            if (diff === 0) {
                return a.length - b.length;
            }
            return diff;
        });
        let lastModifiedOffset = text.length;
        for (let i = sortedEdits.length - 1; i >= 0; i--) {
            let e = sortedEdits[i];
            if (e.offset + e.length <= lastModifiedOffset) {
                text = edit.applyEdit(text, e);
            } else {
                throw new Error('Overlapping edit');
            }
            lastModifiedOffset = e.offset;
        }
        return text;
    }
    exports.applyEdits = applyEdits;
});
```