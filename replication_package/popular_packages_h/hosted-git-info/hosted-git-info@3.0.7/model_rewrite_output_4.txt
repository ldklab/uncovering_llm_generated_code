The provided code is a Node.js module for handling Git URLs, allowing conversion and parsing into a unified format. Hereâ€™s a breakdown of its functionality:

1. **Dependencies and Initialization:**
   - Requires `url` for URL parsing.
   - Requires `git-host-info.js` and `git-host.js` which presumably provide info and a class for different Git hosts.
   - Uses a Least Recently Used (LRU) cache to store results, limiting it to a maximum of 1000 entries.

2. **Protocol Mapping:**
   - Maps URL protocols to representations via `protocolToRepresentationMap`.

3. **Authorization Protocols:**
   - Defines `authProtocols` to indicate which protocols can handle authentication.

4. **Main Function `fromUrl`:**
   - Converts a given Git URL string into a structured format.
   - Caches the processed result to avoid redundant processing.
   - If the URL matches known patterns (`isGitHubShorthand`, `parseGitUrl`), it's parsed and processed.

5. **Helper Functions:**
   - **`protocolToRepresentation`**: Maps protocols to a string representation, with a default to return the protocol minus the trailing `:`.
   - **`isGitHubShorthand`**: Checks if a string is in a GitHub shorthand format.
   - **`fixupUnqualifiedGist`**: Adds a path component to Gist URLs if missing.
   - **`parseGitUrl`**: Parses Git URLs, accommodating various Git URL forms including SCP-like syntax into a common URL structure.

6. **Error Handling:**
   - Handles `URIError` during URL parsing and decoding operations.

Below is the complete code rewritten to reflect the same functionality with some modern JavaScript features:

```javascript
'use strict';

const url = require('url');
const gitHosts = require('./git-host-info.js');
const GitHost = require('./git-host.js');
const LRU = require('lru-cache');
const cache = new LRU({ max: 1000 });

const protocolToRepresentationMap = {
  'git+ssh:': 'sshurl',
  'git+https:': 'https',
  'ssh:': 'sshurl',
  'git:': 'git'
};

function protocolToRepresentation(protocol) {
  return protocolToRepresentationMap[protocol] || protocol.slice(0, -1);
}

const authProtocols = new Set(['git:', 'https:', 'git+https:', 'http:', 'git+http:']);

module.exports = {
  fromUrl: (giturl, opts) => {
    if (typeof giturl !== 'string') return;
    const key = giturl + JSON.stringify(opts || {});

    if (!cache.has(key)) {
      cache.set(key, fromUrl(giturl, opts));
    }

    return cache.get(key);
  }
};

function fromUrl(giturl, opts) {
  if (!giturl) return;
  const normalizedUrl = fixupUnqualifiedGist(
    isGitHubShorthand(giturl) ? 'github:' + giturl : giturl
  );
  const parsed = parseGitUrl(normalizedUrl);
  const shortcutRegex = new RegExp('^([^:]+):(?:(?:[^@:]+(?:[^@]+)?@)?([^/]*))[/](.+?)(?:[.]git)?($|#)');
  const shortcutMatch = normalizedUrl.match(shortcutRegex);

  const matches = Object.keys(gitHosts).map(gitHostName => {
    try {
      const gitHostInfo = gitHosts[gitHostName];
      const auth = parsed.auth && authProtocols.has(parsed.protocol) ? parsed.auth : null;
      const committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null;
      let user = null;
      let project = null;
      let defaultRepresentation = null;

      if (shortcutMatch && shortcutMatch[1] === gitHostName) {
        user = shortcutMatch[2] ? decodeURIComponent(shortcutMatch[2]) : null;
        project = decodeURIComponent(shortcutMatch[3]);
        defaultRepresentation = 'shortcut';
      } else {
        if (parsed.host && ![gitHostInfo.domain, `www.${gitHostInfo.domain}`].includes(parsed.host)) return;
        if (!gitHostInfo.protocols_re.test(parsed.protocol)) return;
        if (!parsed.path) return;

        const pathmatch = gitHostInfo.pathmatch;
        const matched = parsed.path.match(pathmatch);
        if (!matched) return;

        if (matched[1]) {
          user = decodeURIComponent(matched[1].replace(/^:/, ''));
        }
        project = decodeURIComponent(matched[2]);
        defaultRepresentation = protocolToRepresentation(parsed.protocol);
      }
      return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts);
    } catch (ex) {
      if (!(ex instanceof URIError)) throw ex;
    }
  }).filter(gitHostInfo => gitHostInfo);

  return matches.length === 1 ? matches[0] : null;
}

function isGitHubShorthand(arg) {
  return /^[^:@%/\s.-][^:@%/\s]*[/][^:@\s/%]+(?:#.*)?$/.test(arg);
}

function fixupUnqualifiedGist(giturl) {
  const parsed = url.parse(giturl);
  return (parsed.protocol === 'gist:' && parsed.host && !parsed.path) ? `${parsed.protocol}/${parsed.host}` : giturl;
}

function parseGitUrl(giturl) {
  const matched = giturl.match(/^([^@]+)@([^:/]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/);
  if (!matched) {
    const legacy = url.parse(giturl);
    if (legacy.auth) {
      const authmatch = giturl.match(/[^@]+@[^:/]+/);
      if (authmatch) {
        const whatwg = new url.URL(authmatch[0]);
        legacy.auth = whatwg.username || '';
        if (whatwg.password) legacy.auth += ':' + whatwg.password;
      }
    }
    return legacy;
  }
  return {
    protocol: 'git+ssh:',
    slashes: true,
    auth: matched[1],
    host: matched[2],
    hostname: matched[2],
    hash: matched[4],
    pathname: '/' + matched[3],
    path: '/' + matched[3],
    href: `git+ssh://${matched[1]}@${matched[2]}/${matched[3]}${matched[4] || ''}`
  };
}
```