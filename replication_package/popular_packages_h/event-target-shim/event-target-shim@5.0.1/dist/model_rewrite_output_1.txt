The provided Node.js code defines an event handling mechanism similar to the native JavaScript `EventTarget`, but with additional flexibility and features. Here's a breakdown of the main functionalities:

1. **Event Wrapping and Management**: The code includes an `Event` class that wraps native `Event` objects to manage custom event behavior. It stores private data in a `WeakMap` to handle event states like `canceled`, `stopped`, and `immediateStopped`.

2. **Custom Event Attributes**: It allows defining custom event attributes (like `onclick`) on custom event targets.

3. **Event Phases and Listeners**: Supports the concept of event phases (`NONE`, `CAPTURING_PHASE`, `AT_TARGET`, `BUBBLING_PHASE`) and provides methods for adding and removing event listeners with options for capturing, passive, and once.

4. **Custom EventTarget**: Implements `EventTarget` as a constructor and allows creating custom event targets with specific event attributes. It allows instances to register, remove, and dispatch events, mimicking the native `EventTarget` behavior.

5. **Error Handling and Logging**: Includes error handling and logging for disallowed operations, such as preventing default actions in passive listeners.

Here's a possible rewritten version of the code, following the above explanation:

```javascript
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const privateData = new WeakMap();
const wrappers = new WeakMap();

function pd(event) {
    const data = privateData.get(event);
    console.assert(data != null, "'this' is expected an Event object, but got", event);
    return data;
}

function setCancelFlag(data) {
    if (data.passiveListener) {
        console.error("Unable to preventDefault inside passive event listener.", data.passiveListener);
        return;
    }
    if (data.event.cancelable) {
        data.canceled = true;
        data.event.preventDefault?.();
    }
}

function Event(eventTarget, event) {
    privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now(),
    });

    Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });

    Object.keys(event).forEach(key => {
        if (!(key in this)) {
            Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
    });
}

Event.prototype = {
    get type() { return pd(this).event.type; },
    get target() { return pd(this).eventTarget; },
    get currentTarget() { return pd(this).currentTarget; },
    composedPath() { return pd(this).currentTarget ? [pd(this).currentTarget] : []; },
    get NONE() { return 0; },
    get CAPTURING_PHASE() { return 1; },
    get AT_TARGET() { return 2; },
    get BUBBLING_PHASE() { return 3; },
    get eventPhase() { return pd(this).eventPhase; },
    stopPropagation() {
        const data = pd(this);
        data.stopped = true;
        data.event.stopPropagation?.();
    },
    stopImmediatePropagation() {
        const data = pd(this);
        data.stopped = data.immediateStopped = true;
        data.event.stopImmediatePropagation?.();
    },
    get bubbles() { return Boolean(pd(this).event.bubbles); },
    get cancelable() { return Boolean(pd(this).event.cancelable); },
    preventDefault() { setCancelFlag(pd(this)); },
    get defaultPrevented() { return pd(this).canceled; },
    get composed() { return Boolean(pd(this).event.composed); },
    get timeStamp() { return pd(this).timeStamp; },
    get srcElement() { return pd(this).eventTarget; },
    get cancelBubble() { return pd(this).stopped; },
    set cancelBubble(value) {
        if (value) {
            const data = pd(this);
            data.stopped = true;
            if (typeof data.event.cancelBubble === "boolean") {
                data.event.cancelBubble = true;
            }
        }
    },
    get returnValue() { return !pd(this).canceled; },
    set returnValue(value) { if (!value) setCancelFlag(pd(this)); },
    initEvent() {}
};

Object.defineProperty(Event.prototype, "constructor", {
    value: Event,
    configurable: true,
    writable: true,
});

if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
    Object.setPrototypeOf(Event.prototype, window.Event.prototype);
    wrappers.set(window.Event.prototype, Event);
}

function defineRedirectDescriptor(key) {
    return {
        get() { return pd(this).event[key]; },
        set(value) { pd(this).event[key] = value; },
        configurable: true,
        enumerable: true,
    };
}

function defineCallDescriptor(key) {
    return {
        value() { return pd(this).event[key].apply(event, arguments); },
        configurable: true,
        enumerable: true,
    };
}

function defineWrapper(BaseEvent, proto) {
    const keys = Object.keys(proto);
    if (keys.length === 0) return BaseEvent;

    function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
    }

    CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true },
    });

    keys.forEach(key => {
        if (!(key in BaseEvent.prototype)) {
            const descriptor = Object.getOwnPropertyDescriptor(proto, key);
            const isFunc = typeof descriptor.value === "function";
            Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));
        }
    });

    return CustomEvent;
}

function getWrapper(proto) {
    if (proto == null || proto === Object.prototype) return Event;

    let wrapper = wrappers.get(proto);
    if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
    }
    return wrapper;
}

function wrapEvent(eventTarget, event) {
    const Wrapper = getWrapper(Object.getPrototypeOf(event));
    return new Wrapper(eventTarget, event);
}

function isStopped(event) {
    return pd(event).immediateStopped;
}

function setEventPhase(event, eventPhase) {
    pd(event).eventPhase = eventPhase;
}

function setCurrentTarget(event, currentTarget) {
    pd(event).currentTarget = currentTarget;
}

function setPassiveListener(event, passiveListener) {
    pd(event).passiveListener = passiveListener;
}

const listenersMap = new WeakMap();
const CAPTURE = 1;
const BUBBLE = 2;
const ATTRIBUTE = 3;

function isObject(x) {
    return x !== null && typeof x === "object";
}

function getListeners(eventTarget) {
    const listeners = listenersMap.get(eventTarget);
    if (listeners == null) throw new TypeError("'this' is expected an EventTarget object, but got another value.");
    return listeners;
}

function defineEventAttributeDescriptor(eventName) {
    return {
        get() {
            const listeners = getListeners(this);
            let node = listeners.get(eventName);
            while (node) {
                if (node.listenerType === ATTRIBUTE) return node.listener;
                node = node.next;
            }
            return null;
        },
        set(listener) {
            if (typeof listener !== "function" && !isObject(listener)) listener = null;
            const listeners = getListeners(this);

            let prev = null;
            let node = listeners.get(eventName);
            while (node) {
                if (node.listenerType === ATTRIBUTE) {
                    if (prev) prev.next = node.next;
                    else if (node.next) listeners.set(eventName, node.next);
                    else listeners.delete(eventName);
                } else {
                    prev = node;
                }
                node = node.next;
            }

            if (listener !== null) {
                const newNode = { listener, listenerType: ATTRIBUTE, passive: false, once: false, next: null };
                prev ? prev.next = newNode : listeners.set(eventName, newNode);
            }
        },
        configurable: true,
        enumerable: true,
    };
}

function defineEventAttribute(eventTargetPrototype, eventName) {
    Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
}

function defineCustomEventTarget(eventNames) {
    function CustomEventTarget() {
        EventTarget.call(this);
    }

    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: { value: CustomEventTarget, configurable: true, writable: true },
    });

    eventNames.forEach(eventName => {
        defineEventAttribute(CustomEventTarget.prototype, eventName);
    });

    return CustomEventTarget;
}

function EventTarget() {
    if (this instanceof EventTarget) {
        listenersMap.set(this, new Map());
        return;
    }
    if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0]);
    }
    if (arguments.length > 0) {
        return defineCustomEventTarget(Array.from(arguments));
    }
    throw new TypeError("Cannot call a class as a function");
}

EventTarget.prototype = {
    addEventListener(eventName, listener, options) {
        if (!listener) return;
        if (typeof listener !== "function" && !isObject(listener)) {
            throw new TypeError("'listener' should be a function or an object.");
        }

        const listeners = getListeners(this);
        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = { listener, listenerType, passive: options?.passive || false, once: options?.once || false, next: null };

        let node = listeners.get(eventName);
        if (!node) {
            listeners.set(eventName, newNode);
            return;
        }

        let prev = null;
        while (node) {
            if (node.listener === listener && node.listenerType === listenerType) return;
            prev = node;
            node = node.next;
        }

        prev.next = newNode;
    },

    removeEventListener(eventName, listener, options) {
        if (!listener) return;

        const listeners = getListeners(this);
        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;

        let prev = null;
        let node = listeners.get(eventName);
        while (node) {
            if (node.listener === listener && node.listenerType === listenerType) {
                if (prev) prev.next = node.next;
                else if (node.next) listeners.set(eventName, node.next);
                else listeners.delete(eventName);
                return;
            }
            prev = node;
            node = node.next;
        }
    },

    dispatchEvent(event) {
        if (!event || typeof event.type !== "string") {
            throw new TypeError('"event.type" should be a string.');
        }

        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (!node) return true;

        const wrappedEvent = wrapEvent(this, event);

        let prev = null;
        while (node) {
            if (node.once) {
                if (prev) prev.next = node.next;
                else if (node.next) listeners.set(eventName, node.next);
                else listeners.delete(eventName);
            } else {
                prev = node;
            }

            setPassiveListener(wrappedEvent, node.passive ? node.listener : null);
            try {
                if (typeof node.listener === "function") {
                    node.listener.call(this, wrappedEvent);
                } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
                    node.listener.handleEvent(wrappedEvent);
                }
            } catch (err) {
                console.error(err);
            }

            if (isStopped(wrappedEvent)) break;

            node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);

        return !wrappedEvent.defaultPrevented;
    }
};

Object.defineProperty(EventTarget.prototype, "constructor", {
    value: EventTarget,
    configurable: true,
    writable: true,
});

if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
}

exports.defineEventAttribute = defineEventAttribute;
exports.EventTarget = EventTarget;
exports.default = EventTarget;

module.exports = EventTarget;
module.exports.EventTarget = module.exports["default"] = EventTarget;
module.exports.defineEventAttribute = defineEventAttribute;
```