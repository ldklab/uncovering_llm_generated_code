The supplied Node.js code is the main entry point for the `lint-staged` functionality. Its core function, `lintStaged`, performs the following tasks:

1. **Configuration Loading**: Uses `cosmiconfig` to load lint-staged configuration from various possible file types (JSON, YAML, JS, etc.). It prefers user-provided configs but defaults to searching local files if none is specified. The function can resolve a configuration path and handle potential missing configurations gracefully.

2. **Configuration Validation**: Validates and formats the configuration using `validateConfig` and `formatConfig` functions. Logs the configuration for debugging if the debug mode is enabled.

3. **Environment Setup**: Ensures the environment is set up properly by removing any influence of Git environment variables that might impact path handling (`GIT_LITERAL_PATHSPECS`).

4. **Execution of Tasks**: Calls `runAll` to execute the tasks defined in the lint-staged configuration. It uses the provided options like concurrency, maximum argument length, etc. If any errors occur during the task execution, it handles them intelligently by checking specific error types like `ApplyEmptyCommitError`, `GitError`, and `GetBackupStashError` and provides appropriate user feedback.

5. **Logging and Error Handling**: Utilizes a logger to output the results and errors of tasks. Catches and handles any errors pertaining to parsing failures in the configuration files.

Here is a rewritten version of the code:

```javascript
'use strict';

const dedent = require('dedent');
const { cosmiconfig } = require('cosmiconfig');
const debugLog = require('debug')('lint-staged');
const stringifyObject = require('stringify-object');
const { PREVENTED_EMPTY_COMMIT, GIT_ERROR, RESTORE_STASH_EXAMPLE } = require('./messages');
const printTaskOutput = require('./printTaskOutput');
const runAll = require('./runAll');
const { ApplyEmptyCommitError, GetBackupStashError, GitError } = require('./symbols');
const formatConfig = require('./formatConfig');
const validateConfig = require('./validateConfig');

const errConfigNotFound = new Error('Config could not be found');

function resolveConfig(configPath) {
  try {
    return require.resolve(configPath);
  } catch {
    return configPath;
  }
}

function loadConfig(configPath) {
  const explorer = cosmiconfig('lint-staged', {
    searchPlaces: [
      'package.json',
      '.lintstagedrc',
      '.lintstagedrc.json',
      '.lintstagedrc.yaml',
      '.lintstagedrc.yml',
      '.lintstagedrc.js',
      '.lintstagedrc.cjs',
      'lint-staged.config.js',
      'lint-staged.config.cjs',
    ],
  });

  return configPath ? explorer.load(resolveConfig(configPath)) : explorer.search();
}

module.exports = async function lintStaged({
  allowEmpty = false,
  concurrent = true,
  config: configObject,
  configPath,
  cwd = process.cwd(),
  debug = false,
  maxArgLength,
  quiet = false,
  relative = false,
  shell = false,
  stash = true,
  verbose = false,
} = {}, logger = console) {
  try {
    debugLog('Loading config using `cosmiconfig`');
    const resolved = configObject ?
      { config: configObject, filepath: '(input)' } : await loadConfig(configPath);
    if (!resolved) throw errConfigNotFound;

    debugLog('Successfully loaded config from `%s`:\n%O', resolved.filepath, resolved.config);
    const formattedConfig = formatConfig(resolved.config);
    const config = validateConfig(formattedConfig);
    
    if (debug) {
      logger.log('Running lint-staged with the following config:');
      logger.log(stringifyObject(config, { indent: '  ' }));
    } else {
      debugLog('lint-staged config:\n%O', config);
    }

    debugLog('Unset GIT_LITERAL_PATHSPECS (was `%s`)', process.env.GIT_LITERAL_PATHSPECS);
    delete process.env.GIT_LITERAL_PATHSPECS;

    try {
      const ctx = await runAll({
        allowEmpty,
        concurrent,
        config,
        cwd,
        debug,
        maxArgLength,
        quiet,
        relative,
        shell,
        stash,
        verbose,
      }, logger);
      
      debugLog('Tasks were executed successfully!');
      printTaskOutput(ctx, logger);
      return true;
    
    } catch (runAllError) {
      if (runAllError && runAllError.ctx && runAllError.ctx.errors) {
        const { ctx } = runAllError;
        if (ctx.errors.has(ApplyEmptyCommitError)) {
          logger.warn(PREVENTED_EMPTY_COMMIT);
        } else if (ctx.errors.has(GitError) && !ctx.errors.has(GetBackupStashError)) {
          logger.error(GIT_ERROR);
          if (ctx.shouldBackup) {
            logger.error(RESTORE_STASH_EXAMPLE);
          }
        }

        printTaskOutput(ctx, logger);
        return false;
      }
      throw runAllError;
    }
  } catch (lintStagedError) {
    const errorMessage = lintStagedError === errConfigNotFound ?
      `${lintStagedError.message}.` :
      dedent`Could not parse lint-staged config.\n${lintStagedError}`;
    
    logger.error(errorMessage);
    logger.error(); // empty line
    logger.error(dedent`
      Please make sure you have created it correctly.
      See https://github.com/okonet/lint-staged#configuration.
    `);

    throw lintStagedError;
  }
};
```