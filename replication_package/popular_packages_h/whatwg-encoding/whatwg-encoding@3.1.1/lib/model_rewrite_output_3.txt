The Node.js code provides a module for encoding and decoding text using various character encodings. It utilizes the `iconv-lite` library for encoding conversion and offers several exported functions to handle text encoding-related tasks. Let's break down the functionality:

1. **Modules and Data**:
   - The `iconv-lite` package is required for encoding and decoding.
   - `supported-names.json` contains a list of supported encoding names.
   - `labels-to-names.json` maps encoding labels to their respective names.

2. **Data Structures**:
   - `supportedNamesSet`: A `Set` object storing encoding names for quick lookup to check if an encoding is supported.

3. **Exported Functions**:
   - `labelToName(label)`: Accepts an encoding label, converts it to lowercase, trims whitespace, and returns the corresponding encoding name from `labelsToNames` or `null` if it doesn't find a mapping.
   
   - `decode(uint8Array, fallbackEncodingName)`: Decodes a `Uint8Array` to a string using a specified or detected encoding. It checks if the encoding is supported and attempts to detect a Byte Order Mark (BOM) for automatic encoding selection. The function handles special cases for the "x-user-defined" encoding, translating bytes into corresponding Unicode code points. It throws a `RangeError` if the encoding isn't supported.

   - `getBOMEncoding(uint8Array)`: Scans the beginning bytes of an array for a BOM, which can indicate UTF-16BE, UTF-16LE, or UTF-8 encoding. It returns the detected encoding or `null` if no BOM is found.

   - `isSupported(name)`: Checks if a given encoding name is supported by looking it up in `supportedNamesSet`.

Below is a possible rewrite of the original Node.js code based on the explanation provided:

```javascript
"use strict";

const iconvLite = require("iconv-lite");
const supportedNames = require("./supported-names.json");
const labelsToNames = require("./labels-to-names.json");

const supportedNamesSet = new Set(supportedNames);

exports.labelToName = function(label) {
  label = String(label).trim().toLowerCase();
  return labelsToNames[label] || null;
};

exports.decode = function(uint8Array, fallbackEncodingName) {
  let encoding = fallbackEncodingName;
  if (!exports.isSupported(encoding)) {
    throw new RangeError(`"${encoding}" is not a supported encoding name`);
  }

  const bomEncoding = exports.getBOMEncoding(uint8Array);
  if (bomEncoding !== null) {
    encoding = bomEncoding;
  }

  if (encoding === "x-user-defined") {
    let result = "";
    uint8Array.forEach(byte => {
      if (byte <= 0x7F) {
        result += String.fromCodePoint(byte);
      } else {
        result += String.fromCodePoint(0xF780 + byte - 0x80);
      }
    });
    return result;
  }

  return iconvLite.decode(uint8Array, encoding);
};

exports.getBOMEncoding = function(uint8Array) {
  if (uint8Array[0] === 0xFE && uint8Array[1] === 0xFF) {
    return "UTF-16BE";
  } else if (uint8Array[0] === 0xFF && uint8Array[1] === 0xFE) {
    return "UTF-16LE";
  } else if (uint8Array[0] === 0xEF && uint8Array[1] === 0xBB && uint8Array[2] === 0xBF) {
    return "UTF-8";
  }
  return null;
};

exports.isSupported = function(name) {
  return supportedNamesSet.has(String(name));
};
```