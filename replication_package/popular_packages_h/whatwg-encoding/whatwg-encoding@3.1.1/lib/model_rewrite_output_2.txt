The Node.js code provides functionality for dealing with text encodings, specifically around converting labels to encoding names, decoding byte arrays into strings using a given encoding, and handling Byte Order Marks (BOM) to determine the correct encoding. Here's an explanation of its components:

1. **Dependencies and Data**:
   - `iconv-lite` is used for character encoding conversions.
   - `supportedNames.json` lists encoding names that are supported.
   - `labels-to-names.json` maps encoding labels to their canonical encoding names.

2. **Function `labelToName`**:
   - Converts an encoding label to its canonical name by normalizing the label and checking against the mappings in `labels-to-names.json`.
   
3. **Function `decode`**:
   - Takes a `Uint8Array` and an optional fallback encoding name, attempting to decode the byte array into a string.
   - Validates if the fallback encoding is supported; throws an error if not.
   - Checks for BOM to potentially adjust to the correct encoding.
   - Handles "x-user-defined" encoding by mapping high-byte values to Unicode private-use area.
   - Defaults to using `iconv-lite` for decoding otherwise.
   
4. **Function `getBOMEncoding`**:
   - Inspects the first few bytes of a `Uint8Array` to identify a BOM, determining if the encoding should be UTF-16BE, UTF-16LE, or UTF-8.
   
5. **Function `isSupported`**:
   - Checks if a given encoding name is in the list of supported names.

Below is the rewritten version of the original code, maintaining its core functionality:

```javascript
"use strict";
const iconvLite = require("iconv-lite");
const supportedNames = require("./supported-names.json");
const labelsToNames = require("./labels-to-names.json");

const supportedNamesSet = new Set(supportedNames);

exports.labelToName = function(label) {
  label = String(label).trim().toLowerCase();
  return labelsToNames[label] || null;
};

exports.decode = function(uint8Array, fallbackEncodingName) {
  let encoding = fallbackEncodingName;
  if (!this.isSupported(encoding)) {
    throw new RangeError(`"${encoding}" is not a supported encoding name`);
  }

  const bomEncoding = this.getBOMEncoding(uint8Array);
  if (bomEncoding !== null) {
    encoding = bomEncoding;
  }

  if (encoding === "x-user-defined") {
    let result = "";
    for (const byte of uint8Array) {
      result += String.fromCodePoint(byte <= 0x7F ? byte : 0xF780 + byte - 0x80);
    }
    return result;
  }

  return iconvLite.decode(uint8Array, encoding);
};

exports.getBOMEncoding = function(uint8Array) {
  if (uint8Array[0] === 0xFE && uint8Array[1] === 0xFF) {
    return "UTF-16BE";
  } else if (uint8Array[0] === 0xFF && uint8Array[1] === 0xFE) {
    return "UTF-16LE";
  } else if (uint8Array[0] === 0xEF && uint8Array[1] === 0xBB && uint8Array[2] === 0xBF) {
    return "UTF-8";
  }
  return null;
};

exports.isSupported = function(name) {
  return supportedNamesSet.has(String(name));
};
```