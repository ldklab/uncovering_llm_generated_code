The provided Node.js code defines a module that handles the parsing of JSON strings with enhanced error handling. It includes custom error reporting using a specialized `JSONParseError` class, which extends the standard `SyntaxError` to provide more detailed information about where and why parsing errors occur. It also handles indentation and newline management for parsed objects, preserving the formatting of JSON strings. Let's break down the code's functionality:

1. **hexify Function**: Converts a character into its hexadecimal representation.
2. **parseError Function**: Parses error messages generated by JSON parsing, extracting information about error position and type. It provides context around the error position, which helps in identifying the exact location and cause of the syntax error in JSON strings.
3. **JSONParseError Class**: Extends `SyntaxError` to include error-related metadata such as position and system error. It is specifically designed to handle JSON parsing errors, creating a more informative error message.
4. **Symbols for Indentation and Newline**: These symbols (`kIndent` and `kNewline`) are used to manage the formatting of parsed JSON objects.
5. **Regex for Formatting**: Regular expressions are used to detect indentation and handle formatting of JSON strings.
6. **parseJson Function**: The main function to parse JSON strings. It strips byte order markers (BOM) and attempts to parse the text. In case of errors, it throws a `JSONParseError`. It preserves the formatting details using symbols and provides fallbacks for cases with empty objects or arrays.
7. **BOM Removal (stripBOM Function)**: Strips BOM characters from the beginning of the string to prevent parsing issues.
8. **Module Export**: The `parseJson` function is exported as the main module export, along with the `JSONParseError` class. `parseJson.noExceptions` is an additional method that attempts to parse JSON without throwing exceptions.

Below is a rewritten version of the provided Node.js code with the same functionality:

```javascript
'use strict';

const hexify = char => {
  const hex = char.charCodeAt(0).toString(16).toUpperCase();
  return '0x' + (hex.length % 2 ? '0' : '') + hex;
};

const parseError = (error, text, context) => {
  if (!text) {
    return {
      message: `${error.message} while parsing empty string`,
      position: 0,
    };
  }

  const badToken = error.message.match(/^Unexpected token (.) .*position\s+(\d+)/i);
  const errorIndex = badToken ? +badToken[2]
    : error.message.match(/^Unexpected end of JSON.*/i) ? text.length - 1
    : null;

  const message = badToken 
    ? error.message.replace(/^Unexpected token ./, `Unexpected token ${JSON.stringify(badToken[1])} (${hexify(badToken[1])})`)
    : error.message;

  if (errorIndex !== null) {
    const start = Math.max(0, errorIndex - context);
    const end = Math.min(text.length, errorIndex + context);
    const slice = (start === 0 ? '' : '...') + text.slice(start, end) + (end === text.length ? '' : '...');
    const near = text === slice ? '' : 'near ';
    return {
      message: `${message} while parsing ${near}${JSON.stringify(slice)}`,
      position: errorIndex,
    }
  } else {
    return {
      message: `${message} while parsing '${text.slice(0, context * 2)}'`,
      position: 0,
    }
  }
};

class JSONParseError extends SyntaxError {
  constructor (error, text, context = 20, caller) {
    const metadata = parseError(error, text, context);
    super(metadata.message);
    Object.assign(this, metadata);
    this.code = 'EJSONPARSE';
    this.systemError = error;
    Error.captureStackTrace(this, caller || this.constructor);
  }
  get name() { return this.constructor.name; }
  set name(_) {}
  get [Symbol.toStringTag]() { return this.constructor.name; }
}

const kIndent = Symbol.for('indent');
const kNewline = Symbol.for('newline');
const formatRE = /^\s*[{\[]((?:\r?\n)+)([\s\t]*)/;
const emptyRE = /^(?:\{\}|\[\])((?:\r?\n)+)?$/;

const parseJson = (text, reviver, context = 20) => {
  const parseText = stripBOM(text);
  try {
    const [, newline = '\n', indent = '  '] = parseText.match(emptyRE) || parseText.match(formatRE) || [, '', ''];
    const result = JSON.parse(parseText, reviver);
    if (result && typeof result === 'object') {
      result[kNewline] = newline;
      result[kIndent] = indent;
    }
    return result;
  } catch (error) {
    if (typeof text !== 'string' && !Buffer.isBuffer(text)) {
      const isEmptyArray = Array.isArray(text) && text.length === 0;
      throw Object.assign(new TypeError(`Cannot parse ${isEmptyArray ? 'an empty array' : String(text)}`), {
        code: 'EJSONPARSE',
        systemError: error,
      });
    }
    throw new JSONParseError(error, parseText, context, parseJson);
  }
};

const stripBOM = text => String(text).replace(/^\uFEFF/, '');

module.exports = parseJson;
parseJson.JSONParseError = JSONParseError;

parseJson.noExceptions = (text, reviver) => {
  try {
    return JSON.parse(stripBOM(text), reviver);
  } catch (e) {
    // return undefined on parse error
  }
};
```