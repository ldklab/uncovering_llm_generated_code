The given Node.js code provides functionality for parsing WebAssembly (WASM) using JavaScript. Here’s how it works:

1. **Handling Endianness**: The code checks the endianness of the environment. Endianness refers to the order of bytes—whether the least significant byte is stored first (little-endian) or last (big-endian). Based on the environment, it initializes a flag, `A`, to determine which helper function for byte ordering should be used (`C` for little-endian systems, `Q` for big-endian).

2. **Parsing Function**: The `parse` function takes an input string `E` and an optional label `g` (defaulting to '@'). It first checks if the WebAssembly module `B` has been initialized. If not, it waits for the `init` promise to resolve before proceeding.

3. **Memory Management**: The function calculates the required memory for parsing the input string and grows the WebAssembly memory buffer if necessary.

4. **Encoding Input**: Depending on the endianness, it encodes the input string into a binary format and copies it into the WebAssembly memory buffer.

5. **Invoking WASM Parse**: It calls the WebAssembly `parse` method to process the input. If parsing fails, an error is constructed showing the problematic line and column information.

6. **Retrieving Results**: The function extracts parsing results from the WebAssembly instance. It collects data into two arrays `L` and `k`—representing structured data and text segments after parsing, respectively.

7. **Initialization**: The `init` variable is assigned a promise that compiles a base64-encoded WebAssembly binary, then instantiates it, providing the exports to the local variable `B`.

8. **Exported Components**: The `parse` function and `init` initialization promise are exported for use elsewhere.

Below is a refactored version of this code:

```javascript
"use strict";

exports.parse = parse;
exports.init = void 0;

const IS_LITTLE_ENDIAN = 1 === new Uint8Array(new Uint16Array([1]).buffer)[0];

function encodeString(string, memoryBufferOffset, isLittleEndian) {
    const length = string.length;
    if (isLittleEndian) {
        for (let i = 0; i < length; i++) {
            memoryBufferOffset[i] = string.charCodeAt(i);
        }
    } else {
        for (let i = 0; i < length; i++) {
            const charCode = string.charCodeAt(i);
            memoryBufferOffset[i] = (charCode & 0xFF) << 8 | charCode >>> 8;
        }
    }
}

let wasmInstance;

async function loadWebAssembly() {
    const wasmBinary = /* Base64 WASM string omitted for brevity */;
    const binaryBuffer = Buffer.from(wasmBinary, "base64");
    const module = await WebAssembly.compile(binaryBuffer);
    const { exports } = await WebAssembly.instantiate(module);
    return exports;
}

const init = loadWebAssembly().then((exports) => {
    wasmInstance = exports;
});

exports.init = init;

async function parse(inputString, marker = "@") {
    if (!wasmInstance) {
        await init;
    }
  
    const inputLength = inputString.length + 1;
    const neededMemory = (wasmInstance.__heap_base.value || wasmInstance.__heap_base) + 4 * inputLength - wasmInstance.memory.buffer.byteLength;

    if (neededMemory > 0) {
        wasmInstance.memory.grow(Math.ceil(neededMemory / 65536));
    }

    const heapAllocationPointer = wasmInstance.sa(inputLength - 1);
    encodeString(inputString, new Uint16Array(wasmInstance.memory.buffer, heapAllocationPointer, inputLength), IS_LITTLE_ENDIAN);

    if (!wasmInstance.parse()) {
        const errorOffset = wasmInstance.e();
        throw Object.assign(new Error(`Parse error ${marker}:${inputString.slice(0, errorOffset).split("\n").length}:${errorOffset - inputString.lastIndexOf("\n", errorOffset - 1)}`), { idx: errorOffset });
    }

    const structuredData = [];
    const textSegments = [];

    while (wasmInstance.ri()) {
        structuredData.push({
            s: wasmInstance.is(),
            e: wasmInstance.ie(),
            ss: wasmInstance.ss(),
            se: wasmInstance.se(),
            d: wasmInstance.id(),
        });
    }

    while (wasmInstance.re()) {
        textSegments.push(inputString.slice(wasmInstance.es(), wasmInstance.ee()));
    }

    return [structuredData, textSegments, !!wasmInstance.f()];
}
```