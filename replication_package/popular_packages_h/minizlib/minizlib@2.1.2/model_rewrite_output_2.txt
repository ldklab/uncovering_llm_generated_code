```javascript
'use strict';

const assert = require('assert');
const { Buffer } = require('buffer');
const zlib = require('zlib');
const constants = exports.constants = require('./constants.js');
const Minipass = require('minipass');

const OriginalBufferConcat = Buffer.concat;
const _superWrite = Symbol('_superWrite');

class ZlibError extends Error {
  constructor(err) {
    super(`zlib: ${err.message}`);
    this.code = err.code || 'ZLIB_ERROR';
    this.errno = err.errno;
    Error.captureStackTrace(this, this.constructor);
  }

  get name() {
    return 'ZlibError';
  }
}

const _opts = Symbol('opts');
const _flushFlag = Symbol('flushFlag');
const _finishFlushFlag = Symbol('finishFlushFlag');
const _fullFlushFlag = Symbol('fullFlushFlag');
const _handle = Symbol('handle');
const _onError = Symbol('onError');
const _sawError = Symbol('sawError');
const _level = Symbol('level');
const _strategy = Symbol('strategy');
const _ended = Symbol('ended');

class ZlibBase extends Minipass {
  constructor(opts, mode) {
    if (!opts || typeof opts !== 'object')
      throw new TypeError('Invalid options for ZlibBase constructor');
      
    super(opts);
    this[_sawError] = false;
    this[_ended] = false;
    this[_opts] = opts;

    this[_flushFlag] = opts.flush;
    this[_finishFlushFlag] = opts.finishFlush;

    try {
      this[_handle] = new zlib[mode](opts);
    } catch (err) {
      throw new ZlibError(err);
    }

    this[_onError] = (err) => {
      if (this[_sawError])
        return;

      this[_sawError] = true;
      this.close();
      this.emit('error', err);
    };

    this[_handle].on('error', (err) => this[_onError](new ZlibError(err)));
    this.once('end', () => this.close());
  }

  close() {
    if (this[_handle]) {
      this[_handle].close();
      this[_handle] = null;
      this.emit('close');
    }
  }

  reset() {
    if (!this[_sawError]) {
      assert(this[_handle], 'zlib binding closed');
      return this[_handle].reset();
    }
  }

  flush(flushFlag) {
    if (this.ended)
      return;

    if (typeof flushFlag !== 'number')
      flushFlag = this[_fullFlushFlag];

    this.write(Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }));
  }

  end(chunk, encoding, cb) {
    if (chunk)
      this.write(chunk, encoding);
    this.flush(this[_finishFlushFlag]);
    this[_ended] = true;
    return super.end(null, null, cb);
  }

  get ended() {
    return this[_ended];
  }

  write(chunk, encoding, cb) {
    if (typeof encoding === 'function')
      cb = encoding, encoding = 'utf8';

    if (typeof chunk === 'string')
      chunk = Buffer.from(chunk, encoding);

    if (this[_sawError])
      return;

    assert(this[_handle], 'zlib binding closed');

    const nativeHandle = this[_handle]._handle;
    const originalNativeClose = nativeHandle.close;
    nativeHandle.close = () => {};
    const originalClose = this[_handle].close;
    this[_handle].close = () => {};
    Buffer.concat = (args) => args;

    let result;
    try {
      const flushFlag = typeof chunk[_flushFlag] === 'number' ? chunk[_flushFlag] : this[_flushFlag];
      result = this[_handle]._processChunk(chunk, flushFlag);
      Buffer.concat = OriginalBufferConcat;
    } catch (err) {
      Buffer.concat = OriginalBufferConcat;
      this[_onError](new ZlibError(err));
    } finally {
      if (this[_handle]) {
        this[_handle]._handle = nativeHandle;
        nativeHandle.close = originalNativeClose;
        this[_handle].close = originalClose;
        this[_handle].removeAllListeners('error');
      }
    }

    if (this[_handle])
      this[_handle].on('error', (err) => this[_onError](new ZlibError(err)));

    let writeReturn;
    if (result) {
      if (Array.isArray(result) && result.length > 0) {
        writeReturn = this[_superWrite](Buffer.from(result[0]));
        for (let i = 1; i < result.length; i++) {
          writeReturn = this[_superWrite](result[i]);
        }
      } else {
        writeReturn = this[_superWrite](Buffer.from(result));
      }
    }

    if (cb)
      cb();
    return writeReturn;
  }

  [_superWrite](data) {
    return super.write(data);
  }
}

class Zlib extends ZlibBase {
  constructor(opts, mode) {
    opts = opts || {};

    opts.flush = opts.flush || constants.Z_NO_FLUSH;
    opts.finishFlush = opts.finishFlush || constants.Z_FINISH;
    super(opts, mode);

    this[_fullFlushFlag] = constants.Z_FULL_FLUSH;
    this[_level] = opts.level;
    this[_strategy] = opts.strategy;
  }

  params(level, strategy) {
    if (this[_sawError])
      return;

    if (!this[_handle])
      throw new Error('Cannot switch params when binding is closed');

    if (!this[_handle].params)
      throw new Error('Not supported in this implementation');

    if (this[_level] !== level || this[_strategy] !== strategy) {
      this.flush(constants.Z_SYNC_FLUSH);
      assert(this[_handle], 'zlib binding closed');
      const origFlush = this[_handle].flush;
      this[_handle].flush = (flushFlag, cb) => {
        this.flush(flushFlag);
        cb();
      };
      try {
        this[_handle].params(level, strategy);
      } finally {
        this[_handle].flush = origFlush;
      }

      if (this[_handle]) {
        this[_level] = level;
        this[_strategy] = strategy;
      }
    }
  }
}

class Deflate extends Zlib {
  constructor(opts) {
    super(opts, 'Deflate');
  }
}

class Inflate extends Zlib {
  constructor(opts) {
    super(opts, 'Inflate');
  }
}

const _portable = Symbol('_portable');

class Gzip extends Zlib {
  constructor(opts) {
    super(opts, 'Gzip');
    this[_portable] = opts && !!opts.portable;
  }

  [_superWrite](data) {
    if (!this[_portable])
      return super[_superWrite](data);

    this[_portable] = false;
    data[9] = 255;
    return super[_superWrite](data);
  }
}

class Gunzip extends Zlib {
  constructor(opts) {
    super(opts, 'Gunzip');
  }
}

class DeflateRaw extends Zlib {
  constructor(opts) {
    super(opts, 'DeflateRaw');
  }
}

class InflateRaw extends Zlib {
  constructor(opts) {
    super(opts, 'InflateRaw');
  }
}

class Unzip extends Zlib {
  constructor(opts) {
    super(opts, 'Unzip');
  }
}

class Brotli extends ZlibBase {
  constructor(opts, mode) {
    opts = opts || {};

    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;
    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH;

    super(opts, mode);

    this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;
  }
}

class BrotliCompress extends Brotli {
  constructor(opts) {
    super(opts, 'BrotliCompress');
  }
}

class BrotliDecompress extends Brotli {
  constructor(opts) {
    super(opts, 'BrotliDecompress');
  }
}

exports.Deflate = Deflate;
exports.Inflate = Inflate;
exports.Gzip = Gzip;
exports.Gunzip = Gunzip;
exports.DeflateRaw = DeflateRaw;
exports.InflateRaw = InflateRaw;
exports.Unzip = Unzip;

if (typeof zlib.BrotliCompress === 'function') {
  exports.BrotliCompress = BrotliCompress;
  exports.BrotliDecompress = BrotliDecompress;
} else {
  exports.BrotliCompress = exports.BrotliDecompress = class {
    constructor() {
      throw new Error('Brotli is not supported in this version of Node.js');
    }
  };
}
```