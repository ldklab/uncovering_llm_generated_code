The provided Node.js code is designed to determine image dimensions either from a file path or a buffer of image data. It includes functionality to handle both synchronous and asynchronous file reading to accommodate different use cases. Here's a breakdown of the code's functionality:

1. **Constants and Imports:**
   - `MaxBufferSize`: Defines the maximum buffer size to read data from a file, defaulting to 512 KB.
   - `queue`: Utilizes the `queue` module to manage a queue for asynchronous file operations, controlling concurrency to avoid overwhelming the file system.

2. **`lookup` Function:**
   - Takes a buffer and a file path, detects the file type using an external `detector` module.
   - If a handler exists for the detected type in `typeHandlers`, it calculates the image size and returns it. If the file type is unsupported, an error is thrown.

3. **File Reading Functions:**
   - `asyncFileToBuffer`: Asynchronously reads a file given its path, using a limited buffer size, and returns a promise that resolves with the file's buffer.
   - `syncFileToBuffer`: Synchronously reads a file to a buffer, using a similar method to the asynchronous version but blocks the Node.js event loop.

4. **`imageSize` Function:**
   - Main function that determines image size from either a buffer or a file.
   - If passed a buffer, it directly calls `lookup`.
   - If passed a file path, it resolves the path and reads the file into a buffer, either synchronously or asynchronously based on whether a callback is provided.

5. **Exports:**
   - Exports the `imageSize` function and other utility settings, like `setConcurrency` to adjust the queue concurrency and `types` to list supported image types.

Here's a rewritten version of the code using modern Node.js syntax:

```javascript
"use strict";
const fs = require("fs").promises;
const fsSync = require("fs");
const path = require("path");
const Queue = require("queue");
const { detector } = require("./detector");
const { typeHandlers } = require("./types");

const MaxBufferSize = 512 * 1024;
const queue = new Queue({ concurrency: 100, autostart: true });

async function asyncFileToBuffer(filepath) {
    const handle = await fs.open(filepath, 'r');
    const { size } = await handle.stat();
    if (size <= 0) {
        await handle.close();
        throw new Error('Empty file');
    }
    const bufferSize = Math.min(size, MaxBufferSize);
    const buffer = Buffer.alloc(bufferSize);
    await handle.read(buffer, 0, bufferSize, 0);
    await handle.close();
    return buffer;
}

function syncFileToBuffer(filepath) {
    const descriptor = fsSync.openSync(filepath, 'r');
    const { size } = fsSync.fstatSync(descriptor);
    if (size <= 0) {
        fsSync.closeSync(descriptor);
        throw new Error('Empty file');
    }
    const bufferSize = Math.min(size, MaxBufferSize);
    const buffer = Buffer.alloc(bufferSize);
    fsSync.readSync(descriptor, buffer, 0, bufferSize, 0);
    fsSync.closeSync(descriptor);
    return buffer;
}

function lookup(buffer, filepath) {
    const type = detector(buffer);
    if (type && type in typeHandlers) {
        const size = typeHandlers[type].calculate(buffer, filepath);
        if (size !== undefined) {
            size.type = type;
            return size;
        }
    }
    throw new TypeError('unsupported file type: ' + type + ' (file: ' + filepath + ')');
}

function imageSize(input, callback) {
    if (Buffer.isBuffer(input)) {
        return lookup(input);
    }
    if (typeof input !== 'string') {
        throw new TypeError('invalid invocation');
    }
    const filepath = path.resolve(input);
    if (typeof callback === 'function') {
        queue.push(() => asyncFileToBuffer(filepath)
            .then(buffer => process.nextTick(() => callback(null, lookup(buffer, filepath))))
            .catch(callback));
    } else {
        const buffer = syncFileToBuffer(filepath);
        return lookup(buffer, filepath);
    }
}

module.exports = imageSize;
module.exports.setConcurrency = (c) => { queue.concurrency = c; };
module.exports.types = Object.keys(typeHandlers);
```