The given Node.js code is an implementation of an XML parser called `SaxesParser`. This parser is designed to process XML data, keeping track of the parsing state and checking for well-formedness according to XML specifications. Here's a concise explanation of its functionality:

1. **Imports and Constants**: The code imports utilities to handle XML character checks and defines numerous constants used throughout the parsing process, such as states (`S_BEGIN`, `S_TEXT`, etc.) and event types (`xmldecl`, `text`, `opentag`, etc.).

2. **Namespaces and Entities**: It defines and maps XML namespaces and entities. Namespaces are employed for XML elements and attributes, while entities are used for special characters (like `&`, `<`, etc.).

3. **Parser Initialization**: The `SaxesParser` class is initialized with options like `xmlns` for namespace support and `fragment` for parsing partial documents. Depending on these options, adjustments are made to how names and namespaces are handled.

4. **State Machine**: The parser operates based on a state machine model. It transitions between states as it reads and interprets XML data. States handle different constructs like opening tags, closing tags, attributes, comments, CDATA sections, and processing instructions.

5. **Events and Handlers**: The parser supports event-driven parsing. It has methods to set and remove event handlers (`on`, `off`) and fires events like `opentag`, `closetag`, `text`, etc., during parsing.

6. **Error Handling**: It includes robust error handling to ensure XML well-formedness. Errors are thrown or handled by user-provided error handlers.

7. **Public Methods**: Key methods like `write`, `close`, and `end` allow feeding data into the parser and managing its lifecycle. The `write` method processes chunks of the XML data, while `close` and `end` finalize the parsing.

8. **Namespaces and Entity Handling**: The parser can handle XML namespaces and resolve entities within XML data, converting entities to their character equivalents.

Below is a rewrite of the Node.js code, encapsulating its essential functionality in a structured way:

```js
"use strict";
const ed5 = require("xmlchars/xml/1.0/ed5");
const ed2 = require("xmlchars/xml/1.1/ed2");
const NSed3 = require("xmlchars/xmlns/1.0/ed3");

// Constants and regex for XML validation
const XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
const XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
const FORBIDDEN_START = 0, FORBIDDEN_BRACKET = 1, FORBIDDEN_BRACKET_BRACKET = 2;
const EVENTS = ["xmldecl", "text", "processinginstruction", "doctype", "comment", "opentagstart", "attribute", "opentag", "closetag", "cdata", "error", "end", "ready"];
const EOC = -1, NL_LIKE = -2;

// Entity mappings
const XML_ENTITIES = {
    __proto__: null,
    amp: "&",
    gt: ">",
    lt: "<",
    quot: "\"",
    apos: "'"
};

// Utility function
const isQuote = (c) => c === 0x22 || c === 0x27; // DQUOTE, SQUOTE

// XML Parser Class
class SaxesParser {
    constructor(opt) {
        this.opt = opt || {};
        this.stateTable = this.createParserStateTable();
        this._init();
    }

    createParserStateTable() {
        return [
            this.sBegin,
            this.sBeginWhitespace,
            // More states mapped to methods...
            this.sText,
        ];
    }

    getCodeNorm() {
        const c = this.getCode();
        return c === NL_LIKE ? 0xA : c;
    }

    _init() { /*... Initialize parser state ...*/ }

    on(name, handler) { /*... Set event handler ...*/ }
    off(name) { /*... Remove event handler ...*/ }

    write(chunk) {
        if (this.closed) {
            return this.fail("cannot write after close; assign an onready handler.");
        }
        // Parsing logic
    }

    // Fundamental actions per state
    sBegin() { /*... Parsing logic for S_BEGIN state ...*/ }
    sBeginWhitespace() { /*... Parsing logic for whitespace ...*/ }
    sText() { /*... Handle text nodes within root ...*/ }

    openTag() {
        // Handle opening tag logic
    }

    closeTag() {
        // Handle closing tag logic
    }

    fail(message) {
        // Custom error handling
    }

    // NS and entities handling
    parseEntity(entity) {
        // Logic to resolve entities
        return "&";
    }
}

// Export Parser
exports.SaxesParser = SaxesParser;
exports.EVENTS = EVENTS;
``` 

The rewritten code captures the overall structure and key functionalities of the `SaxesParser` by organizing constants, setting up the initial parser state, defining the main methods, state transitions, and event handling capabilities, while focusing on readability and essential logical components.