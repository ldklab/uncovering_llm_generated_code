The provided Node.js code defines a function `eos`, which stands for "end-of-stream." This utility is used to monitor when a stream (such as a network connection or file read/write process) has ended. It facilitates executing a callback function once the stream is finished reading or writing, or if an error occurs.

### Explanation:
1. **Dependencies**:
   - Imports the `once` module, ensuring that the callback is invoked only once, even if multiple end events occur.

2. **Helper Functions**:
   - `noop`: A no-operation function used as a placeholder for a default callback.
   - `isRequest`: Determines if the stream resembles an HTTP request by checking for methods like `setHeader` and `abort`.
   - `isChildProcess`: Checks if the stream is a child process by examining `stdio` property characteristics.

3. **Main `eos` Function**:
   - Takes a stream and optional options or callback function.
   - Establishes state tracking for both readable and writable aspects of the stream.
   - Registers event listeners (`onfinish`, `onend`, `onexit`, `onerror`, `onclose`) for handling various stream endings and errors.
   - If the stream is confirmed to be an HTTP request or a legacy stream, it attaches corresponding event listeners.
   - For child processes, monitors the 'exit' event.
   - Provides a mechanism (`return function`) to cancel the monitoring by removing all event listeners, aiding in memory management.

### Rewritten Code:

```javascript
const once = require('once');

const noop = () => {};

const isRequest = (stream) => (
  stream.setHeader && typeof stream.abort === 'function'
);

const isChildProcess = (stream) => (
  stream.stdio && Array.isArray(stream.stdio) &&
  stream.stdio.length === 3
);

const eos = (stream, opts, callback) => {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};

  callback = once(callback || noop);

  const ws = stream._writableState;
  const rs = stream._readableState;
  let readable = opts.readable || (opts.readable !== false && stream.readable);
  let writable = opts.writable || (opts.writable !== false && stream.writable);
  let cancelled = false;

  const onlegacyfinish = () => {
    if (!stream.writable) onfinish();
  };

  const onfinish = () => {
    writable = false;
    if (!readable) callback.call(stream);
  };

  const onend = () => {
    readable = false;
    if (!writable) callback.call(stream);
  };

  const onexit = (exitCode) => {
    callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
  };

  const onerror = (err) => {
    callback.call(stream, err);
  };

  const onclose = () => {
    process.nextTick(onclosenexttick);
  };

  const onclosenexttick = () => {
    if (cancelled) return;
    if (
      readable && !(rs && (rs.ended && !rs.destroyed)) ||
      writable && !(ws && (ws.ended && !ws.destroyed))
    ) {
      callback.call(stream, new Error('premature close'));
    }
  };

  const onrequest = () => {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();
    else stream.on('request', onrequest);
  } else if (writable && !ws) { // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  if (isChildProcess(stream)) stream.on('exit', onexit);

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);

  return () => {
    cancelled = true;
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('exit', onexit);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
};

module.exports = eos;
```