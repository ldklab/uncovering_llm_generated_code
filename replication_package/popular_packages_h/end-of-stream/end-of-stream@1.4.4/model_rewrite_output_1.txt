The provided Node.js code defines a utility function called `eos` (end-of-stream) that is used to detect when a stream-like object has finished its processing, either by successfully closing or by encountering an error. The function supports both readable and writable streams, as well as process streams such as child processes, and is robust against premature close events and legacy stream implementations.

Here's the explanation of the functionality:

1. **Dependencies**: The `once` package is imported to ensure that the callback function is only invoked a single time.

2. **Helpers**: Defines helper functions `noop`, `isRequest`, and `isChildProcess` to check if a stream is an HTTP request or a child process.

3. **Main Function - `eos`**: This function receives a stream, optional options, and a callback. It handles the stream's end or error events:

    - It adjusts the callback to ensure it is only called once.
    - It listens for various events such as `end`, `finish`, `error`, and `close`.
    - For HTTP requests, it manages additional events like `complete` and `abort`.
    - For child processes, it listens to the `exit` event to handle process termination.
    - It provides a mechanism to cancel all the event listeners.

4. **Return Function**: The `eos` function returns a function that, when called, cancels all previously set listeners to prevent memory leaks.

5. **Export**: The `eos` function is exported as a module, allowing it to be used in other parts of an application.

Now, here is a possible rewrite of the Node.js code:

```javascript
const once = require('once');

const noop = () => {};

const isRequest = stream => !!(stream.setHeader && typeof stream.abort === 'function');

const isChildProcess = stream => !!(stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3);

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  opts = opts || {};
  
  callback = once(callback || noop);

  const ws = stream._writableState;
  const rs = stream._readableState;
  let readable = opts.readable || (opts.readable !== false && stream.readable);
  let writable = opts.writable || (opts.writable !== false && stream.writable);
  let cancelled = false;

  const onfinish = () => {
    writable = false;
    if (!readable) callback.call(stream);
  };

  const onend = () => {
    readable = false;
    if (!writable) callback.call(stream);
  };

  const onexit = exitCode => {
    callback.call(stream, exitCode ? new Error(`exited with error code: ${exitCode}`) : null);
  };

  const onerror = err => {
    callback.call(stream, err);
  };

  const onclose = () => {
    process.nextTick(() => {
      if (cancelled) return;
      if (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));
      if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));
    });
  };

  const onrequest = () => {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();
    else stream.on('request', onrequest);
  } else if (writable && !ws) { // legacy streams
    stream.on('end', onfinish);
    stream.on('close', onfinish);
  }

  if (isChildProcess(stream)) stream.on('exit', onexit);

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);

  return () => {
    cancelled = true;
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onfinish);
    stream.removeListener('close', onfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('exit', onexit);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
```