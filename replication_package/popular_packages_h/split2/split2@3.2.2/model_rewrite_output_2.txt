The given Node.js code defines a `split` function that returns a transform stream. This stream is designed to process chunks of incoming data, splitting them into parts based on a specified delimiter (a matcher) and optionally transforming each part using a given mapping function.

### Functionality Breakdown:
- **`split` Function:** Creates a transform stream that can split data into parts based on a regular expression or string matcher.
  - **Arguments:**
    - `matcher`: Regex/string to split the data (default is newline characters `\r?\n`).
    - `mapper`: Function that transforms each split part (default is a no-operation function).
    - `options`: Additional options including `maxLength` to control buffer size and `skipOverflow` to decide if overflow errors should be skipped.
  - **Setup Stream:**
    - Initializes properties such as the last chunk of data `kLast`, decoder for string conversion `kDecoder`, and others like `matcher` and `mapper`.
    - Uses internal `transform` and `flush` functions to process and output data parts.
  
- **`transform` Function:**
  - Handles incoming chunks, splitting them using the `matcher`.
  - Manages buffer overflow by checking if any split part exceeds `maxLength`.
  - Applies the `mapper` to each part and pushes the transformed result to the output.

- **`flush` Function:**
  - Processes any remaining data in the buffer when the stream ends, mapping and pushing it if necessary.

- **`push` Function:**
  - Helper function to push mapped results to the readable side of the stream.

- **Error Handling:**
  - The split stream raises an error when a chunk causes a buffer to exceed `maxLength` (unless `skipOverflow` is set to `true`).

```javascript
'use strict'

const { Transform } = require('stream')
const { StringDecoder } = require('string_decoder')
const kLast = Symbol('last')
const kDecoder = Symbol('decoder')

function transform(chunk, enc, cb) {
  let list
  if (this.overflow) {
    let buf = this[kDecoder].write(chunk)
    list = buf.split(this.matcher)

    if (list.length === 1) return cb()

    list.shift()
    this.overflow = false
  } else {
    this[kLast] += this[kDecoder].write(chunk)
    list = this[kLast].split(this.matcher)
  }

  this[kLast] = list.pop()

  for (let i = 0; i < list.length; i++) {
    try {
      push(this, this.mapper(list[i]))
    } catch (error) {
      return cb(error)
    }
  }

  this.overflow = this[kLast].length > this.maxLength
  if (this.overflow && !this.skipOverflow) return cb(new Error('maximum buffer reached'))

  cb()
}

function flush(cb) {
  this[kLast] += this[kDecoder].end()

  if (this[kLast]) {
    try {
      push(this, this.mapper(this[kLast]))
    } catch (error) {
      return cb(error)
    }
  }

  cb()
}

function push(self, val) {
  if (val !== undefined) {
    self.push(val)
  }
}

function noop(incoming) {
  return incoming
}

function split(matcher, mapper, options = {}) {
  if (typeof matcher === 'function') {
    mapper = matcher
    matcher = /\r?\n/
  } else if (typeof matcher === 'object' && !(matcher instanceof RegExp)) {
    options = matcher
    matcher = /\r?\n/
    mapper = noop
  } else if (typeof mapper === 'object') {
    options = mapper
    mapper = noop
  }

  const streamOptions = {
    ...options,
    transform,
    flush,
    readableObjectMode: true
  }

  const stream = new Transform(streamOptions)

  stream[kLast] = ''
  stream[kDecoder] = new StringDecoder('utf8')
  stream.matcher = matcher || /\r?\n/
  stream.mapper = mapper || noop
  stream.maxLength = options.maxLength || Infinity
  stream.skipOverflow = options.skipOverflow || false
  stream.overflow = false

  return stream
}

module.exports = split
```