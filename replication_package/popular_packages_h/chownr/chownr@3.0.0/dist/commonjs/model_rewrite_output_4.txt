The provided Node.js code defines two main functions, `chownr` and `chownrSync`, used to change the owner and group of directories and their contents recursively. The code utilizes built-in Node.js modules `fs` (file system operations) and `path` (to resolve file paths).

Here's a breakdown of the functionality:

1. **chown** (`cpath`, `uid`, `gid`, `cb`): A function that changes the owner and group of a path (`cpath`). It uses `fs.lchown` to change file ownership and handles a callback `cb`, skipping errors with the code `ENOENT`.

2. **chownrKid** and **chownrKidSync**: Helper functions that are responsible for handling child nodes (files or directories) in the directory. They check if a child is a directory and, if so, call `chownr` or `chownrSync` recursively.

3. **chownr** (`p`, `uid`, `gid`, `cb`): This is an asynchronous function to change the owner and group of a directory and its content recursively. It reads the directory's contents using `fs.readdir` and processes each entry (both files and subdirectories). For errors, it skips `ENOENT`, `ENOTDIR`, and `ENOTSUP`, indicating non-existent paths, non-directory paths, or unsupported operations. It manages error propagation through a callback mechanism.

4. **chownrSync** (`p`, `uid`, `gid`): This is the synchronous version of `chownr`. It attempts to read the directory contents using `fs.readdirSync`. It similarly checks for errors like `ENOENT`, `ENOTDIR`, and `ENOTSUP`.

Here is the rewritten code:

```javascript
"use strict";
const fs = require("node:fs");
const path = require("node:path");

const lchownSync = (filePath, uid, gid) => {
    try {
        return fs.lchownSync(filePath, uid, gid);
    } catch (error) {
        if (error?.code !== 'ENOENT') throw error;
    }
};

const chown = (filePath, uid, gid, callback) => {
    fs.lchown(filePath, uid, gid, error => {
        callback(error && error?.code !== 'ENOENT' ? error : null);
    });
};

const chownrKid = (parentPath, child, uid, gid, callback) => {
    const childPath = path.resolve(parentPath, child.name);
    if (child.isDirectory()) {
        chownr(childPath, uid, gid, error => {
            if (error) return callback(error);
            chown(childPath, uid, gid, callback);
        });
    } else {
        chown(childPath, uid, gid, callback);
    }
};

const chownr = (directoryPath, uid, gid, callback) => {
    fs.readdir(directoryPath, { withFileTypes: true }, (error, children) => {
        if (error) {
            if (error.code === 'ENOENT') return callback();
            if (error.code !== 'ENOTDIR' && error.code !== 'ENOTSUP') return callback(error);
        }
        if (error || !children.length) return chown(directoryPath, uid, gid, callback);

        let pending = children.length;
        const handleError = err => {
            if (err) return callback(err);
            if (--pending === 0) chown(directoryPath, uid, gid, callback);
        };
        for (const child of children) {
            chownrKid(directoryPath, child, uid, gid, handleError);
        }
    });
};

const chownrKidSync = (parentPath, child, uid, gid) => {
    const childPath = path.resolve(parentPath, child.name);
    if (child.isDirectory()) chownrSync(childPath, uid, gid);
    lchownSync(childPath, uid, gid);
};

const chownrSync = (directoryPath, uid, gid) => {
    let children;
    try {
        children = fs.readdirSync(directoryPath, { withFileTypes: true });
    } catch (error) {
        if (error?.code === 'ENOENT') return;
        if (error?.code === 'ENOTDIR' || error?.code === 'ENOTSUP') return lchownSync(directoryPath, uid, gid);
        throw error;
    }
    for (const child of children) {
        chownrKidSync(directoryPath, child, uid, gid);
    }
    return lchownSync(directoryPath, uid, gid);
};

exports.chownr = chownr;
exports.chownrSync = chownrSync;
```