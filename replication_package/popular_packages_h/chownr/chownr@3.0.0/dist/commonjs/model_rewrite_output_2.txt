The provided Node.js code defines two main functions, `chownr` and `chownrSync`, as well as several helper functions to recursively change the ownership of files and directories. Here's a breakdown of the functionality:

1. **lchownSync**: A synchronous helper function to change the ownership of a file or directory, catching and ignoring ENOENT (file not found) errors.

2. **chown**: An asynchronous helper function that changes the ownership of a specified file or directory, passing any error (except ENOENT) to the callback.

3. **chownrKid**: An asynchronous helper function to handle the recursive chown operation for each child item (file or directory) within a given directory.

4. **chownr**: The main asynchronous function that recursively changes the ownership (user ID and group ID) of a directory and its contents. It uses the `readdir` method to list all child items and applies ownership changes recursively, handling any errors appropriately.

5. **chownrKidSync**: A synchronous helper function similar to `chownrKid`, but it operates in a blocking manner to change ownerships.

6. **chownrSync**: The main synchronous function that recursively changes the ownership of a directory and its contents, similar to `chownr` but using `readdirSync` for synchronous operations.

The functions are exported using `exports`, making them available for use in other modules.

Here's a possible rewrite of the code:

```javascript
"use strict";
const fs = require("node:fs");
const path = require("node:path");

const lchownSync = (filePath, uid, gid) => {
    try {
        fs.lchownSync(filePath, uid, gid);
    } catch (error) {
        if (error?.code !== 'ENOENT') throw error;
    }
};

const chown = (filePath, uid, gid, callback) => {
    fs.lchown(filePath, uid, gid, (error) => {
        callback(error && error.code !== 'ENOENT' ? error : null);
    });
};

const chownrKid = (parentPath, child, uid, gid, callback) => {
    const childPath = path.resolve(parentPath, child.name);
    if (child.isDirectory()) {
        chownr(childPath, uid, gid, (error) => {
            if (error) return callback(error);
            chown(childPath, uid, gid, callback);
        });
    } else {
        chown(childPath, uid, gid, callback);
    }
};

const chownr = (directoryPath, uid, gid, callback) => {
    fs.readdir(directoryPath, { withFileTypes: true }, (error, children) => {
        if (error) {
            if (error.code === 'ENOENT') return callback();
            if (error.code !== 'ENOTDIR' && error.code !== 'ENOTSUP') return callback(error);
        }
        if (error || !children.length) return chown(directoryPath, uid, gid, callback);

        let remaining = children.length;
        let errorState = null;

        const done = (error) => {
            if (errorState) return;
            if (error) return callback((errorState = error));
            if (--remaining === 0) return chown(directoryPath, uid, gid, callback);
        };

        for (const child of children) {
            chownrKid(directoryPath, child, uid, gid, done);
        }
    });
};

const chownrKidSync = (parentPath, child, uid, gid) => {
    const childPath = path.resolve(parentPath, child.name);
    if (child.isDirectory()) {
        chownrSync(childPath, uid, gid);
    }
    lchownSync(childPath, uid, gid);
};

const chownrSync = (directoryPath, uid, gid) => {
    let children;
    try {
        children = fs.readdirSync(directoryPath, { withFileTypes: true });
    } catch (error) {
        if (error?.code === 'ENOENT') return;
        if (error?.code === 'ENOTDIR' || error?.code === 'ENOTSUP') return lchownSync(directoryPath, uid, gid);
        throw error;
    }

    for (const child of children) {
        chownrKidSync(directoryPath, child, uid, gid);
    }
    lchownSync(directoryPath, uid, gid);
};

module.exports = { chownr, chownrSync };
```