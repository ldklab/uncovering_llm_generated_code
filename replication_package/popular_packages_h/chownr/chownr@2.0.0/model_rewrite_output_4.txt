The provided Node.js code defines functions to recursively change the owner (user and group) of a file system path and all its contents. This is particularly useful in managing file permissions. It supports both asynchronous and synchronous operations and handles various edge cases and compatibility issues across Node.js versions. Here is a breakdown of its primary functions:

1. **lchownSync and chownSync**: Synchronously attempt to change the ownership of a path, handling `ENOENT` errors gracefully (ends process without throwing).

2. **handleEISDIR and handleEISDirSync**: Provide workaround solutions for the `EISDIR` error on older Node.js versions, where directory permission changes could throw unexpected errors.

3. **readdir and readdirSync**: Load directory contents using the appropriate method for the Node.js version in use, taking into consideration compatibility for Node v4.

4. **chown and chownrKid**: Change the ownership of a single path, asynchronously handling errors and recursively processing child directories.

5. **chownr**: The main recursive function that traverses directory contents, applies changes, and deals with any encountered errors, reporting back via a callback.

6. **chownrKidSync and chownrSync**: Synchronous versions of the aforementioned functions that follow the same logic without the asynchronous callback pattern.

The result is an exported `chownr` function with both asynchronous and synchronous capabilities (`chownr.sync`).

Here's the rewritten code:

```javascript
'use strict';
const fs = require('fs');
const path = require('path');

const LCHOWN = fs.lchown ? 'lchown' : 'chown';
const LCHOWNSYNC = fs.lchownSync ? 'lchownSync' : 'chownSync';

const needEISDIRHandled = fs.lchown &&
  !process.version.match(/v1[1-9]+\./) &&
  !process.version.match(/v10\.[6-9]/);

const lchownSync = (filePath, uid, gid) => {
  try {
    return fs[LCHOWNSYNC](filePath, uid, gid);
  } catch (er) {
    if (er.code !== 'ENOENT') throw er;
  }
};

const chownSync = (filePath, uid, gid) => {
  try {
    return fs.chownSync(filePath, uid, gid);
  } catch (er) {
    if (er.code !== 'ENOENT') throw er;
  }
};

const handleEISDIR = needEISDIRHandled ? (filePath, uid, gid, cb) => er => {
  if (!er || er.code !== 'EISDIR') cb(er);
  else fs.chown(filePath, uid, gid, cb);
} : (_, __, ___, cb) => cb;

const handleEISDirSync = needEISDIRHandled ? (filePath, uid, gid) => {
  try {
    return lchownSync(filePath, uid, gid);
  } catch (er) {
    if (er.code !== 'EISDIR') throw er;
    chownSync(filePath, uid, gid);
  }
} : (filePath, uid, gid) => lchownSync(filePath, uid, gid);

const nodeVersion = process.version;
let readdir = fs.readdir;
let readdirSync = fs.readdirSync;
if (/^v4\./.test(nodeVersion))
  readdir = (filePath, options, cb) => fs.readdir(filePath, cb);

const chown = (cpath, uid, gid, cb) => {
  fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, er => {
    cb(er && er.code !== 'ENOENT' ? er : null);
  }));
};

const chownrKid = (p, child, uid, gid, cb) => {
  if (typeof child === 'string') {
    return fs.lstat(path.resolve(p, child), (er, stats) => {
      if (er) return cb(er.code !== 'ENOENT' ? er : null);
      stats.name = child;
      chownrKid(p, stats, uid, gid, cb);
    });
  }

  if (child.isDirectory()) {
    chownr(path.resolve(p, child.name), uid, gid, er => {
      if (er) return cb(er);
      chown(path.resolve(p, child.name), uid, gid, cb);
    });
  } else {
    chown(path.resolve(p, child.name), uid, gid, cb);
  }
};

const chownr = (p, uid, gid, cb) => {
  readdir(p, { withFileTypes: true }, (er, children) => {
    if (er) {
      if (er.code === 'ENOENT') return cb();
      if (er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP') return cb(er);
    }
    if (er || !children.length) return chown(p, uid, gid, cb);

    let len = children.length;
    let errState = null;
    const then = er => {
      if (errState) return;
      if (er) return cb(errState = er);
      if (--len === 0) return chown(p, uid, gid, cb);
    };

    children.forEach(child => chownrKid(p, child, uid, gid, then));
  });
};

const chownrKidSync = (p, child, uid, gid) => {
  if (typeof child === 'string') {
    try {
      const stats = fs.lstatSync(path.resolve(p, child));
      stats.name = child;
      child = stats;
    } catch (er) {
      if (er.code === 'ENOENT') return;
      throw er;
    }
  }

  if (child.isDirectory()) chownrSync(path.resolve(p, child.name), uid, gid);
  
  handleEISDirSync(path.resolve(p, child.name), uid, gid);
};

const chownrSync = (p, uid, gid) => {
  let children;
  try {
    children = readdirSync(p, { withFileTypes: true });
  } catch (er) {
    if (er.code === 'ENOENT') return;
    if (er.code === 'ENOTDIR' || er.code === 'ENOTSUP') {
      return handleEISDirSync(p, uid, gid);
    }
    throw er;
  }

  if (children && children.length) {
    children.forEach(child => chownrKidSync(p, child, uid, gid));
  }

  return handleEISDirSync(p, uid, gid);
};

module.exports = chownr;
chownr.sync = chownrSync;
```