The Node.js code defines a custom HTTP/HTTPS `Agent` by extending Node.js's built-in `http.Agent`. The `Agent` class overrides and provides additional functionalities to manage socket creation and connection pooling for network requests. The following are key functionalities provided by the code:

1. **Module Import and Export**: 
   - Uses `__importStar` to import all exports from Node.js 'net', 'http', and 'https' modules.
   - Exports all from a local 'helpers' module.
   
2. **Secure Endpoint Detection**:
   - Implements `isSecureEndpoint` to determine if a request should use a secure HTTP connection based on `options` provided.
   - Uses `protocol` property from `options` or stack trace detection to check for HTTPS usage.

3. **Socket Management**:
   - Implements `incrementSockets` and `decrementSockets` methods to track and manage sockets actively used by the agent.
   - Creates fake sockets to ensure synchronous updates to the socket pool.

4. **Custom Socket and Connection Logic**:
   - Implements `createSocket` method which asynchronously creates or retrieves a socket connection for HTTP(S) requests.
   - `createConnection` ensures the correct socket is used when executing requests.

5. **Default Port and Protocol Handling**:
   - Provides `defaultPort` and `protocol` properties with getter and setter methods to manage connection defaults based on HTTP/HTTPS protocol.

The rewritten code is organized as a single module:

```javascript
"use strict";

const net = require("net");
const http = require("http");
const https = require("https");
Object.assign(exports, require("./helpers"));

const INTERNAL = Symbol('AgentBaseInternalState');

class Agent extends http.Agent {
    constructor(opts) {
        super(opts);
        this[INTERNAL] = {};
    }

    isSecureEndpoint(options) {
        if (options) {
            if (typeof options.secureEndpoint === 'boolean') {
                return options.secureEndpoint;
            }
            if (typeof options.protocol === 'string') {
                return options.protocol === 'https:';
            }
        }
        const { stack } = new Error();
        return typeof stack === 'string' &&
            stack.split('\n').some((l) => l.includes('(https.js:') || l.includes('node:https:'));
    }

    incrementSockets(name) {
        if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
            return null;
        }
        if (!this.sockets[name]) this.sockets[name] = [];
        const fakeSocket = new net.Socket({ writable: false });
        this.sockets[name].push(fakeSocket);
        this.totalSocketCount = (this.totalSocketCount || 0) + 1;
        return fakeSocket;
    }
    
    decrementSockets(name, socket) {
        if (!this.sockets[name] || !socket) return;

        const sockets = this.sockets[name];
        const index = sockets.indexOf(socket);
        if (index !== -1) {
            sockets.splice(index, 1);
            this.totalSocketCount--;
            if (!sockets.length) delete this.sockets[name];
        }
    }

    getName(options) {
        const secureEndpoint = typeof options.secureEndpoint === 'boolean'
            ? options.secureEndpoint
            : this.isSecureEndpoint(options);
        return secureEndpoint
            ? https.Agent.prototype.getName.call(this, options)
            : super.getName(options);
    }

    createSocket(req, options, cb) {
        const connectOpts = { ...options, secureEndpoint: this.isSecureEndpoint(options) };
        const name = this.getName(connectOpts);
        const fakeSocket = this.incrementSockets(name);

        Promise.resolve()
            .then(() => this.connect(req, connectOpts))
            .then((socket) => {
                this.decrementSockets(name, fakeSocket);
                if (socket instanceof http.Agent) {
                    return socket.addRequest(req, connectOpts);
                }
                this[INTERNAL].currentSocket = socket;
                super.createSocket(req, options, cb);
            })
            .catch((err) => {
                this.decrementSockets(name, fakeSocket);
                cb(err);
            });
    }

    createConnection() {
        const socket = this[INTERNAL].currentSocket;
        this[INTERNAL].currentSocket = undefined;
        if (!socket) {
            throw new Error('No socket was returned in the `connect()` function');
        }
        return socket;
    }

    get defaultPort() {
        return this[INTERNAL].defaultPort ?? (this.protocol === 'https:' ? 443 : 80);
    }

    set defaultPort(v) {
        if (this[INTERNAL]) {
            this[INTERNAL].defaultPort = v;
        }
    }

    get protocol() {
        return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? 'https:' : 'http:');
    }

    set protocol(v) {
        if (this[INTERNAL]) {
            this[INTERNAL].protocol = v;
        }
    }
}

exports.Agent = Agent;
```